<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliminador de Fondos (Color + Comparador) - XocoStudio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- === Dependencias img-comparison-slider === -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/img-comparison-slider@8/dist/index.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/img-comparison-slider@8/dist/style.css" />
    <!-- === FIN Dependencias === -->

<style>
    /* --- Estilos CSS (Optimizados + Añadidos) --- */
    body { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    /* Fondos */
    .checkerboard-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; background-color: #e5e5e5;}
    .solid-bg { background-image: none !important; } /* Para fondo sólido */
    /* Botones Activos */
    .tool-btn.active-tool { background-color: #d1d5db; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); }
    .tool-btn.active-hole-remover { background-color: #fde047 !important; color: #713f12 !important; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #ca8a04; }
    /* NUEVO: Estilo picker activo */
    .tool-btn.active-color-picker { background-color: #a5b4fc !important; color: #3730a3 !important; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #6366f1; }
    .brush-shape.active-shape { border-color: #3b82f6; border-width: 2px; }
    /* Canvas y Contenedores */
    #canvas-outer-container { width: 100%; height: 100%; overflow: hidden; position: relative; cursor: default; transition: background-color 0.3s ease; }
    #canvas-inner-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
    #image-canvas, #preview-canvas { display: block; position: absolute; top: 0; left: 0; max-width: none; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
    #preview-canvas { pointer-events: none; z-index: 1;} #image-canvas { z-index: 0; }
    main { height: calc(100vh - 64px - 32px); }
    /* Iconos Compuestos */
    .fa-line-eraser::before { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 1; } .fa-line-eraser::after { content: ""; position: absolute; left: 15%; top: 50%; width: 70%; height: 2px; background-color: currentColor; transform: translateY(-50%) rotate(0deg); opacity: 0.6; z-index: 0; } .tool-btn .fa-line-eraser { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } #eraser-line-tool i { font-size: 0.9em; } .fa-continuous-eraser-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } .fa-continuous-eraser-line::before { content: "\f55b"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; } .fa-continuous-eraser-line::after { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #ef4444; } #continuous-eraser-line-tool i { font-size: 1em; } .fa-continuous-keep-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } .fa-continuous-keep-line::before { content: "\f55b"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; } .fa-continuous-keep-line::after { content: "\f55d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #22c55e; } #continuous-keep-line-tool i { font-size: 1em; }
    /* Feedback Botones */
    .btn-feedback { transition: background-color 0.2s ease-out, color 0.2s ease-out, border-color 0.2s ease-out; } .btn-feedback.success { background-color: #22c55e !important; color: white !important; border-color: #16a34a !important; } .btn-feedback.error { background-color: #ef4444 !important; color: white !important; border-color: #dc2626 !important; } .btn-feedback.working { background-color: #eab308 !important; color: white !important; border-color: #ca8a04 !important; cursor: wait; } .btn-feedback.cancelling { background-color: #f97316 !important; color: white !important; border-color: #ea580c !important; cursor: default; }
    /* Overlay Procesamiento */
    .processing-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: none; } .processing-overlay i { margin-bottom: 10px; } .processing-overlay p { margin-top: 0px; font-size: 1.1rem; }
    /* NUEVO: Estilos Colores Seleccionados */
    .color-tag { display: inline-flex; align-items: center; background-color: #e5e7eb; border-radius: 9999px; padding: 2px 8px; margin: 2px; font-size: 0.8rem; line-height: 1; }
    .color-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; border: 1px solid #9ca3af; display: inline-block; }
    .remove-color-btn { margin-left: 4px; cursor: pointer; color: #ef4444; background: none; border: none; padding: 0; font-weight: bold; line-height: 1; }
    .remove-color-btn:hover { color: #dc2626; }
    #selected-colors-list { max-height: 80px; overflow-y: auto; background-color: #f9fafb; padding: 4px; border-radius: 4px; border: 1px solid #d1d5db; }
    /* === Estilos Popup Comparación === */
    #compare-popup-overlay { backdrop-filter: blur(3px); }
    #compare-popup-content img-comparison-slider {
         max-width: 100%; max-height: 100%; min-height: 200px;
         outline: none; border-radius: 0.25rem;
         box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
    }
    img-comparison-slider::part(handle) { color: #3b82f6; }
    img-comparison-slider::part(divider) { background-color: #3b82f6; }
    .compare-handle-icon { width: 100%; height: 100%; }
    /* === FIN Estilos Popup === */
</style>
Use code with caution.
</head>
<body class="bg-gray-100 flex flex-col min-h-screen overflow-hidden">
<header class="bg-white shadow-md p-4 flex-shrink-0 flex items-center">
    <a href="https://xocostudio.com/" target="_blank" rel="noopener noreferrer" class="mr-4 flex-shrink-0"><img src="https://xocostudio.com/assets/images/xocostudio-354x128.png" alt="XocoStudio Logo" class="h-8"></a>
    <h1 class="text-xl md:text-2xl font-bold text-gray-800">Eliminador de Fondos</h1>
</header>

<main class="flex-grow flex flex-col md:flex-row p-4 gap-4">
    <!-- Panel de Controles -->
    <aside class="w-full md:w-72 bg-white p-4 rounded-lg shadow space-y-6 flex-shrink-0 overflow-y-auto">
        <!-- Carga -->
        <div id="upload-section">
            <h2 class="text-lg font-semibold mb-2">1. Cargar Imagen</h2>
            <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors">
                <p>Arrastra y suelta</p>
                <p class="text-sm text-gray-500 my-2">o</p>
                <div class="flex flex-col items-center space-y-2">
                    <input type="file" id="file-input" accept="image/*" class="hidden">
                    <button id="upload-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded btn-feedback"><i class="fas fa-upload mr-1"></i> Seleccionar</button>
                    <button id="paste-btn" class="w-full bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Pegar (Ctrl+V)"><i class="fas fa-paste mr-1"></i> Pegar</button>
                </div>
                <p id="paste-support-warning" class="text-xs text-red-600 mt-2 hidden">Pegar no soportado.</p>
            </div>
            <p id="filename-display" class="text-xs text-gray-600 mt-2 truncate"></p>
        </div>
        <!-- Herramientas -->
        <div id="tools-section" class="space-y-4 hidden pt-4 border-t">
            <h2 class="text-lg font-semibold mb-2">2. Herramientas</h2>
            <!-- Auto / Color -->
            <div class="mb-4 space-y-2">
                <button id="remove-edge-bg-btn" class="w-full bg-cyan-600 hover:bg-cyan-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Fondo Automático basado en bordes"><i class="fas fa-wand-magic-sparkles mr-1"></i> Auto (Bordes)</button>
                <button id="remove-inner-hole-btn" class="tool-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Eliminar Hueco Interno (Clic en el hueco)"><i class="fas fa-highlighter mr-1"></i> Hueco (Clic)</button>
                <!-- NUEVO: Botón Aplicar Color -->
                <button id="apply-color-removal-btn" class="w-full bg-indigo-600 hover:bg-indigo-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Aplicar Eliminación por Color Seleccionado"><i class="fas fa-fill-drip mr-1"></i> Aplicar Color</button>
                <div class="mt-2">
                    <label for="edge-color-tolerance" class="block text-sm font-medium text-gray-700">Tolerancia (<span id="edge-color-tolerance-value">30</span>):</label>
                    <input type="range" id="edge-color-tolerance" min="1" max="150" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled>
                    <p class="text-xs text-gray-500 mt-1">Sensibilidad Auto/Hueco/Color.</p> <!-- Texto actualizado -->
                </div>
            </div>
            <!-- Manual -->
            <div class="border-t pt-4">
                <p class="text-sm font-medium text-gray-700 mb-2">Ajuste manual:</p>
                <div class="flex space-x-1 flex-wrap gap-y-1">
                    <!-- NUEVO: Botón Selector Color -->
                    <button id="color-picker-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Seleccionar Color (P)" disabled><i class="fas fa-eye-dropper fa-fw"></i></button>
                    <button id="brush-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Pincel Conservar (B)" disabled><i class="fas fa-paint-brush fa-fw"></i></button>
                    <button id="eraser-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Borrador Eliminar (E)" disabled><i class="fas fa-eraser fa-fw"></i></button>
                    <!-- <button id="magic-wand-tool" (eliminado, reemplazado por color picker) -->
                    <button id="line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Conservar (L)" disabled><i class="fas fa-minus fa-fw"></i></button>
                    <button id="eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Borrador (Shift+L)" disabled><i class="fa-line-eraser"></i></button>
                    <button id="continuous-keep-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trazo Conservar (C/W)" disabled><i class="fa-continuous-keep-line"></i></button>
                    <button id="continuous-eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trazo Borrar (X/Q)" disabled><i class="fa-continuous-eraser-line"></i></button>
                </div>
            </div>
             <!-- NUEVO: Sección Colores Seleccionados -->
             <div id="selected-colors-section" class="space-y-2 hidden pt-4 border-t">
                 <label class="block text-sm font-medium text-gray-700">Colores Seleccionados:</label>
                 <div id="selected-colors-list" class="text-xs text-gray-600">
                     <p id="no-colors-selected" class="italic text-center p-2">Ningún color. Usa <i class="fas fa-eye-dropper fa-fw"></i></p>
                 </div>
             </div>
             <!-- Opciones Herramienta -->
             <div id="brush-options-section" class="space-y-3 pt-4 border-t">
                 <p class="text-sm font-medium text-gray-700 mb-2">Opciones Herramienta:</p>
                 <div><label for="brush-size">Tamaño/Grosor: <span id="brush-size-value">50</span>px</label><input type="range" id="brush-size" min="1" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                 <div id="feather-option"><label for="brush-feather">Difuminado: <span id="brush-feather-value">0.10</span></label><input type="range" id="brush-feather" min="0" max="1" step="0.05" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" title="Suavizado pincel/borrador/color" disabled></div> <!-- Titulo actualizado -->
                 <div><label for="brush-opacity">Opacidad (Pincel): <span id="brush-opacity-value">1.00</span></label><input type="range" id="brush-opacity" min="0.05" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                 <div id="shape-option"><label>Forma (Pincel):</label><div class="flex space-x-2 mt-1"><button id="brush-shape-circle" class="brush-shape p-1 border rounded-full w-6 h-6 bg-gray-700 disabled:opacity-50" title="Circular" disabled></button><button id="brush-shape-square" class="brush-shape p-1 border rounded w-6 h-6 bg-gray-700 disabled:opacity-50" title="Cuadrado" disabled></button></div></div>
             </div>
             <!-- Acciones -->
             <div class="pt-4 border-t space-y-3">
                 <!-- Historial -->
                 <div class="flex space-x-2">
                     <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Deshacer (Ctrl+Z)" disabled><i class="fas fa-undo"></i> (<span id="undo-count">0</span>)</button>
                     <button id="redo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Rehacer (Ctrl+Y)" disabled><i class="fas fa-redo"></i> (<span id="redo-count">0</span>)</button> <!-- RE-AÑADIDO REDO -->
                     <button id="reset-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Resetear Máscara" disabled><i class="fas fa-trash-alt"></i> Reset</button>
                 </div>
                 <!-- NUEVO: Fondo Previsualización Unificado -->
                 <div id="preview-bg-section" class="hidden space-y-1">
                     <label class="block text-sm font-medium text-gray-700">Fondo Previsualización:</label>
                     <div class="flex items-center space-x-2">
                         <button id="preview-bg-toggle-btn" class="p-2 rounded hover:bg-gray-200 disabled:opacity-50 border border-gray-300" title="Cambiar fondo" disabled><i id="preview-bg-icon" class="fas fa-th fa-fw"></i></button>
                         <input type="color" id="preview-bg-color-input" value="#FFFFFF" class="h-8 w-10 border border-gray-300 rounded disabled:opacity-50 p-1 cursor-pointer" title="Color fondo sólido" disabled>
                     </div>
                 </div>
             </div>
        </div> <!-- Fin Tools Section -->

        <!-- Exportar / Copiar / Comparar -->
         <div id="export-section" class="hidden pt-4 border-t space-y-2">
             <h2 class="text-lg font-semibold mb-2">3. Guardar / Copiar</h2>
             <button id="export-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-download mr-1"></i> Exportar PNG</button>
             <button id="copy-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-copy mr-1"></i> Copiar Imagen</button>
             <button id="compare-btn" class="w-full bg-teal-500 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback mt-2" disabled><i class="fas fa-columns mr-1"></i> Comparar</button>
             <p id="clipboard-support-warning" class="text-xs text-red-600 text-center hidden">Copiar no soportado.</p>
        </div>
    </aside>
    <!-- Área de Trabajo -->
    <section class="flex-grow bg-gray-300 rounded-lg shadow overflow-hidden relative" id="canvas-section">
        <!-- Contenedor Canvas (se actualizará bg desde JS) -->
        <div id="canvas-outer-container">
            <div id="canvas-inner-container">
                <canvas id="image-canvas" class="hidden"></canvas>
                <canvas id="preview-canvas" class="hidden"></canvas>
            </div>
             <p id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">Carga una imagen</p>
        </div>
        <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-50 pointer-events-none"> <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i> <p class="text-lg font-semibold ml-3">Cargando...</p> </div>
        <div id="processing-overlay" class="processing-overlay hidden"> <i class="fas fa-spinner fa-spin fa-3x"></i> <p id="processing-status-text">Procesando...</p> </div>
        <div id="status-bar" class="absolute bottom-0 left-0 bg-black bg-opacity-60 text-white text-xs p-1 rounded-tr z-10 pointer-events-none">Zoom: <span id="zoom-level">100</span>% | Herramienta: <span id="current-tool-status">Ninguna</span> | Rueda=Zoom, Espacio+Arrastrar=Mover</div>
    </section>
</main>

<!-- === Popup de Comparación === -->
<div id="compare-popup-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[1000] hidden p-4">
    <div id="compare-popup-content" class="bg-gray-100 p-4 md:p-6 rounded-lg shadow-xl max-w-5xl w-full relative flex flex-col max-h-[90vh]">
        <button id="compare-popup-close" class="absolute top-2 right-2 text-gray-500 hover:text-red-600 text-3xl leading-none z-10 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow">×</button>
        <h3 class="text-xl md:text-2xl font-semibold mb-4 text-center text-gray-800 flex-shrink-0">Comparación Antes / Después</h3>
        <div id="compare-container-wrapper" class="relative w-full flex-grow overflow-auto flex items-center justify-center p-2 bg-gray-300 rounded">
            <img-comparison-slider class="rendered">
                <img id="compare-before-img" slot="first" src="" alt="Antes" />
                <img id="compare-after-img" slot="second" src="" alt="Después" />
                 <svg slot="handle" class="compare-handle-icon" xmlns="http://www.w3.org/2000/svg" width="40" viewBox="-8 -3 16 6">
                     <path d="M -5 -2 L -7 -2 L -7 2 L -5 2 L -5 3 L 5 3 L 5 2 L 7 2 L 7 -2 L 5 -2 L 5 -3 L -5 -3 L -5 -2" fill="currentColor" />
                     <path d="M -4 -1 L -4 1 L -2 1 L -2 -1 L -4 -1 M 2 -1 L 2 1 L 4 1 L 4 -1 L 2 -1" fill="#fff"/>
                 </svg>
            </img-comparison-slider>
        </div>
        <p class="text-center text-sm text-gray-600 mt-2 flex-shrink-0">Arrastra el control deslizante</p>
    </div>
</div>
<!-- === FIN Popup === -->


<script>
    document.addEventListener('DOMContentLoaded', async () => {
        await customElements.whenDefined('img-comparison-slider');
        console.log("DOM Cargado - XocoStudio BG Remover (Color + Comparador) - img-comparison-slider definido");

        // --- DOM Elements ---
        const dropZone = document.getElementById('drop-zone'),
            fileInput = document.getElementById('file-input'),
            uploadBtn = document.getElementById('upload-btn'),
            pasteBtn = document.getElementById('paste-btn'),
            pasteSupportWarning = document.getElementById('paste-support-warning'),
            filenameDisplay = document.getElementById('filename-display'),
            canvasSection = document.getElementById('canvas-section'), // Needed for bg change
            canvasOuterContainer = document.getElementById('canvas-outer-container'),
            canvasInnerContainer = document.getElementById('canvas-inner-container'),
            canvas = document.getElementById('image-canvas'),
            previewCanvas = document.getElementById('preview-canvas'),
            canvasPlaceholder = document.getElementById('canvas-placeholder'),
            loadingSpinner = document.getElementById('loading-spinner'),
            toolsSection = document.getElementById('tools-section'),
            exportSection = document.getElementById('export-section'),
            // Tool Buttons
            colorPickerBtn = document.getElementById('color-picker-tool'), // <-- NUEVO
            brushBtn = document.getElementById('brush-tool'),
            eraserBtn = document.getElementById('eraser-tool'),
            lineBtn = document.getElementById('line-tool'),
            eraserLineBtn = document.getElementById('eraser-line-tool'),
            continuousKeepLineBtn = document.getElementById('continuous-keep-line-tool'),
            continuousEraserLineBtn = document.getElementById('continuous-eraser-line-tool'),
            // Action Buttons
            removeEdgeBgBtn = document.getElementById('remove-edge-bg-btn'),
            removeInnerHoleBtn = document.getElementById('remove-inner-hole-btn'),
            applyColorRemovalBtn = document.getElementById('apply-color-removal-btn'), // <-- NUEVO
            // Options
            brushOptionsSection = document.getElementById('brush-options-section'),
            featherOptionDiv = document.getElementById('feather-option'),
            shapeOptionDiv = document.getElementById('shape-option'),
            brushSizeSlider = document.getElementById('brush-size'),
            brushSizeValue = document.getElementById('brush-size-value'),
            brushFeatherSlider = document.getElementById('brush-feather'),
            brushFeatherValue = document.getElementById('brush-feather-value'),
            brushOpacitySlider = document.getElementById('brush-opacity'),
            brushOpacityValue = document.getElementById('brush-opacity-value'),
            shapeCircleBtn = document.getElementById('brush-shape-circle'),
            shapeSquareBtn = document.getElementById('brush-shape-square'),
            edgeColorToleranceSlider = document.getElementById('edge-color-tolerance'),
            edgeColorToleranceValueSpan = document.getElementById('edge-color-tolerance-value'),
            // Selected Colors UI <-- NUEVO
            selectedColorsSection = document.getElementById('selected-colors-section'),
            selectedColorsListDiv = document.getElementById('selected-colors-list'),
            noColorsSelectedP = document.getElementById('no-colors-selected'),
            // History
            undoBtn = document.getElementById('undo-btn'),
            undoCountSpan = document.getElementById('undo-count'),
            redoBtn = document.getElementById('redo-btn'), // <-- RE-AÑADIDO
            redoCountSpan = document.getElementById('redo-count'), // <-- RE-AÑADIDO
            resetBtn = document.getElementById('reset-btn'),
            // Preview Background Controls <-- NUEVO (unificado)
            previewBgSection = document.getElementById('preview-bg-section'),
            previewBgToggleBtn = document.getElementById('preview-bg-toggle-btn'),
            previewBgIcon = document.getElementById('preview-bg-icon'),
            previewBgColorInput = document.getElementById('preview-bg-color-input'),
            // Export/Copy/Compare
            exportBtn = document.getElementById('export-btn'),
            copyBtn = document.getElementById('copy-btn'),
            clipboardSupportWarning = document.getElementById('clipboard-support-warning'),
            compareBtn = document.getElementById('compare-btn'),
            // Status/Overlays
            zoomLevelSpan = document.getElementById('zoom-level'),
            currentToolSpan = document.getElementById('current-tool-status'),
            processingOverlay = document.getElementById('processing-overlay'),
            processingStatusText = document.getElementById('processing-status-text'),
            // Compare Popup Elements
            comparePopupOverlay = document.getElementById('compare-popup-overlay'),
            comparePopupContent = document.getElementById('compare-popup-content'),
            comparePopupCloseBtn = document.getElementById('compare-popup-close'),
            compareBeforeImg = document.getElementById('compare-before-img'),
            compareAfterImg = document.getElementById('compare-after-img');

        // --- State Variables ---
        let ctx = null, previewCtx = null, maskCtx = null, originalImage = null, originalImageDataCache = null, maskCanvas = null, imageFilename = 'imagen';
        let isDrawing = false, lastX = 0, lastY = 0, history = [], redoHistory = []; // <-- RE-AÑADIDO redoHistory
        let currentTool = 'eraser', brushOptions = { size: 50, feather: 0.1, opacity: 1.0, shape: 'circle' };
        let zoomLevel = 1.0, panX = 0, panY = 0, isPanning = false, panStartX = 0, panStartY = 0, isSpacePressed = false;
        let isDrawingLine = false, lineStartX = 0, lineStartY = 0;
        let isDrawingContinuousLine = false, lastContinuousLinePoint = null;
        let currentMousePos = { x: 0, y: 0 };
        let isClipboardWriteSupported = !!(navigator.clipboard && navigator.clipboard.write);
        let isClipboardReadSupported = !!(navigator.clipboard && navigator.clipboard.read);
        let isFloodFilling = false, cancelFloodFillRequest = false;
        let waitingForInnerHoleClick = false, holeRemoverFeedbackTimeout = null;
        let isColorPickingActive = false, selectedBackgroundColors = [], isProcessingColorRemoval = false; // <-- NUEVO estado color
        let previewMode = 'checkerboard', previewBackgroundColor = '#FFFFFF'; // <-- NUEVO estado fondo preview
        let isComparePopupOpen = false;
        const MAX_HISTORY = 30;

        // --- Performance Throttling ---
        let lastRenderTime = 0; const RENDER_THROTTLE = 16; // ms

        // --- Verification ---
        if (!canvas || !previewCanvas || !dropZone || !fileInput || !uploadBtn || !pasteBtn || !removeEdgeBgBtn || !removeInnerHoleBtn || !continuousKeepLineBtn || !continuousEraserLineBtn || !canvasOuterContainer || !canvasInnerContainer || !previewBgSection || !previewBgToggleBtn || !previewBgIcon || !previewBgColorInput || !toolsSection || !exportSection || !colorPickerBtn || !applyColorRemovalBtn || !selectedColorsSection || !selectedColorsListDiv || !compareBtn || !comparePopupOverlay || !comparePopupCloseBtn || !compareBeforeImg || !compareAfterImg || !undoBtn || !redoBtn || !resetBtn ) { console.error("ERROR CRÍTICO: Falta elemento DOM."); alert("Error: No se pudo iniciar."); return; }
        console.log("Elementos DOM OK.");

        // --- Initialization ---
        setActiveTool('eraser');
        updateToolOptionsDisplay();
        setupImageLoadingListeners();
        setupInteractionListeners();
        setupToolControlListeners();
        setupPreviewBackgroundListeners(); // <-- Setup para nuevo control de fondo
        setupComparePopupListeners();
        checkClipboardSupport();
        updateActionButtonsState();
        updatePreviewBackground(); // <-- Llamada inicial para fondo
        updateSelectedColorsUI(); // <-- Llamada inicial para UI colores
        console.log("Inicialización completada.");

        // --- Helper Functions ---
        function cancelContinuousLineDrawing(silent = false) {
            if (isDrawingContinuousLine) {
                if (!silent) console.log("Cancelando trazo continuo.");
                isDrawingContinuousLine = false; lastContinuousLinePoint = null; clearPreviewCanvas(); updateStatusBar();
                canvasOuterContainer.style.cursor = getToolCursor(); updateActionButtonsState();
                if (!isComparePopupOpen && !isColorPickingActive) drawToolPreview(currentMousePos.x, currentMousePos.y);
                return true;
            }
            return false;
        }
        function cancelCurrentAction(silent = false) {
            let actionCancelled = false;
            if (isColorPickingActive) {
                if (!silent) console.log("Cancelando modo Selección Color.");
                isColorPickingActive = false;
                actionCancelled = true;
            }
            if (waitingForInnerHoleClick) {
                if (!silent) console.log("Cancelando modo Eliminar Hueco.");
                 // Directly update state, UI update happens below
                waitingForInnerHoleClick = false;
                if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);
                holeRemoverFeedbackTimeout = null;
                // Reset button appearance without triggering setActiveTool if popup open
                if (removeInnerHoleBtn) {
                     removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error', 'working', 'cancelling');
                     if (removeInnerHoleBtn.dataset.originalHtml) removeInnerHoleBtn.innerHTML = removeInnerHoleBtn.dataset.originalHtml;
                     if (removeInnerHoleBtn.dataset.originalTitle) removeInnerHoleBtn.title = removeInnerHoleBtn.dataset.originalTitle;
                }
                actionCancelled = true;
            }
            if (isDrawingLine) {
                if (!silent) console.log("Cancelando dibujo de línea.");
                isDrawingLine = false; clearPreviewCanvas(); actionCancelled = true;
            }
            if (cancelContinuousLineDrawing(silent)) actionCancelled = true;
            if (isDrawing) {
                if (!silent) console.log("Cancelando dibujo.");
                isDrawing = false; actionCancelled = true;
            }

            if (actionCancelled) {
                canvasOuterContainer.style.cursor = getToolCursor();
                updateStatusBar();
                updateActionButtonsState(); // Update all buttons after any cancellation
                updateSelectedColorsUI(); // Update color UI as picker might have been cancelled
                if (!isComparePopupOpen && !isColorPickingActive && !waitingForInnerHoleClick) {
                    drawToolPreview(currentMousePos.x, currentMousePos.y); // Draw preview if needed
                }
            }
            return actionCancelled;
        }
        function simulateEscapeKeyPressLogic() {
            // Priority 1: Close Compare Popup if open
            if (isComparePopupOpen) {
                closeComparePopup();
                console.log("Popup cerrado por Esc.");
                return true;
            }
            // Priority 2: Cancel any ongoing user action
            if (cancelCurrentAction(true)) { // Use silent cancel here
                console.log("Acción cancelada por Esc (Color Picker, Hole Click, Drawing, Line).");
                 // Redraw preview only if not entering another special mode
                 if (!isComparePopupOpen && !isColorPickingActive && !waitingForInnerHoleClick) {
                     drawToolPreview(currentMousePos.x, currentMousePos.y);
                 }
                return true;
            }
            // If nothing else was cancelled, return false
            return false;
        }
        function isGenerallyIdle() { // Renamed to avoid confusion with popup state
             return !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !waitingForInnerHoleClick && !isColorPickingActive && !isFloodFilling && !isProcessingColorRemoval && !isPanning;
        }


        // --- Setup Functions ---
        function setupImageLoadingListeners() { console.log("Configurando listeners carga..."); dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); const f = e.dataTransfer?.files?.[0]; if (f?.type.startsWith('image/')) handleFile(f); else if (f) alert('Suelta imagen válida.'); }); uploadBtn.addEventListener('click', () => fileInput.click()); pasteBtn.addEventListener('click', handlePasteButtonClick); fileInput.addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f?.type.startsWith('image/')) { handleFile(f); e.target.value = null; } else if (f) alert('Selecciona imagen válida.'); }); window.addEventListener('paste', (e) => { const a = document.activeElement; if (isComparePopupOpen || a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.isContentEditable) return; if (handleClipboardPaste(e.clipboardData)) e.preventDefault(); }); console.log("Listeners carga añadidos."); }
        function setupInteractionListeners() { console.log("Configurando listeners interacción..."); window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); canvasOuterContainer.addEventListener('mousedown', handleInteractionStart); canvasOuterContainer.addEventListener('mousemove', handleInteractionMove); window.addEventListener('mouseup', handleInteractionEnd); canvasOuterContainer.addEventListener('touchstart', (e) => handleInteractionStart(e.touches[0]), { passive: false }); canvasOuterContainer.addEventListener('touchmove', (e) => handleInteractionMove(e.touches[0]), { passive: false }); window.addEventListener('touchend', (e) => handleInteractionEnd(e.changedTouches[0])); window.addEventListener('touchcancel', (e) => handleInteractionEnd(e.changedTouches[0])); canvasOuterContainer.addEventListener('wheel', handleWheelZoom, { passive: false }); canvasOuterContainer.addEventListener('mouseleave', () => { if (!isDrawingLine && !isDrawingContinuousLine && !isComparePopupOpen && !isColorPickingActive) clearPreviewCanvas(); }); console.log("Listeners interacción añadidos."); }
        function setupToolControlListeners() {
             console.log("Configurando listeners herramientas (con color)...");
             // Tool selection buttons
             colorPickerBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('color-picker'); });
             brushBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('brush'); });
             eraserBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('eraser'); });
             lineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('line'); });
             eraserLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('eraser-line'); });
             continuousKeepLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('continuous-keep-line'); });
             continuousEraserLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('continuous-eraser-line'); });

             // Tool options (mostly blocked by popup check or state checks within handlers)
             brushSizeSlider.addEventListener('input', (e) => { if (isComparePopupOpen) return; brushOptions.size = parseInt(e.target.value); updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             brushFeatherSlider.addEventListener('input', (e) => { if (isComparePopupOpen && !isColorPickingActive) return; brushOptions.feather = parseFloat(e.target.value); updateToolOptionsDisplay(); if(!isColorPickingActive) drawToolPreview(currentMousePos.x, currentMousePos.y); }); // Allow feather change for color picker
             brushOpacitySlider.addEventListener('input', (e) => { if (isComparePopupOpen) return; brushOptions.opacity = parseFloat(e.target.value); updateToolOptionsDisplay(); });
             shapeCircleBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'circle'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             shapeSquareBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'square'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             edgeColorToleranceSlider.addEventListener('input', (e) => { edgeColorToleranceValueSpan.textContent = e.target.value; }); // Allow tolerance change always (needed for color/hole/auto)

             // History/Reset (blocked by popup check)
             undoBtn.addEventListener('click', () => { if (isComparePopupOpen) return; undo(); });
             redoBtn.addEventListener('click', () => { if (isComparePopupOpen) return; redo(); }); // <-- Listener RE-AÑADIDO
             resetBtn.addEventListener('click', () => { if (isComparePopupOpen || !originalImage || history.length <= 1) return; if (confirm('¿Estás seguro de que quieres resetear todas las ediciones?')) { cancelCurrentAction(true); resetMask(); selectedBackgroundColors = []; updateSelectedColorsUI(); } });

             // Export/Copy (blocked by popup check in handlers)
             exportBtn.addEventListener('click', exportImage);
             copyBtn.addEventListener('click', copyImageToClipboard);

             // Auto/Hole/Color Actions
             removeEdgeBgBtn.addEventListener('click', () => { if (isComparePopupOpen) return; cancelCurrentAction(true); if (isFloodFilling) { console.log("%cSolicitando cancelación BG...", 'color: orange;'); cancelFloodFillRequest = true; processingStatusText.textContent = "Cancelando..."; showButtonFeedback(removeEdgeBgBtn, 'cancelling', 'Cancelando...', 60000); } else if (isGenerallyIdle()) { handleRemoveBackgroundByFloodFill(); } else console.warn("Intento Auto BG mientras no idle."); });
             // *** MODIFIED: Inner Hole Button Listener (allows activation during compare) ***
             removeInnerHoleBtn.addEventListener('click', () => {
                 // Block only if actively processing something else
                 if (isFloodFilling || isProcessingColorRemoval) {
                     console.warn("Ignorando clic en Hueco: Proceso activo.");
                     showButtonFeedback(removeInnerHoleBtn, 'error', 'Ocupado', 1000);
                     return;
                 }
                 if (waitingForInnerHoleClick) {
                     cancelCurrentAction(true); // Use general cancel
                 } else {
                     cancelCurrentAction(true); // Cancel other things first
                     activateInnerHoleClickMode(); // Try to activate
                 }
             });
            applyColorRemovalBtn.addEventListener('click', () => { if (isComparePopupOpen) return; cancelCurrentAction(true); if (!originalImage || selectedBackgroundColors.length === 0 || isFloodFilling || isProcessingColorRemoval) { console.warn("Aplicar Color bloqueado."); return; } if (isGenerallyIdle()) applyColorRemoval(); else console.warn("Intento Aplicar Color no idle."); });
            // Listener para eliminar colores de la lista
            selectedColorsListDiv.addEventListener('click', (e) => { if (e.target.classList.contains('remove-color-btn')) { const r = parseInt(e.target.dataset.r, 10), g = parseInt(e.target.dataset.g, 10), b = parseInt(e.target.dataset.b, 10); removeSelectedColor(r, g, b); } });

             console.log("Listeners herramientas añadidos (con color).");
        }
        function setupPreviewBackgroundListeners() { console.log("Configurando listeners preview bg..."); if (!previewBgToggleBtn || !previewBgColorInput) { console.error("Faltan controles preview bg."); return; } previewBgToggleBtn.addEventListener('click', () => { if (!originalImage || isComparePopupOpen) return; previewMode = (previewMode === 'checkerboard') ? 'solid' : 'checkerboard'; console.log("Modo fondo:", previewMode); updatePreviewBackground(); updateActionButtonsState(); }); previewBgColorInput.addEventListener('input', (e) => { if (!originalImage || isComparePopupOpen) return; previewBackgroundColor = e.target.value; if (previewMode === 'solid') { console.log("Color fondo:", previewBackgroundColor); updatePreviewBackground(); } }); console.log("Listeners preview bg añadidos."); }
        function setupComparePopupListeners() { console.log("Configurando listeners popup compare..."); if (!compareBtn || !comparePopupOverlay || !comparePopupCloseBtn) { console.error("Faltan elementos popup compare."); return; } compareBtn.addEventListener('click', openComparePopup); comparePopupCloseBtn.addEventListener('click', closeComparePopup); comparePopupOverlay.addEventListener('click', (e) => { if (e.target === comparePopupOverlay) closeComparePopup(); }); console.log("Listeners popup compare añadidos."); }

        // --- Core Logic ---
        function handleFile(file) { console.log('>>> handleFile:', file?.name); cancelCurrentAction(true); if (!file?.type?.startsWith('image/')) { alert('Archivo no válido.'); console.error('Tipo inválido:', file?.type); return; } const reader = new FileReader(); reader.onloadstart = () => { console.log('   onloadstart'); showLoadingState(file.name); }; reader.onload = (e) => { console.log('   onload'); if (!e.target?.result) { handleLoadingError(file.name, 'Error leer archivo.'); return; } originalImage = new Image(); originalImage.onload = () => { console.log(`  onload OK: ${originalImage.naturalWidth}x${originalImage.naturalHeight}`); if (originalImage.naturalWidth === 0 || originalImage.naturalHeight === 0) { handleLoadingError(file.name, 'Dimensiones 0x0.'); originalImage = null; return; } initializeEditor(file.name, originalImage); }; originalImage.onerror = (err) => { console.error('onerror:', err); handleLoadingError(file.name, 'Error decodificar imagen.'); originalImage = null; }; originalImage.src = e.target.result; }; reader.onerror = (err) => { console.error('reader.onerror:', err); handleLoadingError(file.name, 'Error lectura.'); }; try { reader.readAsDataURL(file); } catch (error) { console.error("Error readAsDataURL:", error); handleLoadingError(file.name, 'Error iniciar lectura.'); } }
        function showLoadingState(fileName) { console.log("Loading state:", fileName); cancelCurrentAction(true); closeComparePopup(true); loadingSpinner.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden'); filenameDisplay.textContent = `Cargando: ${fileName}...`; toolsSection.classList.add('hidden'); previewBgSection.classList.add('hidden'); exportSection.classList.add('hidden'); canvas.classList.add('hidden'); previewCanvas.classList.add('hidden'); originalImage = null; originalImageDataCache = null; ctx = previewCtx = maskCtx = null; history = []; redoHistory = []; selectedBackgroundColors = []; updateSelectedColorsUI(); updateActionButtonsState(); }
        function handleLoadingError(fileName, message) { console.error(`Error cargando ${fileName || 'img'}: ${message}`); cancelCurrentAction(true); closeComparePopup(true); alert(`Error cargar "${fileName || 'img'}":\n${message}`); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.remove('hidden'); filenameDisplay.textContent = `Error carga`; toolsSection.classList.add('hidden'); previewBgSection.classList.add('hidden'); exportSection.classList.add('hidden'); originalImage = null; originalImageDataCache = null; ctx = previewCtx = maskCtx = null; history = []; redoHistory = []; selectedBackgroundColors = []; updateSelectedColorsUI(); updateActionButtonsState(); }
        function initializeEditor(fileName, loadedImage) { console.log(">>> initializeEditor:", fileName); cancelCurrentAction(true); closeComparePopup(true); if (!loadedImage || !loadedImage.naturalWidth || !loadedImage.naturalHeight) { handleLoadingError(fileName, "Datos imagen inválidos."); return; } imageFilename = fileName.replace(/\.[^/.]+$/, "") || 'imagen_editada'; filenameDisplay.textContent = `Editando: ${fileName} (${loadedImage.naturalWidth}x${loadedImage.naturalHeight})`; try { ctx = canvas.getContext('2d', { willReadFrequently: false }); previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true }); if (!ctx || !previewCtx) throw new Error("Contextos principales null."); console.log("   Contextos OK."); } catch (e) { console.error("ERROR FATAL contextos:", e); handleLoadingError(fileName, "Error interno contexto."); return; } if (!setupCanvases(loadedImage)) { handleLoadingError(fileName, "Error configurando lienzos."); return; } cacheOriginalImageData(); resetMask(); // Resets history
             selectedBackgroundColors = []; // Clear colors on new image
             updateSelectedColorsUI(); // Update UI
             centerAndFitImage(); requestRender(); toolsSection.classList.remove('hidden'); previewBgSection.classList.remove('hidden'); exportSection.classList.remove('hidden'); canvas.classList.remove('hidden'); previewCanvas.classList.remove('hidden'); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.add('hidden'); setActiveTool('eraser'); updatePreviewBackground(); updateActionButtonsState(); console.log("<<< initializeEditor completado."); }
        function setupCanvases(img) { console.log(">>> setupCanvases"); if (!img?.naturalWidth || !img?.naturalHeight || !canvas || !previewCanvas || !canvasInnerContainer) return false; const w = img.naturalWidth, h = img.naturalHeight; canvas.width = w; canvas.height = h; previewCanvas.width = w; previewCanvas.height = h; canvasInnerContainer.style.width = `${w}px`; canvasInnerContainer.style.height = `${h}px`; try { maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h; maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true }); if (!maskCtx) throw new Error("maskCtx null."); console.log("   maskCtx creado."); } catch (e) { alert("Error fatal: No se pudo crear máscara."); console.error("Error creando maskCtx:", e); maskCanvas = maskCtx = null; return false; } console.log(`   Canvases ${w}x${h}`); return true; }
        function cacheOriginalImageData() { if (!originalImage || !canvas || !maskCanvas) { originalImageDataCache = null; console.warn("No se pudo cachear ImageData."); return; } console.log("Cacheando ImageData..."); const tempC = document.createElement('canvas'); tempC.width = originalImage.naturalWidth; tempC.height = originalImage.naturalHeight; const tempCtx = tempC.getContext('2d', { willReadFrequently: true }); if (!tempCtx) { console.error("Error ctx temporal cache."); originalImageDataCache = null; return; } try { tempCtx.drawImage(originalImage, 0, 0); originalImageDataCache = tempCtx.getImageData(0, 0, tempC.width, tempC.height); console.log("   ImageData cacheada OK."); } catch (e) { console.error("Error getImageData cache (¿CORS?):", e); alert("Advertencia: No se pudo acceder a píxeles originales (¿CORS?). Herramientas auto/color pueden fallar."); originalImageDataCache = null; } }
        function centerAndFitImage() { if (!originalImage || !canvasOuterContainer) return; const imgW = originalImage.naturalWidth, imgH = originalImage.naturalHeight; const contW = canvasOuterContainer.clientWidth, contH = canvasOuterContainer.clientHeight; if (contW <= 0 || contH <= 0) { console.warn("Contenedor sin dimensiones."); return; } zoomLevel = Math.min(1, Math.min(contW / imgW, contH / imgH) * 0.95); panX = (contW - imgW * zoomLevel) / 2; panY = (contH - imgH * zoomLevel) / 2; updateTransform(); updateStatusBar(); console.log(`Imagen centrada: zoom=${zoomLevel.toFixed(2)}, panX=${panX.toFixed(0)}, panY=${panY.toFixed(0)}`); }
        function resetMask() { if (!maskCtx || !maskCanvas || !originalImage) return; console.log("Reseteando máscara."); maskCtx.fillStyle = 'white'; maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height); history = []; redoHistory = []; saveStateToHistory(); updateActionButtonsState(); requestRender(); }

        // --- Rendering & Previews ---
        function requestRender() { const n = performance.now(); if (n - lastRenderTime >= RENDER_THROTTLE) { renderCanvas(); lastRenderTime = n; } }
        function renderCanvas() { if (!ctx || !originalImage || !maskCanvas) return; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(originalImage, 0, 0); ctx.globalCompositeOperation = 'destination-in'; ctx.drawImage(maskCanvas, 0, 0); ctx.globalCompositeOperation = 'source-over'; }
        function clearPreviewCanvas() { if (previewCtx) previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height); }
        function drawToolPreview(ix, iy) {
             clearPreviewCanvas();
             // Block preview if comparing, panning, processing, or in a click-based mode
             if (isComparePopupOpen || isPanning || isFloodFilling || isProcessingColorRemoval || isColorPickingActive || waitingForInnerHoleClick) return;
             // Draw preview based on current tool
             if (currentTool === 'brush' || currentTool === 'eraser') drawBrushPreview(ix, iy);
             else if (isDrawingLine && (currentTool === 'line' || currentTool === 'eraser-line')) { drawSimpleLineMarker(lineStartX, lineStartY); drawSimpleLinePreview(lineStartX, lineStartY, ix, iy); }
             else if (isDrawingContinuousLine && (currentTool === 'continuous-keep-line' || currentTool === 'continuous-eraser-line')) { if (lastContinuousLinePoint) { drawContinuousLineMarker(lastContinuousLinePoint.x, lastContinuousLinePoint.y); drawContinuousLinePreview(lastContinuousLinePoint.x, lastContinuousLinePoint.y, ix, iy); } }
             else if (['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line'].includes(currentTool)) drawCrosshairPreview(ix, iy);
        }
        function drawBrushPreview(ix, iy) { if (!previewCtx || !originalImage) return; const s = brushOptions.size, f = s * brushOptions.feather, sr = Math.max(0, s / 2 - f / 2), tr = s / 2; previewCtx.save(); previewCtx.globalAlpha = 0.6; const pc = (currentTool === 'eraser') ? 'rgba(255,0,0,0.7)' : 'rgba(0,0,0,0.7)', oc = 'rgba(255,255,255,0.9)'; if (brushOptions.shape === 'circle') { const g = previewCtx.createRadialGradient(ix, iy, sr, ix, iy, tr); g.addColorStop(0, pc); g.addColorStop(1, 'rgba(0,0,0,0)'); previewCtx.fillStyle = g; previewCtx.beginPath(); previewCtx.arc(ix, iy, tr, 0, Math.PI * 2); previewCtx.fill(); previewCtx.strokeStyle = oc; previewCtx.lineWidth = 1 / zoomLevel; previewCtx.stroke(); } else { const hs = s / 2; previewCtx.fillStyle = pc; previewCtx.fillRect(ix - hs, iy - hs, s, s); previewCtx.strokeStyle = oc; previewCtx.lineWidth = 1 / zoomLevel; previewCtx.strokeRect(ix - hs, iy - hs, s, s); } previewCtx.restore(); }
        function drawSimpleLineMarker(ix, iy) { if (!previewCtx) return; const k = currentTool === 'line'; previewCtx.fillStyle = k ? 'rgba(0,255,0,0.7)' : 'rgba(255,0,0,0.7)'; previewCtx.beginPath(); previewCtx.arc(ix, iy, 5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }
        function drawSimpleLinePreview(sx, sy, ex, ey) { if (!previewCtx) return; const k = currentTool === 'line'; previewCtx.save(); previewCtx.beginPath(); previewCtx.moveTo(sx, sy); previewCtx.lineTo(ex, ey); previewCtx.strokeStyle = k ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'; previewCtx.lineWidth = brushOptions.size; previewCtx.lineCap = 'round'; previewCtx.stroke(); previewCtx.restore(); }
        function drawContinuousLineMarker(ix, iy) { if (!previewCtx) return; const k = currentTool === 'continuous-keep-line'; previewCtx.fillStyle = k ? 'rgba(0,255,0,0.8)' : 'rgba(255,0,0,0.8)'; previewCtx.beginPath(); previewCtx.arc(ix, iy, 4 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }
        function drawContinuousLinePreview(sx, sy, ex, ey) { if (!previewCtx) return; const k = currentTool === 'continuous-keep-line'; previewCtx.save(); previewCtx.beginPath(); previewCtx.moveTo(sx, sy); previewCtx.lineTo(ex, ey); previewCtx.strokeStyle = k ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'; previewCtx.lineWidth = brushOptions.size; previewCtx.lineCap = 'round'; previewCtx.stroke(); previewCtx.restore(); }
        function drawCrosshairPreview(ix, iy) { if (!previewCtx) return; const cs = 10 / zoomLevel; previewCtx.save(); previewCtx.strokeStyle = 'rgba(0,0,0,0.6)'; previewCtx.lineWidth = 1 / zoomLevel; previewCtx.beginPath(); previewCtx.moveTo(ix - cs, iy); previewCtx.lineTo(ix + cs, iy); previewCtx.moveTo(ix, iy - cs); previewCtx.lineTo(ix, iy + cs); previewCtx.stroke(); previewCtx.restore(); }

        // --- Mask Modification ---
        function applyMaskModification(dx, dy, t, o) { if (!maskCtx || (t !== 'brush' && t !== 'eraser')) return; const ie = t === 'eraser'; maskCtx.save(); maskCtx.globalCompositeOperation = ie ? 'destination-out' : 'source-over'; const s = o.size, hs = s / 2, f = o.feather, op = o.opacity, c = ie ? '0,0,0' : '255,255,255'; if (o.shape === 'circle') { const sr = Math.max(0, hs * (1 - f)), g = maskCtx.createRadialGradient(dx, dy, sr, dx, dy, hs); g.addColorStop(0, `rgba(${c}, ${op})`); g.addColorStop(1, `rgba(${c}, 0)`); maskCtx.fillStyle = g; maskCtx.beginPath(); maskCtx.arc(dx, dy, hs, 0, Math.PI * 2); maskCtx.fill(); } else { maskCtx.fillStyle = `rgba(${c}, ${op})`; maskCtx.fillRect(dx - hs, dy - hs, s, s); } maskCtx.restore(); }
        function drawLineOnMask(x1, y1, x2, y2, t, o) { if (!maskCtx) return; const ie = t === 'eraser' || t === 'eraser-line' || t === 'continuous-eraser-line', s = o.size, op = o.opacity; maskCtx.save(); maskCtx.globalCompositeOperation = ie ? 'destination-out' : 'source-over'; maskCtx.beginPath(); maskCtx.moveTo(x1, y1); maskCtx.lineTo(x2, y2); maskCtx.lineWidth = s; maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round'; const c = ie ? `rgba(0,0,0,${op})` : `rgba(255,255,255,${op})`; maskCtx.strokeStyle = c; maskCtx.stroke(); maskCtx.restore(); requestRender(); }

        // --- Interaction Handling ---
        function getInteractionPos(e) { if (!canvasOuterContainer) return { screenX: 0, screenY: 0, imageX: 0, imageY: 0 }; const r = canvasOuterContainer.getBoundingClientRect(), cx = e.clientX ?? e.pageX ?? 0, cy = e.clientY ?? e.pageY ?? 0, sx = cx - r.left, sy = cy - r.top, ix = (sx - panX) / zoomLevel, iy = (sy - panY) / zoomLevel; return { screenX: sx, screenY: sy, imageX: ix, imageY: iy }; }
        function handleInteractionStart(e) {
            // Priority 1: Color Picking (even if popup open? NO, block if popup open)
            if (isColorPickingActive && !isComparePopupOpen) {
                if (!originalImage) return; // Need image data
                if (e.preventDefault && e.cancelable) e.preventDefault();
                const { imageX: ix, imageY: iy } = getInteractionPos(e);
                pickColorAt(ix, iy);
                return; // Stop further processing
            }

            // Priority 2: Hole Clicking (handles its own check for compare popup)
            if (waitingForInnerHoleClick) {
                 // Basic checks still needed
                 if (!originalImage || isFloodFilling || isProcessingColorRemoval) {
                     console.warn("Interacción de Clic-Hueco ignorada: Sin imagen o proceso activo.");
                     return;
                 }
                 if (e.preventDefault && e.cancelable) e.preventDefault();
                 const { imageX: ix, imageY: iy } = getInteractionPos(e);
                 removeInnerHoleAt(ix, iy); // Attempt to remove the hole
                 return; // Stop further processing for this click
             }

            // Block other interactions if popup is open or processing
            if (isComparePopupOpen || !originalImage || isFloodFilling || isProcessingColorRemoval) {
                 // console.log("Interaction blocked: Popup open or invalid state."); // Optional debug
                 return;
            }

            // Standard Interaction Logic (popup closed, not picking, not waiting for hole)
            if (e.preventDefault && e.cancelable) e.preventDefault();
            const { screenX: sx, screenY: sy, imageX: ix, imageY: iy } = getInteractionPos(e);

            if (isSpacePressed) { isPanning = true; panStartX = sx - panX; panStartY = sy - panY; canvasOuterContainer.style.cursor = 'grabbing'; return; }

            switch (currentTool) {
                case 'line': case 'eraser-line':
                    if (!isDrawingLine) { isDrawingLine = true; lineStartX = ix; lineStartY = iy; updateActionButtonsState(); drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'crosshair'; }
                    else { drawLineOnMask(lineStartX, lineStartY, ix, iy, currentTool, brushOptions); saveStateToHistory(); isDrawingLine = false; clearPreviewCanvas(); updateActionButtonsState(); canvasOuterContainer.style.cursor = getToolCursor(); drawToolPreview(ix, iy); }
                    break;
                case 'continuous-keep-line': case 'continuous-eraser-line':
                    if (!isDrawingContinuousLine) { isDrawingContinuousLine = true; lastContinuousLinePoint = { x: ix, y: iy }; updateActionButtonsState(); drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'crosshair'; }
                    else { drawLineOnMask(lastContinuousLinePoint.x, lastContinuousLinePoint.y, ix, iy, currentTool, brushOptions); lastContinuousLinePoint = { x: ix, y: iy }; saveStateToHistory(); drawToolPreview(ix, iy); }
                    break;
                case 'brush': case 'eraser': default: // Includes cases where tool isn't explicitly handled
                    if (isDrawingLine) { isDrawingLine = false; clearPreviewCanvas(); updateActionButtonsState(); } // End line if switching
                    cancelContinuousLineDrawing(true); // End continuous line if switching
                    isDrawing = true; lastX = ix; lastY = iy; updateActionButtonsState(); applyMaskModification(ix, iy, currentTool, brushOptions); requestRender(); canvasOuterContainer.style.cursor = 'none'; drawToolPreview(ix, iy);
                    break;
            }
        }
        function handleInteractionMove(e) {
             // Block move processing if compare popup is open (unless waiting for hole click, handled separately)
             // Also block if picking color
             if ((isComparePopupOpen && !waitingForInnerHoleClick) || isColorPickingActive) {
                // Keep cursor updated if needed
                 canvasOuterContainer.style.cursor = getToolCursor();
                 return;
             }
            // If waiting for hole click, just update cursor
            if (waitingForInnerHoleClick) {
                canvasOuterContainer.style.cursor = getToolCursor();
                return;
            }

            // Standard move logic (popup closed, not picking, not waiting)
            if (!originalImage) return;
            const { screenX: sx, screenY: sy, imageX: ix, imageY: iy } = getInteractionPos(e); currentMousePos = { x: ix, y: iy };
            const busy = isFloodFilling || isProcessingColorRemoval; // Removed hole/picker checks here

            if (isPanning) { panX = sx - panStartX; panY = sy - panStartY; updateTransform(); updateStatusBar(); }
            else if (busy) { canvasOuterContainer.style.cursor = getToolCursor(); clearPreviewCanvas(); } // Show normal cursor if busy
            else if (isDrawing) { drawLineOnMask(lastX, lastY, ix, iy, currentTool, brushOptions); lastX = ix; lastY = iy; drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'none'; }
            else { drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = (currentTool === 'brush' || currentTool === 'eraser') ? 'none' : getToolCursor(); } // Draw tool preview if idle
        }
        function handleInteractionEnd(e) {
            // End logic doesn't apply if compare popup is open or color picking
            if (isComparePopupOpen || isColorPickingActive) return;
            // Hole click end is handled within removeInnerHoleAt

            // Standard end logic
            if (isPanning) { isPanning = false; canvasOuterContainer.style.cursor = getToolCursor(); }
            else if (isDrawing) { isDrawing = false; saveStateToHistory(); updateActionButtonsState(); canvasOuterContainer.style.cursor = 'none'; drawToolPreview(currentMousePos.x, currentMousePos.y); }
        }
        function handleKeyDown(e) {
            // Handle Esc for popup FIRST
            if (isComparePopupOpen && e.key === 'Escape') {
                e.preventDefault(); closeComparePopup(); return;
            }
            // If popup is open, block other shortcuts
            if (isComparePopupOpen) return;

            // --- Keydown Logic (popup closed) ---
            const finp = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable;
            if (e.key === 'Escape') { const c = simulateEscapeKeyPressLogic(); if (c || !finp) e.preventDefault(); return; }

            const idle = isGenerallyIdle();
            if (e.key === ' ' && !isSpacePressed && !e.repeat && idle && !finp) { isSpacePressed = true; canvasOuterContainer.style.cursor = 'grab'; e.preventDefault(); }
            // History shortcuts (Ctrl+Z / Ctrl+Y / Ctrl+Shift+Z)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey && !e.repeat) { if (idle) { e.preventDefault(); undo(); } else console.log("Undo bloqueado."); }
            if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z')) && !e.repeat) { if (idle) { e.preventDefault(); redo(); } else console.log("Redo bloqueado."); }

            // Tool shortcuts (only if idle and not typing in input)
            if (idle && !finp && !e.ctrlKey && !e.altKey && !e.metaKey) {
                const k = e.key.toLowerCase();
                let targetTool = null;
                switch (k) {
                    case 'p': targetTool = 'color-picker'; break;
                    case 'b': targetTool = 'brush'; break;
                    case 'e': targetTool = 'eraser'; break;
                    case 'l': targetTool = e.shiftKey ? 'eraser-line' : 'line'; break;
                    case 'c': case 'w': targetTool = 'continuous-keep-line'; break;
                    case 'x': case 'q': targetTool = 'continuous-eraser-line'; break;
                }
                if (targetTool) {
                    e.preventDefault();
                    setActiveTool(targetTool);
                }
            }
        }
        function handleKeyUp(e) {
            if (isComparePopupOpen && e.key !== ' ') return; // Block most keyups if popup open
            if (e.key === ' ') { isSpacePressed = false; if (!isPanning) canvasOuterContainer.style.cursor = getToolCursor(); e.preventDefault(); }
        }
        function handleWheelZoom(e) {
            // Block zoom if comparing, processing, or picking color
            if (isComparePopupOpen || !originalImage || !isGenerallyIdle()) return;
            e.preventDefault();
            const { screenX: sx, screenY: sy } = getInteractionPos(e);
            const zf = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            zoomInOut(zf, sx, sy);
        }
        function zoomInOut(f, px, py) { if (!originalImage) return; const cz = zoomLevel, nz = Math.max(0.1, Math.min(cz * f, 15)); if (nz === cz) return; const dx = (px - panX) * (nz / cz - 1), dy = (py - panY) * (nz / cz - 1); zoomLevel = nz; panX -= dx; panY -= dy; updateTransform(); updateStatusBar(); clearPreviewCanvas(); if (!isComparePopupOpen && !isColorPickingActive) drawToolPreview(currentMousePos.x, currentMousePos.y); }

        // --- Tool Management ---
        function setActiveTool(tool) {
            if (isComparePopupOpen) return; // Block tool change if popup open

            // Cancel current actions before switching (unless switching TO the active mode)
            if (tool !== 'color-picker' && isColorPickingActive) cancelCurrentAction(true);
            if (tool !== 'hole-remover' && waitingForInnerHoleClick) cancelCurrentAction(true);
            if (tool !== 'line' && tool !== 'eraser-line' && isDrawingLine) cancelCurrentAction(true);
            if (tool !== 'continuous-keep-line' && tool !== 'continuous-eraser-line' && isDrawingContinuousLine) cancelCurrentAction(true);
            if (tool !== 'brush' && tool !== 'eraser' && isDrawing) cancelCurrentAction(true);

            currentTool = tool;
            isColorPickingActive = (tool === 'color-picker');
            // Note: waitingForInnerHoleClick is set ONLY by its activate function

            console.log("Herramienta activa:", tool);
            // Update button highlights
            const allToolButtons = [colorPickerBtn, brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn, removeInnerHoleBtn];
            allToolButtons.forEach(b => b?.classList.remove('active-tool', 'active-color-picker', 'active-hole-remover'));

            if (isColorPickingActive) {
                colorPickerBtn?.classList.add('active-color-picker');
            } else if (waitingForInnerHoleClick) {
                 removeInnerHoleBtn?.classList.add('active-hole-remover');
            } else {
                const activeBtn = document.getElementById(`${tool}-tool`);
                activeBtn?.classList.add('active-tool');
            }

            // Update options visibility
            const isBrushOrEraser = tool === 'brush' || tool === 'eraser';
            const isAnyLineBasedTool = ['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line'].includes(tool);
            const showBrushOptionsPanel = isBrushOrEraser || isAnyLineBasedTool;

            if (brushOptionsSection) brushOptionsSection.style.display = showBrushOptionsPanel ? 'block' : 'none';
            // Feather relevant for brush, eraser, and color removal
            if (featherOptionDiv) featherOptionDiv.style.display = (isBrushOrEraser || tool === 'color-picker' || tool === 'apply-color') ? 'block' : 'none';
            // Shape only for brush/eraser
            if (shapeOptionDiv) shapeOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none';
            // Opacity only for brush/eraser/lines
            if (brushOpacitySlider?.parentElement) brushOpacitySlider.parentElement.style.display = (isBrushOrEraser || isAnyLineBasedTool) ? 'block' : 'none';
            // Show color list only when picker is active
            if (selectedColorsSection) selectedColorsSection.style.display = (isColorPickingActive && originalImage) ? 'block' : 'none';

            canvasOuterContainer.style.cursor = getToolCursor();
            updateStatusBar();
            updateToolOptionsDisplay(); // Ensure correct values are shown
            updateActionButtonsState(); // Update enable/disable states
            clearPreviewCanvas();
            if (!isColorPickingActive && !waitingForInnerHoleClick) { // Don't draw preview for click modes
                drawToolPreview(currentMousePos.x, currentMousePos.y);
            }
        }
        function getToolCursor() {
             if (isColorPickingActive) return 'crosshair';
             if (waitingForInnerHoleClick) return 'crosshair';
             // Block other cursors if compare popup is open
             if (isComparePopupOpen) return 'default';
             // Standard cursors
             if (isSpacePressed && !isPanning) return 'grab';
             if (isPanning) return 'grabbing';
             if (currentTool === 'brush' || currentTool === 'eraser') return 'none';
             if (['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line'].includes(currentTool)) return 'crosshair';
             return 'default';
        }
        function updateToolOptionsDisplay() { if (brushSizeValue) brushSizeValue.textContent = brushOptions.size; if (brushFeatherValue) brushFeatherValue.textContent = brushOptions.feather.toFixed(2); if (brushOpacityValue) brushOpacityValue.textContent = brushOptions.opacity.toFixed(2); if (shapeCircleBtn) shapeCircleBtn.classList.toggle('active-shape', brushOptions.shape === 'circle'); if (shapeSquareBtn) shapeSquareBtn.classList.toggle('active-shape', brushOptions.shape === 'square'); }
        function updateTransform() { if (canvasInnerContainer) canvasInnerContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
        function updateStatusBar() {
             if (zoomLevelSpan) zoomLevelSpan.textContent = Math.round(zoomLevel * 100);
             if (!currentToolSpan) return;
             let tn = 'Ninguna';

             if (waitingForInnerHoleClick) tn = 'Eliminar Hueco (Clic)';
             else if (isColorPickingActive) tn = 'Seleccionar Color (P)';
             else if (isComparePopupOpen) tn = 'Comparando';
             else if (!originalImage) tn = 'Ninguna (Carga imagen)';
             else { // Standard tool display
                 switch (currentTool) {
                     case 'brush': tn = 'Pincel (B)'; break;
                     case 'eraser': tn = 'Borrador (E)'; break;
                     case 'line': tn = 'Línea (L)'; break;
                     case 'eraser-line': tn = 'Línea Borrar (Shift+L)'; break;
                     case 'continuous-keep-line': tn = 'Trazo Conservar (C/W)'; break;
                     case 'continuous-eraser-line': tn = 'Trazo Borrar (X/Q)'; break;
                      default: tn = 'Desconocido'; // Should not happen
                 }
                 if (isDrawingLine) tn += ' (Dibujando...)';
                 else if (isDrawingContinuousLine) tn += ' (Trazando...)';
                 else if (isDrawing) tn += ' (Pintando...)';
                 else if (isPanning) tn += ' (Moviendo...)';
             }
             currentToolSpan.textContent = tn;
         }
        function updateActionButtonsState() {
            const imageLoaded = !!originalImage && !!ctx && !!maskCtx;
            const canUndo = history.length > 1;
            const canRedo = redoHistory.length > 0;
            const idle = isGenerallyIdle(); // Use the function that ignores popup state

            // --- Handle Compare Popup Open State ---
            if (isComparePopupOpen) {
                // Disable MOST controls
                const controlsToDisable = [
                    uploadBtn, pasteBtn, colorPickerBtn, brushBtn, eraserBtn, lineBtn, eraserLineBtn,
                    continuousKeepLineBtn, continuousEraserLineBtn, removeEdgeBgBtn, /* removeInnerHoleBtn handled below */
                    applyColorRemovalBtn, brushSizeSlider, brushFeatherSlider, brushOpacitySlider,
                    shapeCircleBtn, shapeSquareBtn, /* edgeColorToleranceSlider handled below */
                    undoBtn, redoBtn, resetBtn, previewBgToggleBtn, previewBgColorInput,
                    exportBtn, copyBtn, compareBtn
                ];
                controlsToDisable.forEach(el => { if (el) el.disabled = true; });

                // Keep Tolerance enabled (for hole remover)
                if (edgeColorToleranceSlider) edgeColorToleranceSlider.disabled = !imageLoaded;

                // Clear active classes for most tools
                [colorPickerBtn, brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn]
                    .forEach(btn => btn?.classList.remove('active-tool', 'active-color-picker'));

                // SPECIFICALLY handle removeInnerHoleBtn while popup is open
                if (removeInnerHoleBtn) {
                    removeInnerHoleBtn.disabled = !(imageLoaded && !isFloodFilling && !isProcessingColorRemoval); // Enable if possible
                    removeInnerHoleBtn.classList.toggle('active-hole-remover', waitingForInnerHoleClick && !removeInnerHoleBtn.disabled);
                }
                return; // Stop here if popup is open
            }

            // --- Normal State (Compare Popup Closed) ---
            undoBtn.disabled = !(imageLoaded && canUndo && idle);
            redoBtn.disabled = !(imageLoaded && canRedo && idle); // <-- RE-AÑADIDO check
            undoCountSpan.textContent = Math.max(0, history.length - 1);
            redoCountSpan.textContent = redoHistory.length; // <-- RE-AÑADIDO update

            resetBtn.disabled = !(imageLoaded && canUndo && idle);
            exportBtn.disabled = !(imageLoaded && idle);
            copyBtn.disabled = !(imageLoaded && isClipboardWriteSupported && idle);
            pasteBtn.disabled = !(isClipboardReadSupported && idle);
            if (compareBtn) compareBtn.disabled = !(imageLoaded && idle);

            // Manual drawing tools (excluding color picker and hole remover)
            const manualDrawingTools = [brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn];
            manualDrawingTools.forEach(btn => { if (btn) btn.disabled = !(imageLoaded && idle); });

            // Color Picker Button
            if (colorPickerBtn) colorPickerBtn.disabled = !(imageLoaded && (idle || isColorPickingActive));

            // Hole Remover Button
            if (removeInnerHoleBtn) {
                removeInnerHoleBtn.disabled = !(imageLoaded && (idle || waitingForInnerHoleClick) && !isFloodFilling && !isProcessingColorRemoval);
                removeInnerHoleBtn.classList.toggle('active-hole-remover', waitingForInnerHoleClick && !removeInnerHoleBtn.disabled);
            }

            // Auto/Apply Buttons
            removeEdgeBgBtn.disabled = !(imageLoaded && idle && !isFloodFilling);
            applyColorRemovalBtn.disabled = !(imageLoaded && selectedBackgroundColors.length > 0 && idle && !isProcessingColorRemoval);

            // Options
            const disableStrictIdleOptions = !(imageLoaded && idle);
            const disableUnlessPickingOrIdle = !(imageLoaded && (idle || isColorPickingActive));
            if (brushSizeSlider) brushSizeSlider.disabled = disableStrictIdleOptions;
            if (brushFeatherSlider) brushFeatherSlider.disabled = !(imageLoaded && (idle || isColorPickingActive)); // Enable if picking or idle
            if (brushOpacitySlider) brushOpacitySlider.disabled = disableStrictIdleOptions;
            if (shapeCircleBtn) shapeCircleBtn.disabled = disableStrictIdleOptions;
            if (shapeSquareBtn) shapeSquareBtn.disabled = disableStrictIdleOptions;
            if (edgeColorToleranceSlider) edgeColorToleranceSlider.disabled = !(imageLoaded && (idle || isColorPickingActive || waitingForInnerHoleClick)); // Enable if needed

            // Preview Background Controls
            if (previewBgToggleBtn) previewBgToggleBtn.disabled = !imageLoaded;
            if (previewBgColorInput) previewBgColorInput.disabled = !imageLoaded || previewMode !== 'solid';

            // Update active tool classes (excluding hole remover, handled above)
            if (colorPickerBtn) colorPickerBtn.classList.toggle('active-color-picker', isColorPickingActive && !colorPickerBtn.disabled);
            manualDrawingTools.forEach(btn => {
                if (btn) {
                    const isActive = btn.id.startsWith(currentTool + '-tool');
                    btn.classList.toggle('active-tool', isActive && !isColorPickingActive && !waitingForInnerHoleClick && !btn.disabled);
                }
            });
        }

        // --- Utility Functions ---
        function showButtonFeedback(button, status, message = null, duration = 1500) {
             if (!button) return;
             const isHoleRemoverButton = button.id === 'remove-inner-hole-btn';
             const isColorPickerButton = button.id === 'color-picker-tool';
             const isWorkingOrCancelling = status === 'working' || status === 'cancelling';

             // Store original state only if not already stored
             if (!button.dataset.originalHtml) button.dataset.originalHtml = button.innerHTML;
             if (!button.dataset.originalTitle) button.dataset.originalTitle = button.title;
             if (button.feedbackTimeout) clearTimeout(button.feedbackTimeout); button.feedbackTimeout = null;

             // Reset classes first
             button.classList.remove('success', 'error', 'working', 'cancelling', 'active-hole-remover', 'active-color-picker');

             // Apply new status class or active class if relevant
             if (status) button.classList.add(status);
             if (isHoleRemoverButton && waitingForInnerHoleClick) button.classList.add('active-hole-remover');
             if (isColorPickerButton && isColorPickingActive) button.classList.add('active-color-picker');

             // Set message and title
             let finalMessage = message;
             let finalTitle = button.dataset.originalTitle || button.title;
             if (isHoleRemoverButton && waitingForInnerHoleClick) { finalMessage = '<i class="fas fa-hand-pointer mr-1"></i> Clic Hueco'; finalTitle = "Haz clic en un área interna..."; }
             else if (isColorPickerButton && isColorPickingActive) { finalMessage = '<i class="fas fa-eye-dropper"></i> Seleccionar'; finalTitle = "Haz clic para seleccionar color (P)"; } // Default active picker text
             else if (!message && (status === 'success' || status === 'error')) { // Keep original text if no message provided for success/error
                 finalMessage = button.dataset.originalHtml || button.innerHTML;
             }

             if (finalMessage && button.innerHTML !== finalMessage) {
                 if (finalMessage.startsWith('<i class="')) button.innerHTML = finalMessage;
                 else button.textContent = finalMessage;
             }
             button.title = finalTitle;

             // Disabling is handled by updateActionButtonsState primarily, only override for working/cancelling
             button.disabled = isWorkingOrCancelling;
             if (!isWorkingOrCancelling) {
                  // Let updateActionButtonsState determine final disabled state otherwise
                  updateActionButtonsState();
             }

             // Set timeout to revert SUCCESS or ERROR states
             const shouldRevert = (status === 'success' || status === 'error');
             if (shouldRevert) {
                 button.feedbackTimeout = setTimeout(() => {
                     button.classList.remove(status); // Remove success/error class

                     // Revert HTML/Title ONLY if the button is NOT in its active state
                     if (!(isHoleRemoverButton && waitingForInnerHoleClick) && !(isColorPickerButton && isColorPickingActive)) {
                         if (button.dataset.originalHtml) button.innerHTML = button.dataset.originalHtml;
                         if (button.dataset.originalTitle) button.title = button.dataset.originalTitle;
                     } // Active state text/title is handled by the checks above or setActiveTool

                     // Re-evaluate button states after feedback timeout
                     updateActionButtonsState();

                 }, duration);
             }
         }
        function updatePreviewBackground() {
             if (!canvasOuterContainer || !previewBgIcon || !previewBgToggleBtn) return;
             if (previewMode === 'solid') {
                 canvasOuterContainer.classList.remove('checkerboard-bg');
                 canvasOuterContainer.classList.add('solid-bg');
                 canvasOuterContainer.style.backgroundColor = previewBackgroundColor;
                 previewBgIcon.className = 'fas fa-square fa-fw'; // Show solid square icon
                 previewBgToggleBtn.title = 'Cambiar a fondo damero';
             } else { // checkerboard
                 canvasOuterContainer.classList.add('checkerboard-bg');
                 canvasOuterContainer.classList.remove('solid-bg');
                 canvasOuterContainer.style.backgroundColor = ''; // Reset background color
                 previewBgIcon.className = 'fas fa-th fa-fw'; // Show checkerboard icon
                 previewBgToggleBtn.title = 'Cambiar a fondo sólido';
             }
             // updateActionButtonsState(); // Already called by caller functions
         }
        function checkClipboardSupport() { if (!isClipboardReadSupported) { if (pasteSupportWarning) pasteSupportWarning.classList.remove('hidden'); if (pasteBtn) { pasteBtn.disabled = true; pasteBtn.title = "Pegar no soportado."; } console.warn("Clipboard read no soportado."); } else { if (pasteSupportWarning) pasteSupportWarning.classList.add('hidden'); } if (!isClipboardWriteSupported) { if (clipboardSupportWarning) clipboardSupportWarning.classList.remove('hidden'); if (copyBtn) { copyBtn.disabled = true; copyBtn.title = "Copiar no soportado."; } console.warn("Clipboard write no soportado."); } else { if (clipboardSupportWarning) clipboardSupportWarning.classList.add('hidden'); } updateActionButtonsState(); }
        function saveStateToHistory() {
             if (!maskCtx || !maskCanvas) return;
             try {
                 // Clear redo history on new action
                 if (redoHistory.length > 0) {
                     console.log("Nueva acción, limpiando historial Redo.");
                     redoHistory = [];
                 }
                 const currentState = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                 history.push(currentState);
                 if (history.length > MAX_HISTORY + 1) {
                     history.shift(); // Remove oldest state
                 }
                 console.log("Historial:", history.length - 1, "Redo:", redoHistory.length);
                 updateActionButtonsState(); // Update counts and button states
             } catch (e) {
                 console.error("Error guardando estado en el historial:", e);
                 // Potentially disable undo/redo if saving fails?
             }
         }
        function undo() {
             // Block if comparing or no history or not idle
             if (isComparePopupOpen || history.length <= 1 || !isGenerallyIdle()) return;
             console.log("Deshaciendo...");
             try {
                 const currentState = history.pop(); // Remove current state
                 redoHistory.push(currentState); // Add it to redo stack
                 const previousState = history[history.length - 1]; // Get the new current state
                 if (previousState) {
                     maskCtx.putImageData(previousState, 0, 0);
                     requestRender();
                 }
                 console.log("Historial:", history.length - 1, "Redo:", redoHistory.length);
             } catch (e) {
                 console.error("Error al deshacer:", e);
             } finally {
                 updateActionButtonsState();
             }
         }
        function redo() {
             // Block if comparing or no redo history or not idle
             if (isComparePopupOpen || redoHistory.length === 0 || !isGenerallyIdle()) return;
             console.log("Rehaciendo...");
             try {
                 const nextState = redoHistory.pop(); // Get state from redo stack
                 history.push(nextState); // Add it back to history
                 if (history.length > MAX_HISTORY + 1) {
                    history.shift(); // Maintain max history size
                 }
                 maskCtx.putImageData(nextState, 0, 0);
                 requestRender();
                 console.log("Historial:", history.length - 1, "Redo:", redoHistory.length);
             } catch (e) {
                 console.error("Error al rehacer:", e);
             } finally {
                 updateActionButtonsState();
             }
         }
        function showProcessingOverlay(m) { if (processingStatusText) processingStatusText.textContent = m || "Procesando..."; if (processingOverlay) processingOverlay.classList.remove('hidden'); }
        function hideProcessingOverlay() { if (processingOverlay) processingOverlay.classList.add('hidden'); }
        function drawCheckerboard(tCtx, w, h, s = 10) { tCtx.save(); tCtx.fillStyle = '#fff'; tCtx.fillRect(0, 0, w, h); tCtx.fillStyle = '#ccc'; for (let i = 0; i < w; i += s) { for (let j = 0; j < h; j += s) { if ((Math.floor(i / s) + Math.floor(j / s)) % 2 === 0) tCtx.fillRect(i, j, s, s); } } tCtx.restore(); }
        function colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2, dg = g1 - g2, db = b1 - b2; return dr * dr + dg * dg + db * db; }

        // --- Image Generation & Export/Copy/Paste ---
        async function createFinalImageBlob(f = 'image/png') {
            if (!originalImage || !maskCanvas) return null;
            console.log("Creando Blob final...");
            const fc = document.createElement('canvas');
            fc.width = originalImage.naturalWidth;
            fc.height = originalImage.naturalHeight;
            const fctx = fc.getContext('2d');
            if (!fctx) { console.error("No ctx final."); return null; }

            // Apply background based on preview settings IF NEEDED for export
            // Typically export should be transparent, ignore preview bg
            // if (previewMode === 'checkerboard') { /* Draw checkerboard if desired for export? Unlikely */ }
            // else if (previewMode === 'solid') { /* Draw solid color if desired for export? Unlikely */ }
            // else { fctx.clearRect(0, 0, fc.width, fc.height); } // Default: Clear for transparency

            // Draw original image then apply mask
            fctx.clearRect(0, 0, fc.width, fc.height); // Ensure transparent background
            fctx.drawImage(originalImage, 0, 0);
            fctx.globalCompositeOperation = 'destination-in';
            fctx.drawImage(maskCanvas, 0, 0);
            fctx.globalCompositeOperation = 'source-over'; // Reset composite mode

            return new Promise(r => fc.toBlob(r, f));
        }
        async function exportImage() { if (isComparePopupOpen || !originalImage || !exportBtn || exportBtn.disabled) return; showButtonFeedback(exportBtn, 'working', 'Exportando...'); try { const b = await createFinalImageBlob(); if (!b) throw new Error("Fallo Blob."); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = `${imageFilename}_sin_fondo.png`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(u); showButtonFeedback(exportBtn, 'success', '<i class="fas fa-check"></i> Exportado'); } catch (e) { console.error("Error exportando:", e); alert(`Error exportar: ${e.message}`); showButtonFeedback(exportBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        async function copyImageToClipboard() { if (isComparePopupOpen || !originalImage || !isClipboardWriteSupported || !copyBtn || copyBtn.disabled) return; showButtonFeedback(copyBtn, 'working', 'Copiando...'); try { const b = await createFinalImageBlob('image/png'); if (!b) throw new Error("Fallo Blob."); const i = new ClipboardItem({ 'image/png': b }); await navigator.clipboard.write([i]); showButtonFeedback(copyBtn, 'success', '<i class="fas fa-check"></i> Copiado'); } catch (e) { console.error("Error copiando:", e); let m = "Error desconocido."; if (e.name === 'NotAllowedError') m = "Permiso denegado."; else if (e.message?.toLowerCase().includes("large")) m = "Imagen grande."; else if (e.name === 'SecurityError') m = "Error seguridad."; alert(`No se pudo copiar: ${m}\nDetalles: ${e.message}`); showButtonFeedback(copyBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        async function handlePasteButtonClick() { if (isComparePopupOpen || !isClipboardReadSupported || !pasteBtn || pasteBtn.disabled) return; console.log("Intentando pegar (botón)..."); showButtonFeedback(pasteBtn, 'working', 'Pegando...'); try { const p = await navigator.permissions.query({ name: 'clipboard-read' }); if (p.state === 'denied') throw new Error("Permiso denegado."); const ci = await navigator.clipboard.read(); let found = false; for (const item of ci) { const it = item.types.find(t => t.startsWith("image/")); if (it) { const b = await item.getType(it); cancelCurrentAction(true); handleFile(new File([b], "img_pegada.png", { type: it })); found = true; break; } } if (found) showButtonFeedback(pasteBtn, 'success', '<i class="fas fa-check"></i> Pegado'); else showButtonFeedback(pasteBtn, 'error', 'No imagen', 1000); } catch (e) { console.error("Error pegando:", e); let m = "Error."; if (e.name === 'NotAllowedError' || e.message?.includes("denied")) m = "Permiso denegado."; else if (e.name === 'SecurityError') m = "Error seguridad."; else if (e.message?.includes("No valid data")) m = "No imagen."; else if (e.message?.includes("activation")) m = "Requiere interacción."; alert(`No se pudo pegar: ${m}\nDetalles: ${e.message}`); showButtonFeedback(pasteBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        function handleClipboardPaste(cd) { if (isComparePopupOpen || !cd?.items) return false; console.log("Evento paste..."); let found = false; for (const i of cd.items) { if (i.kind === 'file' && i.type.startsWith('image/')) { const f = i.getAsFile(); if (f) { cancelCurrentAction(true); handleFile(f); found = true; break; } } } if (!found) console.log("No imagen 'file' en paste."); return found; }


        // --- Compare Popup Functions ---
        async function openComparePopup() {
             if (!originalImage || !comparePopupOverlay || !compareBeforeImg || !compareAfterImg || isComparePopupOpen) { console.warn("No abrir comparación: estado inválido."); return; }
             const slider = comparePopupOverlay.querySelector("img-comparison-slider");
             if (!slider) { console.error("Slider de comparación no encontrado."); alert("Error interno comparación."); return; }
             console.log("Abriendo popup comparación...");

             cancelCurrentAction(true); // Cancel any active tool/mode

             isComparePopupOpen = true; // Set state AFTER cancelling
             updateActionButtonsState(); // Disable most buttons
             updateStatusBar(); // Show "Comparando"
             document.body.style.overflow = 'hidden';
             canvasOuterContainer.style.cursor = 'default';

             compareBeforeImg.alt = `Antes (Cargando...)`; compareAfterImg.alt = 'Después (Cargando...)';
             compareBeforeImg.src = ''; compareAfterImg.src = '';
             showButtonFeedback(compareBtn, 'working', 'Generando...', 60000);
             try {
                 compareBeforeImg.src = originalImage.src;
                 compareBeforeImg.alt = `Antes (${originalImage.naturalWidth}×${originalImage.naturalHeight})`;
                 const blob = await createFinalImageBlob('image/png');
                 if (!blob) throw new Error("Fallo al crear blob 'Después'");
                 const dataUrl = await new Promise((res, rej) => { const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = e => rej(e); r.readAsDataURL(blob); });
                 compareAfterImg.src = dataUrl;
                 compareAfterImg.alt = `Después (${originalImage.naturalWidth}×${originalImage.naturalHeight})`;
                 console.log("   Imagen 'Después' cargada.");

                 slider.value = 50; // Reset slider position
                 comparePopupOverlay.classList.remove('hidden');
                 showButtonFeedback(compareBtn, null); // Clear working feedback

             } catch (err) {
                 console.error("Error generando imágenes popup:", err);
                 alert(`Error al generar imagen para comparación: ${err.message}`);
                 showButtonFeedback(compareBtn, 'error', 'Error', 2000);
                 closeComparePopup(true); // Force close on error
             }
        }
        function closeComparePopup(forceClose = false) {
            if (!isComparePopupOpen && !forceClose) return;
            console.log("Cerrando popup comparación...");
            isComparePopupOpen = false; // Update state FIRST
            if (comparePopupOverlay) comparePopupOverlay.classList.add('hidden');
            document.body.style.overflow = '';
            if (compareBeforeImg) compareBeforeImg.src = '';
            if (compareAfterImg) compareAfterImg.src = '';

            updateActionButtonsState(); // Re-enable buttons
            updateStatusBar();
            canvasOuterContainer.style.cursor = getToolCursor(); // Restore cursor

            // Reset compare button appearance if needed
            if (!forceClose && compareBtn) {
                 compareBtn.classList.remove('success', 'error', 'working', 'cancelling');
                 if (compareBtn.dataset.originalHtml) compareBtn.innerHTML = compareBtn.dataset.originalHtml;
                 if (compareBtn.dataset.originalTitle) compareBtn.title = compareBtn.dataset.originalTitle;
                 updateActionButtonsState(); // Ensure its disabled state is correct
             }
        }

        // --- Flood Fill Logic (Background & Holes) ---
        async function handleRemoveBackgroundByFloodFill() {
             if (isComparePopupOpen) return; // Block if comparing
             console.log(`%c>>> FloodFill Bordes`, 'color:blue;font-weight:bold');
             if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || !isGenerallyIdle()) { console.warn("FloodFill abortado: Estado inválido"); if (!isFloodFilling) showButtonFeedback(removeEdgeBgBtn, 'error', 'Ocupado', 1000); return; }
             isFloodFilling = true; cancelFloodFillRequest = false; updateActionButtonsState(); showButtonFeedback(removeEdgeBgBtn, 'working', 'Analizando...'); showProcessingOverlay('Analizando bordes...'); await new Promise(r => setTimeout(r, 50)); try { if (cancelFloodFillRequest) throw new Error("CancelledBeforeStart"); processingStatusText.textContent = "Procesando fondo..."; const t = parseInt(edgeColorToleranceSlider.value, 10), tsq = t * t * 3; const oD = originalImageDataCache, miD = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height), w = miD.width, h = miD.height, v = Array(h).fill(null).map(() => Array(w).fill(false)); console.log(` FloodFill Bordes. Tol:${t}, DistSq:${tsq.toFixed(0)}`); const st = performance.now(); let canc = false; for (let x = 0; x < w; x++) { if (cancelFloodFillRequest) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, x, 0, tsq, v)) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, x, h - 1, tsq, v)) { canc = true; break; } } if (!canc) { for (let y = 1; y < h - 1; y++) { if (cancelFloodFillRequest) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, 0, y, tsq, v)) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, w - 1, y, tsq, v)) { canc = true; break; } } } const et = performance.now(); console.log(` FloodFill terminado ${((et - st) / 1000).toFixed(2)}s. Cancelado:${canc || cancelFloodFillRequest}`); if (cancelFloodFillRequest || canc) throw new Error("Cancelled"); maskCtx.putImageData(miD, 0, 0); saveStateToHistory(); renderCanvas(); console.log("<<< FloodFill Completado."); showButtonFeedback(removeEdgeBgBtn, 'success', '<i class="fas fa-check"></i> Hecho'); } catch (e) { if (e.message === "Cancelled" || e.message === "CancelledBeforeStart") { console.log("%cFloodFill CANCELADO.", 'color:orange;'); showButtonFeedback(removeEdgeBgBtn, 'error', 'Cancelado', 1500); } else { console.error("Error FloodFill:", e); alert(`Error proceso:${e.message}`); showButtonFeedback(removeEdgeBgBtn, 'error', 'Error', 1500); } } finally { console.log(" Finally FloodFill: Limpiando."); isFloodFilling = false; cancelFloodFillRequest = false; hideProcessingOverlay(); if (removeEdgeBgBtn && !removeEdgeBgBtn.classList.contains('success') && !removeEdgeBgBtn.classList.contains('error')) { if (removeEdgeBgBtn.dataset.originalHtml) removeEdgeBgBtn.innerHTML = removeEdgeBgBtn.dataset.originalHtml; if (removeEdgeBgBtn.dataset.originalTitle) removeEdgeBgBtn.title = removeEdgeBgBtn.dataset.originalTitle; } updateActionButtonsState(); }
        }
        async function floodFillMaskAsync(oD, mD, sx, sy, tsq, v) { const w = oD.width, h = oD.height, oP = oD.data, mP = mD.data, cInt = 5000; if (sx < 0 || sx >= w || sy < 0 || sy >= h || v[sy][sx]) return false; const sIdx = (sy * w + sx) * 4; if (mP[sIdx + 3] < 128 || oP[sIdx + 3] < 128) { v[sy][sx] = true; return false; } const sR = oP[sIdx], sG = oP[sIdx + 1], sB = oP[sIdx + 2]; const q = [[sx, sy]]; v[sy][sx] = true; mP[sIdx + 3] = 0; let pp = 0; while (q.length > 0) { pp++; if (pp % cInt === 0) { if (cancelFloodFillRequest) return true; await new Promise(r => setTimeout(r, 0)); if (cancelFloodFillRequest) return true; } const [x, y] = q.shift(); const n = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]]; for (const [nx, ny] of n) { if (nx >= 0 && nx < w && ny >= 0 && ny < h && !v[ny][nx]) { v[ny][nx] = true; const nIdx = (ny * w + nx) * 4; if (mP[nIdx + 3] >= 128 && oP[nIdx + 3] >= 128) { const nR = oP[nIdx], nG = oP[nIdx + 1], nB = oP[nIdx + 2]; if (colorDistance(sR, sG, sB, nR, nG, nB) <= tsq) { q.push([nx, ny]); mP[nIdx + 3] = 0; } } } } } return false; }
        function activateInnerHoleClickMode() {
             // Can activate even if compare popup is open, but check other states
             if (!originalImage || isFloodFilling || isProcessingColorRemoval || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine || isColorPickingActive) {
                 console.warn("No se puede activar 'Eliminar Hueco': Estado inválido.");
                 // Show feedback only if not blocked by compare popup
                 if (!isComparePopupOpen && !isGenerallyIdle() && !waitingForInnerHoleClick) {
                     showButtonFeedback(removeInnerHoleBtn, 'error', 'Ocupado', 1000);
                 }
                 return;
             }
             console.log("Activando modo 'Eliminar Hueco Interno'");
             waitingForInnerHoleClick = true;
             // Don't change 'currentTool' state, just the waiting flag
             showButtonFeedback(removeInnerHoleBtn, 'active-hole-remover'); // Use feedback function
             updateStatusBar();
             updateActionButtonsState();
             clearPreviewCanvas();
             canvasOuterContainer.style.cursor = 'crosshair';
         }
        function removeInnerHoleAt(startX, startY) {
            console.log(`%c>>> removeInnerHoleAt (${startX.toFixed(0)}, ${startY.toFixed(0)})`, 'color: purple; font-weight: bold;');
            // Check if waiting, valid state, and have data. Compare popup state doesn't block this.
            if (!waitingForInnerHoleClick || !originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || isFloodFilling || isProcessingColorRemoval) {
                console.warn("Eliminar Hueco abortado: Estado inválido, datos faltantes o no esperando clic.");
                if (waitingForInnerHoleClick) { // Only show feedback if it was actively waiting
                     showButtonFeedback(removeInnerHoleBtn, 'error', 'Error Estado', 1500);
                     cancelCurrentAction(true); // Cancel the mode if it failed immediately
                }
                return;
            }

            const width = maskCanvas.width; const height = maskCanvas.height;
            startX = Math.floor(startX); startY = Math.floor(startY);
            if (startX < 0 || startX >= width || startY < 0 || startY >= height) {
                console.log("Clic fuera de límites.");
                showButtonFeedback(removeInnerHoleBtn, 'error', 'Fuera Imagen', 1000);
                cancelCurrentAction(true); // Cancel the mode
                return;
            }

            let pixelsChanged = 0; let success = false; let message = ''; let statusClass = 'error';
            try {
                const maskImageData = maskCtx.getImageData(0, 0, width, height);
                const maskPixels = maskImageData.data; const originalPixels = originalImageDataCache.data;
                const tolerance = parseInt(edgeColorToleranceSlider.value, 10); const toleranceSq = tolerance * tolerance * 3;
                const startIndex = (startY * width + startX) * 4;
                if (maskPixels[startIndex + 3] < 128) { // Clicked on already transparent area
                    message = 'Ya Transparente'; statusClass = 'error'; success = false;
                } else { // Clicked on opaque area, proceed with fill
                    const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2];
                    const visited = new Uint8Array(width * height); // More efficient than 2D array
                    const queue = [[startX, startY]];
                    visited[startY * width + startX] = 1;
                    maskPixels[startIndex + 3] = 0; pixelsChanged = 1;
                    let head = 0; const maxQueueSize = width * height * 1.5; // Safety limit

                    while (head < queue.length && queue.length < maxQueueSize) {
                        const [x, y] = queue[head++];
                        const neighbors = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]];
                        for (const [nx, ny] of neighbors) {
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nIndexLinear = ny * width + nx;
                                if (visited[nIndexLinear] === 0) {
                                    visited[nIndexLinear] = 1;
                                    const nIndexRGBA = nIndexLinear * 4;
                                    if (maskPixels[nIndexRGBA + 3] >= 128) { // Check MASK if opaque
                                        const nR_orig = originalPixels[nIndexRGBA];
                                        const nG_orig = originalPixels[nIndexRGBA + 1];
                                        const nB_orig = originalPixels[nIndexRGBA + 2];
                                        if (colorDistance(startR, startG, startB, nR_orig, nG_orig, nB_orig) <= toleranceSq) {
                                            queue.push([nx, ny]);
                                            maskPixels[nIndexRGBA + 3] = 0; // Make transparent
                                            pixelsChanged++;
                                        }
                                    }
                                }
                            }
                        }
                    } // End while loop

                    if (queue.length >= maxQueueSize) {
                        console.warn(`Flood fill (hueco) alcanzó límite de cola desde (${startX}, ${startY}).`);
                        message = 'Área Muy Grande'; statusClass = 'error'; success = false; pixelsChanged = 0;
                        // NOTE: We don't revert changes made so far if it hits the limit. Could be added if needed.
                    } else if (pixelsChanged > 0) { // If fill completed and changed something
                        maskCtx.putImageData(maskImageData, 0, 0);
                        saveStateToHistory();
                        requestRender();
                        message = '<i class="fas fa-check"></i> Hueco Borrado'; statusClass = 'success'; success = true;
                        console.log(`   Hueco eliminado, ${pixelsChanged} píxeles afectados.`);
                    } else { // Fill completed but nothing matched (shouldn't happen if start pixel was opaque)
                        message = 'No Cambios'; statusClass = 'error'; success = false;
                    }
                } // End if/else (clicked on transparent vs opaque)
            } catch (error) {
                console.error("Error crítico durante la eliminación del hueco:", error);
                alert(`Error procesando el hueco: ${error.message}\nConsulta la consola.`);
                message = '<i class="fas fa-times"></i> Error Interno'; statusClass = 'error'; success = false;
            } finally {
                // IMPORTANT: Always cancel the waiting mode after attempt
                waitingForInnerHoleClick = false;
                showButtonFeedback(removeInnerHoleBtn, statusClass, message, success ? 1200 : 2000);
                // Update UI state *after* cancelling the mode
                updateStatusBar();
                updateActionButtonsState();
                canvasOuterContainer.style.cursor = getToolCursor(); // Restore cursor
            }
        }


        // --- Color Picker & Removal Logic ---
        function pickColorAt(ix, iy) {
             if (!originalImageDataCache || !originalImage) { console.warn("Pick color sin datos."); return; }
             const x = Math.floor(ix), y = Math.floor(iy), w = originalImage.naturalWidth, h = originalImage.naturalHeight;
             if (x < 0 || x >= w || y < 0 || y >= h) { console.log("Clic fuera para color."); showButtonFeedback(colorPickerBtn, 'error', 'Fuera', 800); return; }
             const idx = (y * w + x) * 4, r = originalImageDataCache.data[idx], g = originalImageDataCache.data[idx + 1], b = originalImageDataCache.data[idx + 2];
             const exists = selectedBackgroundColors.some(c => c.r === r && c.g === g && c.b === b);
             if (!exists) {
                 selectedBackgroundColors.push({ r, g, b });
                 console.log(`Color añadido: rgb(${r},${g},${b}). Total: ${selectedBackgroundColors.length}`);
                 updateSelectedColorsUI();
                 updateActionButtonsState(); // Update apply button state
                 showButtonFeedback(colorPickerBtn, 'success', `<i class="fas fa-plus mr-1"></i>${r},${g},${b}`, 800);
             } else {
                 console.log(`Color rgb(${r},${g},${b}) ya existe.`);
                 showButtonFeedback(colorPickerBtn, 'error', 'Ya existe', 800);
             }
         }
        function removeSelectedColor(r, g, b) {
             selectedBackgroundColors = selectedBackgroundColors.filter(c => !(c.r === r && c.g === g && c.b === b));
             console.log(`Color quitado: rgb(${r},${g},${b}). Restantes: ${selectedBackgroundColors.length}`);
             updateSelectedColorsUI();
             updateActionButtonsState(); // Update apply button state
         }
        function updateSelectedColorsUI() {
             if (!selectedColorsListDiv || !noColorsSelectedP || !selectedColorsSection) return;
             selectedColorsListDiv.innerHTML = ''; // Clear previous list
             if (selectedBackgroundColors.length === 0) {
                 if (noColorsSelectedP) {
                     // selectedColorsListDiv.appendChild(noColorsSelectedP); // Don't append, just show/hide
                     noColorsSelectedP.style.display = 'block';
                 }
             } else {
                 if (noColorsSelectedP) noColorsSelectedP.style.display = 'none';
                 selectedBackgroundColors.forEach(c => {
                     const tag = document.createElement('span');
                     tag.className = 'color-tag';
                     const dot = document.createElement('span');
                     dot.className = 'color-dot';
                     dot.style.backgroundColor = `rgb(${c.r},${c.g},${c.b})`;
                     const txt = document.createElement('span');
                     txt.textContent = `${c.r},${c.g},${c.b}`;
                     const btn = document.createElement('button');
                     btn.className = 'remove-color-btn';
                     btn.innerHTML = '×'; // Use multiplication sign for 'x'
                     btn.title = 'Eliminar este color';
                     btn.type = 'button'; // Important for accessibility and forms
                     btn.dataset.r = c.r; btn.dataset.g = c.g; btn.dataset.b = c.b;
                     tag.appendChild(dot);
                     tag.appendChild(txt);
                     tag.appendChild(btn);
                     selectedColorsListDiv.appendChild(tag);
                 });
             }
             // Show/hide the whole section based on picker activity and if an image is loaded
             selectedColorsSection.style.display = (isColorPickingActive && originalImage) ? 'block' : 'none';
         }
        function applyFeatherToMask(miD, w, h, f) { // Basic Box Blur on Alpha
             const r = Math.max(1, Math.round(f * 15)); // Ensure radius is at least 1 if feather > 0
             if (r <= 0) return miD; // No feathering needed
             console.log(` Aplicando suavizado (radio ~${r}px)`);
             const d = miD.data;
             const tempAlpha = new Uint8ClampedArray(w * h); // Use Uint8ClampedArray for alpha
             const blurredAlpha = new Uint8ClampedArray(w * h);

             // Copy alpha channel to temp buffer
             for (let i = 0; i < w * h; i++) {
                 tempAlpha[i] = d[i * 4 + 3];
             }

             // Apply Box Blur (approximated) - could be improved with Gaussian
             // This is a simple, unoptimized box blur
             for (let y = 0; y < h; y++) {
                 for (let x = 0; x < w; x++) {
                     let totalAlpha = 0;
                     let count = 0;
                     for (let ky = -r; ky <= r; ky++) {
                         const ny = y + ky;
                         if (ny < 0 || ny >= h) continue; // Clamp y
                         for (let kx = -r; kx <= r; kx++) {
                             const nx = x + kx;
                             if (nx < 0 || nx >= w) continue; // Clamp x
                             totalAlpha += tempAlpha[ny * w + nx];
                             count++;
                         }
                     }
                     blurredAlpha[y * w + x] = count > 0 ? totalAlpha / count : tempAlpha[y * w + x];
                 }
             }

             // Apply blurred alpha back to the image data
             for (let i = 0; i < w * h; i++) {
                 d[i * 4 + 3] = blurredAlpha[i];
             }
             console.log("   Suavizado aplicado.");
             return miD; // Return the modified ImageData
         }
        async function applyColorRemoval() {
             if (isComparePopupOpen) return; // Block if comparing
             console.log("%c>>> Aplicando Eliminación por Color...", 'color:purple;font-weight:bold');
             if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || selectedBackgroundColors.length === 0 || !isGenerallyIdle()) {
                 console.warn("Eliminación por Color abortada: Estado inválido o sin colores.");
                 showButtonFeedback(applyColorRemovalBtn, 'error', 'Error Estado', 1000);
                 return;
             }
             isProcessingColorRemoval = true;
             updateActionButtonsState();
             showButtonFeedback(applyColorRemovalBtn, 'working', 'Procesando...');
             showProcessingOverlay('Eliminando colores...');
             await new Promise(r => setTimeout(r, 50)); // Allow UI update

             try {
                 const tolerance = parseInt(edgeColorToleranceSlider.value, 10);
                 const toleranceSq = tolerance * tolerance * 3; // Squared tolerance for faster comparison
                 const featherAmount = parseFloat(brushFeatherSlider.value); // Get feather value
                 const width = maskCanvas.width, height = maskCanvas.height;
                 const originalPixels = originalImageDataCache.data;
                 const maskImageData = maskCtx.getImageData(0, 0, width, height);
                 const maskPixels = maskImageData.data;

                 console.log(` Procesando ${width}x${height}. Colores: ${selectedBackgroundColors.length}, Tolerancia: ${tolerance}, Suavizado: ${featherAmount}`);
                 const startTime = performance.now();

                 // Iterate through each pixel of the mask
                 for (let y = 0; y < height; y++) {
                     for (let x = 0; x < width; x++) {
                         const idx = (y * width + x) * 4;
                         // Only process opaque pixels in the original image and current mask
                         if (originalPixels[idx + 3] < 128 || maskPixels[idx + 3] < 128) {
                              continue;
                         }

                         const rO = originalPixels[idx];
                         const gO = originalPixels[idx + 1];
                         const bO = originalPixels[idx + 2];

                         // Check if the original pixel matches any selected background color within tolerance
                         let match = false;
                         for (const bgColor of selectedBackgroundColors) {
                             if (colorDistance(rO, gO, bO, bgColor.r, bgColor.g, bgColor.b) <= toleranceSq) {
                                 match = true;
                                 break; // Stop checking colors if one matches
                             }
                         }

                         // If matched, make the corresponding mask pixel transparent
                         if (match) {
                             maskPixels[idx + 3] = 0; // Set alpha to 0 (transparent)
                         }
                     }
                 }

                 // Apply feathering AFTER initial color removal if specified
                 let finalMaskData = maskImageData;
                 if (featherAmount > 0) {
                     finalMaskData = applyFeatherToMask(maskImageData, width, height, featherAmount);
                 }

                 // Put the modified (and potentially feathered) mask data back onto the mask canvas
                 maskCtx.putImageData(finalMaskData, 0, 0);

                 const endTime = performance.now();
                 console.log(` Eliminación por Color completada en ${((endTime - startTime) / 1000).toFixed(2)}s.`);

                 saveStateToHistory();
                 requestRender(); // Update the main canvas view
                 showButtonFeedback(applyColorRemovalBtn, 'success', '<i class="fas fa-check"></i> Colores Aplicados');

             } catch (e) {
                 console.error("Error durante eliminación por color:", e);
                 alert(`Error al aplicar colores: ${e.message}`);
                 showButtonFeedback(applyColorRemovalBtn, 'error', 'Error Proceso', 1500);
             } finally {
                 console.log(" Finally Eliminación Color: Limpiando estado.");
                 isProcessingColorRemoval = false;
                 hideProcessingOverlay();
                 // Reset button text/title if it wasn't success
                 if (applyColorRemovalBtn && !applyColorRemovalBtn.classList.contains('success')) {
                     if (applyColorRemovalBtn.dataset.originalHtml) applyColorRemovalBtn.innerHTML = applyColorRemovalBtn.dataset.originalHtml;
                     if (applyColorRemovalBtn.dataset.originalTitle) applyColorRemovalBtn.title = applyColorRemovalBtn.dataset.originalTitle;
                 }
                 updateActionButtonsState(); // Re-enable buttons accordingly
             }
         }


        // --- Final cierre del listener DOMContentLoaded ---
    }); // End DOMContentLoaded Listener
</script>
Use code with caution.
</body>
</html>
