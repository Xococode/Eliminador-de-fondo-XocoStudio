<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliminador de Fondos (Simple) - XocoStudio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- Estilos CSS (Optimizados) --- */
        body { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .checkerboard-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        .tool-btn.active-tool { background-color: #d1d5db; /* gray-300 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); }
        /* Añadido estilo para el botón de eliminar huecos activo */
        .tool-btn.active-hole-remover { background-color: #fde047 !important; /* yellow-300 */ color: #713f12 !important; /* yellow-800 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #ca8a04; /* yellow-600 */}
        .brush-shape.active-shape { border-color: #3b82f6; /* blue-500 */ border-width: 2px; }
        #canvas-outer-container { width: 100%; height: 100%; overflow: hidden; position: relative; /* Cursor se define por JS */ }
        #canvas-inner-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
        #image-canvas, #preview-canvas { display: block; position: absolute; top: 0; left: 0; max-width: none; /* width/height se definen por JS */ image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        #preview-canvas { pointer-events: none; }
        main { height: calc(100vh - 64px - 32px); } /* Header height (64px) + padding (2*16px=32px) */
        /* Estilo para el icono custom de línea-borrador */
        .fa-line-eraser::before { content: "\f12d"; /* Icono de borrador */ font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 1; }
        .fa-line-eraser::after { content: ""; position: absolute; left: 15%; top: 50%; width: 70%; height: 2px; background-color: currentColor; transform: translateY(-50%) rotate(0deg); opacity: 0.6; z-index: 0; }
        .tool-btn .fa-line-eraser { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; }
        #eraser-line-tool i { font-size: 0.9em; }
        /* Feedback visual para botones */
        .btn-feedback { transition: background-color 0.2s ease-out, color 0.2s ease-out, border-color 0.2s ease-out; }
        .btn-feedback.success { background-color: #22c55e !important; color: white !important; border-color: #16a34a !important; }
        .btn-feedback.error { background-color: #ef4444 !important; color: white !important; border-color: #dc2626 !important; }
        .btn-feedback.working { background-color: #eab308 !important; color: white !important; border-color: #ca8a04 !important; cursor: wait; }
        .btn-feedback.cancelling { background-color: #f97316 !important; color: white !important; border-color: #ea580c !important; cursor: default; }
         /* Overlay para procesamiento */
        .processing-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: none; }
        .processing-overlay i { margin-bottom: 10px; }
        .processing-overlay p { margin-top: 0px; font-size: 1.1rem; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col min-h-screen overflow-hidden">

    <header class="bg-white shadow-md p-4 flex-shrink-0 flex items-center"> <!-- Añadido flex e items-center -->
        <!-- LOGO Añadido -->
        <a href="https://xocostudio.com/" target="_blank" rel="noopener noreferrer" class="mr-4 flex-shrink-0">
             <img src="https://xocostudio.com/assets/images/xocostudio-354x128.png" alt="XocoStudio Logo" class="h-8"> <!-- Ajustar altura (h-8) si es necesario -->
        </a>
        <!-- Título -->
        <h1 class="text-xl md:text-2xl font-bold text-gray-800">Eliminador de Fondos de Imágenes</h1>
    </header>

    <main class="flex-grow flex flex-col md:flex-row p-4 gap-4">
        <!-- Panel de Controles -->
        <aside class="w-full md:w-72 bg-white p-4 rounded-lg shadow space-y-6 flex-shrink-0 overflow-y-auto">
            <!-- Carga de Imagen -->
            <div id="upload-section">
                 <h2 class="text-lg font-semibold mb-2">1. Cargar Imagen</h2>
                 <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors">
                    <p class="text-gray-600">Arrastra y suelta</p>
                    <p class="text-sm text-gray-500 my-2">o</p>
                    <div class="flex flex-col items-center space-y-2">
                        <input type="file" id="file-input" accept="image/*" class="hidden">
                        <button id="upload-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded btn-feedback">
                            <i class="fas fa-upload mr-1"></i> Seleccionar Archivo
                        </button>
                        <button id="paste-btn" class="w-full bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Pegar imagen del portapapeles (Requiere permisos)">
                             <i class="fas fa-paste mr-1"></i> Pegar (Ctrl+V)
                        </button>
                    </div>
                     <p id="paste-support-warning" class="text-xs text-red-600 mt-2 hidden">Pegar desde el portapapeles no está soportado o permitido.</p>
                 </div>
                 <p id="filename-display" class="text-xs text-gray-600 mt-2 truncate"></p>
            </div>

            <!-- Herramientas -->
            <div id="tools-section" class="space-y-4 hidden pt-4 border-t">
                <h2 class="text-lg font-semibold mb-2">2. Herramientas</h2>

                 <!-- Eliminación Automática -->
                 <div class="mb-4 space-y-2"> <!-- Added space-y-2 -->
                    <button id="remove-edge-bg-btn" class="w-full bg-cyan-600 hover:bg-cyan-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Eliminar fondo basado en el color de los bordes. Haz clic de nuevo para intentar cancelar.">
                        <i class="fas fa-wand-magic-sparkles mr-1"></i> Fondo Automático
                    </button>
                    <!-- NEW BUTTON -->
                    <button id="remove-inner-hole-btn" class="tool-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Activa/Desactiva el modo 'Eliminar Hueco'. Haz clic en un 'hueco' (ej: interior de 'o') para eliminarlo según su color original. Usa la tolerancia de abajo. Pulsa Esc para cancelar.">
                        <i class="fas fa-highlighter mr-1"></i> Eliminar Hueco Interno
                    </button>
                    <!-- END NEW BUTTON -->
                    <div class="mt-2">
                         <label for="edge-color-tolerance" class="block text-sm font-medium text-gray-700">Tolerancia (<span id="edge-color-tolerance-value">30</span>):</label>
                         <input type="range" id="edge-color-tolerance" min="1" max="150" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled>
                         <p class="text-xs text-gray-500 mt-1">Detecta más colores como fondo/hueco.</p> <!-- Updated text -->
                     </div>
                </div>

                <!-- Ajuste Manual -->
                <div class="border-t pt-4">
                    <p class="text-sm font-medium text-gray-700 mb-2">Ajuste manual:</p>
                    <div class="flex space-x-2">
                        <button id="brush-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Pincel Conservar (B)" disabled> <i class="fas fa-paint-brush fa-fw"></i> </button>
                        <button id="eraser-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Borrador Eliminar (E)" disabled> <i class="fas fa-eraser fa-fw"></i> </button>
                        <button id="line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Línea Conservar (L) - Clic inicio, Clic fin" disabled> <i class="fas fa-minus fa-fw"></i> </button>
                        <button id="eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Línea Borrador (Shift+L) - Clic inicio, Clic fin" disabled> <i class="fa-line-eraser"></i> </button>
                    </div>
                </div>

                <!-- Opciones Pincel/Borrador -->
                <div id="brush-options-section" class="space-y-3">
                    <div><label for="brush-size" class="block text-sm font-medium text-gray-700">Tamaño: <span id="brush-size-value">50</span>px</label><input type="range" id="brush-size" min="1" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div id="feather-option"><label for="brush-feather" class="block text-sm font-medium text-gray-700">Difuminado: <span id="brush-feather-value">0.10</span></label><input type="range" id="brush-feather" min="0" max="1" step="0.05" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div><label for="brush-opacity" class="block text-sm font-medium text-gray-700">Opacidad: <span id="brush-opacity-value">1.00</span></label><input type="range" id="brush-opacity" min="0.05" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div id="shape-option"><label class="block text-sm font-medium text-gray-700">Forma:</label><div class="flex space-x-2 mt-1"><button id="brush-shape-circle" class="brush-shape p-1 border rounded-full w-6 h-6 bg-gray-700 disabled:opacity-50" title="Circular" disabled></button><button id="brush-shape-square" class="brush-shape p-1 border rounded w-6 h-6 bg-gray-700 disabled:opacity-50" title="Cuadrado" disabled></button></div></div>
                </div>
                <!-- Acciones -->
                <div class="flex space-x-2 pt-4 border-t">
                    <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Deshacer (Ctrl+Z)" disabled> <i class="fas fa-undo"></i> (<span id="undo-count">0</span>) </button>
                    <button id="reset-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Resetear Máscara" disabled> <i class="fas fa-trash-alt"></i> Reset </button>
                </div>
            </div>

            <!-- Exportar / Copiar -->
             <div id="export-section" class="hidden pt-4 border-t space-y-2">
                 <h2 class="text-lg font-semibold mb-2">3. Guardar / Copiar</h2>
                 <button id="export-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed btn-feedback" disabled><i class="fas fa-download mr-1"></i> Exportar PNG</button>
                 <button id="copy-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed btn-feedback" disabled><i class="fas fa-copy mr-1"></i> Copiar Imagen</button>
                 <p id="clipboard-support-warning" class="text-xs text-red-600 text-center hidden">La copia al portapapeles no está soportada o permitida.</p>
             </div>
        </aside>

        <!-- Área de Trabajo -->
        <section class="flex-grow bg-gray-300 rounded-lg shadow overflow-hidden relative checkerboard-bg">
            <div id="canvas-outer-container">
                <div id="canvas-inner-container">
                    <canvas id="image-canvas" class="hidden"></canvas>
                    <canvas id="preview-canvas" class="hidden"></canvas>
                </div>
                <p id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">Carga una imagen para empezar</p>
            </div>
            <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-50 pointer-events-none">
                <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i>
                <p class="text-lg font-semibold ml-3">Cargando...</p>
            </div>
            <!-- Overlay para procesamiento (usado por Flood Fill) -->
            <div id="processing-overlay" class="processing-overlay hidden">
                <i class="fas fa-spinner fa-spin fa-3x"></i>
                <p id="processing-status-text">Procesando...</p>
            </div>
            <div id="status-bar" class="absolute bottom-0 left-0 bg-black bg-opacity-60 text-white text-xs p-1 rounded-tr z-10 pointer-events-none">Zoom: <span id="zoom-level">100</span>% | Herramienta: <span id="current-tool-status">Ninguna</span> | Rueda=Zoom, Espacio+Arrastrar=Mover</div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Cargado - XocoStudio Background Remover"); // LOG 1

            // --- DOM Elements ---
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const uploadBtn = document.getElementById('upload-btn');
            const pasteBtn = document.getElementById('paste-btn');
            const pasteSupportWarning = document.getElementById('paste-support-warning');
            const filenameDisplay = document.getElementById('filename-display');
            const canvasOuterContainer = document.getElementById('canvas-outer-container');
            const canvasInnerContainer = document.getElementById('canvas-inner-container');
            const canvas = document.getElementById('image-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const canvasPlaceholder = document.getElementById('canvas-placeholder');
            const loadingSpinner = document.getElementById('loading-spinner');
            const toolsSection = document.getElementById('tools-section');
            const exportSection = document.getElementById('export-section');
            const brushBtn = document.getElementById('brush-tool');
            const eraserBtn = document.getElementById('eraser-tool');
            const lineBtn = document.getElementById('line-tool');
            const eraserLineBtn = document.getElementById('eraser-line-tool');
            const brushOptionsSection = document.getElementById('brush-options-section');
            const featherOptionDiv = document.getElementById('feather-option');
            const shapeOptionDiv = document.getElementById('shape-option');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushFeatherSlider = document.getElementById('brush-feather');
            const brushFeatherValue = document.getElementById('brush-feather-value');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            const brushOpacityValue = document.getElementById('brush-opacity-value');
            const shapeCircleBtn = document.getElementById('brush-shape-circle');
            const shapeSquareBtn = document.getElementById('brush-shape-square');
            const undoBtn = document.getElementById('undo-btn');
            const undoCountSpan = document.getElementById('undo-count');
            const resetBtn = document.getElementById('reset-btn');
            const exportBtn = document.getElementById('export-btn');
            const copyBtn = document.getElementById('copy-btn');
            const clipboardSupportWarning = document.getElementById('clipboard-support-warning');
            const zoomLevelSpan = document.getElementById('zoom-level');
            const currentToolSpan = document.getElementById('current-tool-status');
            const processingOverlay = document.getElementById('processing-overlay');
            const processingStatusText = document.getElementById('processing-status-text');
            const removeEdgeBgBtn = document.getElementById('remove-edge-bg-btn');
            const removeInnerHoleBtn = document.getElementById('remove-inner-hole-btn'); // New Button Element
            const edgeColorToleranceSlider = document.getElementById('edge-color-tolerance');
            const edgeColorToleranceValueSpan = document.getElementById('edge-color-tolerance-value');

            // --- State Variables ---
            let ctx = null;
            let previewCtx = null;
            let originalImage = null;
            let originalImageDataCache = null; // <-- Cache for original pixel data
            let imageFilename = 'imagen';
            let maskCanvas = null;
            let maskCtx = null;
            let isDrawing = false;
            let lastX = 0, lastY = 0;
            let history = [];
            const MAX_HISTORY = 30;
            let currentTool = 'eraser';
            let brushOptions = { size: 50, feather: 0.1, opacity: 1.0, shape: 'circle' };
            let zoomLevel = 1.0;
            let panX = 0, panY = 0;
            let isPanning = false;
            let panStartX = 0, panStartY = 0;
            let isSpacePressed = false;
            let isDrawingLine = false;
            let lineStartX = 0, lineStartY = 0;
            let currentMousePos = { x: 0, y: 0 };
            let isClipboardWriteSupported = !!(navigator.clipboard && navigator.clipboard.write);
            let isClipboardReadSupported = !!(navigator.clipboard && navigator.clipboard.read);
            let isFloodFilling = false; // Estado para el proceso automático de bordes
            let cancelFloodFillRequest = false; // Flag para solicitar cancelación
            let waitingForInnerHoleClick = false; // <-- State for the new tool
            let holeRemoverFeedbackTimeout = null; // <-- Timeout specific for hole remover button text reset

            // Performance Throttling
            let lastRenderTime = 0;
            const RENDER_THROTTLE = 16; // ms, approx 60fps

            // --- Verification ---
            if (!canvas || !previewCanvas || !dropZone || !fileInput || !uploadBtn || !pasteBtn || !removeEdgeBgBtn || !removeInnerHoleBtn) { // Added check for new button
                console.error("¡ERROR CRÍTICO! No se encontraron uno o más elementos esenciales del DOM. Verifica los IDs.");
                alert("Error: La aplicación no pudo iniciarse correctamente.");
                return;
            }
            console.log("Elementos DOM principales OK."); // LOG 2

            // --- Initialization ---
            setActiveTool('eraser');
            updateToolOptionsDisplay();
            updateActionButtonsState();
            setupImageLoadingListeners();
            setupInteractionListeners();
            setupToolControlListeners();
            checkClipboardSupport();
            console.log("Inicialización completada."); // LOG 3

            // --- Setup Functions ---
            function setupImageLoadingListeners() {
                console.log("Configurando listeners de carga..."); // LOG 4
                dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); });
                dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                    const file = e.dataTransfer?.files?.[0];
                    if (file?.type.startsWith('image/')) {
                        handleFile(file);
                    } else if (file) { alert('Por favor, suelta un archivo de imagen válido.'); }
                });
                uploadBtn.addEventListener('click', () => fileInput.click());
                pasteBtn.addEventListener('click', handlePasteButtonClick);
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files?.[0];
                    if (file?.type.startsWith('image/')) {
                        handleFile(file);
                        e.target.value = null;
                    } else if (file) { alert('Por favor, selecciona un archivo de imagen válido.'); }
                });
                window.addEventListener('paste', (e) => {
                    const activeElement = document.activeElement;
                    if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable) return;
                    if (handleClipboardPaste(e.clipboardData)) e.preventDefault();
                });
                console.log("Listeners de carga añadidos."); // LOG 5
            }

            function setupInteractionListeners() {
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                canvasOuterContainer.addEventListener('mousedown', handleInteractionStart);
                canvasOuterContainer.addEventListener('mousemove', handleInteractionMove);
                window.addEventListener('mouseup', handleInteractionEnd);
                canvasOuterContainer.addEventListener('touchstart', (e) => handleInteractionStart(e.touches[0]), { passive: false });
                canvasOuterContainer.addEventListener('touchmove', (e) => handleInteractionMove(e.touches[0]), { passive: false });
                window.addEventListener('touchend', (e) => handleInteractionEnd(e.changedTouches[0]));
                window.addEventListener('touchcancel', (e) => handleInteractionEnd(e.changedTouches[0]));
                canvasOuterContainer.addEventListener('wheel', handleWheelZoom, { passive: false });
                // Listener para el cursor fuera del canvas
                canvasOuterContainer.addEventListener('mouseleave', () => {
                    clearPreviewCanvas();
                    // If waiting for hole click and mouse leaves, cancel waiting state
                    // NOTE: We DON'T cancel the sticky mode on mouse leave anymore.
                    // if (waitingForInnerHoleClick) {
                    //     cancelInnerHoleClickMode();
                    // }
                });
            }

            function setupToolControlListeners() {
                console.log("Configurando listeners de herramientas...");
                brushBtn.addEventListener('click', () => setActiveTool('brush'));
                eraserBtn.addEventListener('click', () => setActiveTool('eraser'));
                lineBtn.addEventListener('click', () => setActiveTool('line'));
                eraserLineBtn.addEventListener('click', () => setActiveTool('eraser-line'));
                brushSizeSlider.addEventListener('input', (e) => { brushOptions.size = parseInt(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y);});
                brushFeatherSlider.addEventListener('input', (e) => { brushOptions.feather = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                brushOpacitySlider.addEventListener('input', (e) => { brushOptions.opacity = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                shapeCircleBtn.addEventListener('click', () => { brushOptions.shape = 'circle'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                shapeSquareBtn.addEventListener('click', () => { brushOptions.shape = 'square'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                undoBtn.addEventListener('click', undo);
                resetBtn.addEventListener('click', () => {
                    if (!originalImage || history.length <= 1) return;
                    if (confirm('¿Resetear todas las ediciones? Esta acción no se puede deshacer.')) {
                         // Ensure mode is cancelled on reset
                        if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                        resetMask();
                    }
                 });
                exportBtn.addEventListener('click', exportImage);
                copyBtn.addEventListener('click', copyImageToClipboard);
                edgeColorToleranceSlider.addEventListener('input', (e) => edgeColorToleranceValueSpan.textContent = e.target.value);

                // --- Listener para Botón Automático (con cancelación) ---
                removeEdgeBgBtn.addEventListener('click', () => {
                    // --- MODIFICATION: Cancel hole mode if active ---
                    if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                    // --- END MODIFICATION ---
                    if (isFloodFilling) {
                        console.log("%cSolicitando cancelación de Flood Fill...", 'color: orange; font-weight: bold;');
                        cancelFloodFillRequest = true;
                        processingStatusText.textContent = "Cancelando...";
                        showButtonFeedback(removeEdgeBgBtn, 'cancelling', 'Cancelando...', 60000);
                    } else {
                        handleRemoveBackgroundByFloodFill();
                    }
                });

                // --- Listener for NEW Inner Hole Button ---
                removeInnerHoleBtn.addEventListener('click', () => {
                    if (isFloodFilling) return; // Don't activate if auto is running
                    if (waitingForInnerHoleClick) {
                         cancelInnerHoleClickMode(); // Click again to cancel
                    } else {
                        activateInnerHoleClickMode();
                    }
                });

                console.log("Listeners de herramientas añadidos.");
            }

            // --- Core Logic ---
            function handleFile(file) {
                console.log('>>> handleFile:', file?.name); // LOG 6
                 // Ensure mode is cancelled on new file load
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                if (!file?.type?.startsWith('image/')) {
                    alert('Archivo no válido. Selecciona una imagen.');
                    console.error('Tipo inválido:', file?.type);
                    return;
                }
                const reader = new FileReader();
                reader.onloadstart = () => { console.log('   reader.onloadstart'); showLoadingState(file.name); } // LOG 7
                reader.onload = (e) => {
                    console.log('   reader.onload'); // LOG 8
                    if (!e.target?.result) { handleLoadingError(file.name, 'Error al leer.'); return; }
                    originalImage = new Image();
                    originalImage.onload = () => {
                        console.log(`      originalImage.onload OK: ${originalImage.naturalWidth}x${originalImage.naturalHeight}`); // LOG 9
                        if (originalImage.naturalWidth === 0 || originalImage.naturalHeight === 0) {
                            handleLoadingError(file.name, 'Dimensiones inválidas (0x0).'); originalImage = null; return;
                        }
                        initializeEditor(file.name, originalImage);
                    };
                    originalImage.onerror = (err) => { console.error('originalImage.onerror:', err); handleLoadingError(file.name, 'Error al decodificar. ¿Formato soportado?'); originalImage = null; }; // LOG 10
                    originalImage.src = e.target.result;
                };
                reader.onerror = (err) => { console.error('reader.onerror:', err); handleLoadingError(file.name, 'Error de lectura.'); }; // LOG 11
                try { reader.readAsDataURL(file); } catch (error) { console.error("Error readAsDataURL:", error); handleLoadingError(file.name, 'Error iniciando lectura.'); }
            }

            function showLoadingState(fileName) {
                console.log("Mostrando carga:", fileName);
                 // Ensure mode is cancelled on loading start
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                loadingSpinner.classList.remove('hidden');
                canvasPlaceholder.classList.add('hidden');
                filenameDisplay.textContent = `Cargando: ${fileName}...`;
                toolsSection.classList.add('hidden');
                exportSection.classList.add('hidden');
                canvas.classList.add('hidden');
                previewCanvas.classList.add('hidden');
                originalImage = null; // Resetear estado
                originalImageDataCache = null; // Clear cache
                ctx = previewCtx = maskCtx = null;
                history = [];
                updateActionButtonsState();
            }

            function handleLoadingError(fileName, message) {
                console.error(`Error cargando ${fileName || 'imagen'}: ${message}`);
                 // Ensure mode is cancelled on loading error
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                alert(`Error al cargar "${fileName || ''}":\n${message}`);
                loadingSpinner.classList.add('hidden');
                canvasPlaceholder.classList.remove('hidden');
                filenameDisplay.textContent = `Error al cargar`;
                originalImage = null;
                originalImageDataCache = null; // Clear cache
                ctx = previewCtx = maskCtx = null;
                history = [];
                updateActionButtonsState();
            }

            function initializeEditor(fileName, loadedImage) {
                 console.log(">>> initializeEditor:", fileName); // LOG 12
                 // Ensure mode is cancelled on editor initialization
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 if (!loadedImage || !loadedImage.naturalWidth || !loadedImage.naturalHeight) {
                     handleLoadingError(fileName, "Datos de imagen inválidos."); return;
                 }
                 imageFilename = fileName.replace(/\.[^/.]+$/, "") || 'imagen_editada';
                 filenameDisplay.textContent = `Editando: ${fileName} (${loadedImage.naturalWidth}x${loadedImage.naturalHeight})`;

                 // --- Obtener Contextos ---
                 try {
                    ctx = canvas.getContext('2d', { willReadFrequently: false });
                    previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
                    if (!ctx || !previewCtx) throw new Error("getContext devolvió null.");
                    console.log("   Contextos ctx y previewCtx OK.");
                 } catch (e) {
                     console.error("¡ERROR FATAL obteniendo contextos principales!:", e);
                     handleLoadingError(fileName, "Error interno: No se pudo crear contexto gráfico."); return;
                 }

                 if (!setupCanvases(loadedImage)) {
                     handleLoadingError(fileName, "Error configurando canvas."); return;
                 }
                 cacheOriginalImageData(); // <-- Cache the original data
                 resetMask(); // Crea máscara inicial y guarda estado
                 centerAndFitImage();
                 requestRender();

                 toolsSection.classList.remove('hidden');
                 exportSection.classList.remove('hidden');
                 canvas.classList.remove('hidden');
                 previewCanvas.classList.remove('hidden');
                 loadingSpinner.classList.add('hidden');
                 canvasPlaceholder.classList.add('hidden');
                 setActiveTool(currentTool); // Set default tool (eraser)
                 updateActionButtonsState();
                 console.log("<<< initializeEditor completado."); // LOG 13
            }

             function setupCanvases(img) {
                 console.log(">>> setupCanvases");
                 if (!img?.naturalWidth || !img?.naturalHeight) { console.error("   Imagen inválida."); return false; }
                 if (!canvas || !previewCanvas || !canvasInnerContainer) { console.error("   Faltan elementos canvas."); return false; }

                 const w = img.naturalWidth; const h = img.naturalHeight;
                 canvas.width = w; canvas.height = h;
                 previewCanvas.width = w; previewCanvas.height = h;
                 canvasInnerContainer.style.width = `${w}px`; canvasInnerContainer.style.height = `${h}px`;

                 try {
                      maskCanvas = document.createElement('canvas');
                      maskCanvas.width = w; maskCanvas.height = h;
                      maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
                      if (!maskCtx) throw new Error("maskCtx es null.");
                      console.log("   Contexto maskCtx OK.");
                 } catch (e) {
                     alert("Error fatal: No se pudo crear canvas interno para máscara.");
                     console.error("   Error creando maskCtx:", e);
                     maskCanvas = maskCtx = null; return false;
                 }
                 console.log(`   Canvases configurados a ${w}x${h}`);
                 return true;
             }

             // --- Function to cache original image data ---
             function cacheOriginalImageData() {
                if (!originalImage || !canvas || !maskCanvas) {
                    originalImageDataCache = null;
                    console.warn("No se pudo cachear ImageData original: faltan elementos.");
                    return;
                }
                console.log("Cacheando ImageData original...");
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImage.naturalWidth;
                tempCanvas.height = originalImage.naturalHeight;
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                if (!tempCtx) {
                    console.error("Error creando contexto temporal para cachear ImageData.");
                    originalImageDataCache = null;
                    return;
                }
                try {
                    tempCtx.drawImage(originalImage, 0, 0);
                    originalImageDataCache = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    console.log("   ImageData original cacheada OK.");
                } catch (e) {
                    console.error("Error al obtener ImageData original para cache:", e);
                    originalImageDataCache = null;
                    // Alertar al usuario podría ser buena idea aquí si esto falla consistentemente
                    // alert("Advertencia: No se pudieron leer los datos de píxeles originales. La función 'Eliminar Hueco Interno' podría no funcionar.");
                }
             }

            function centerAndFitImage() { /* No change */
                if (!originalImage || !canvasOuterContainer) return;
                const imgWidth = originalImage.naturalWidth; const imgHeight = originalImage.naturalHeight;
                const contWidth = canvasOuterContainer.clientWidth; const contHeight = canvasOuterContainer.clientHeight;
                zoomLevel = Math.min(contWidth / imgWidth, contHeight / imgHeight) * 0.95;
                panX = (contWidth - imgWidth * zoomLevel) / 2;
                panY = (contHeight - imgHeight * zoomLevel) / 2;
                updateTransform(); updateStatusBar();
                console.log(`Imagen centrada/ajustada: zoom=${zoomLevel.toFixed(2)}, panX=${panX.toFixed(0)}, panY=${panY.toFixed(0)}`);
             }

            function resetMask() {
                 // Ensure mode is cancelled on mask reset
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                if (!maskCtx || !maskCanvas || !originalImage) return;
                console.log("Reseteando máscara a blanco (opaco).");
                maskCtx.fillStyle = 'white';
                maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
                history = [];
                saveStateToHistory(); // Guarda estado inicial
                updateActionButtonsState();
                requestRender();
            }

            function requestRender() { /* No change */
                const now = performance.now();
                if (now - lastRenderTime >= RENDER_THROTTLE) { renderCanvas(); lastRenderTime = now; }
            }

            function renderCanvas() { /* No change */
                if (!ctx || !originalImage || !maskCanvas) return;
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(originalImage, 0, 0);
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(maskCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            }

            function clearPreviewCanvas() { if (previewCtx) previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height); }

            function drawBrushPreview(imageX, imageY) { /* Don't draw preview if waiting for hole click */
                if (!previewCtx || isPanning || waitingForInnerHoleClick || currentTool === 'line' || currentTool === 'eraser-line' || isDrawingLine) {
                    clearPreviewCanvas();
                    return;
                }
                clearPreviewCanvas();
                const size = brushOptions.size * zoomLevel; const featherAmount = size * brushOptions.feather;
                const solidRadius = size / 2 - featherAmount / 2; const totalRadius = size / 2;
                const screenX = imageX * zoomLevel + panX; const screenY = imageY * zoomLevel + panY;
                const previewX = (screenX - panX) / zoomLevel; const previewY = (screenY - panY) / zoomLevel;
                previewCtx.save(); previewCtx.globalAlpha = 0.6;
                if (brushOptions.shape === 'circle') {
                    const gradient = previewCtx.createRadialGradient(previewX, previewY, Math.max(0, solidRadius / zoomLevel), previewX, previewY, totalRadius / zoomLevel);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    previewCtx.fillStyle = gradient; previewCtx.beginPath(); previewCtx.arc(previewX, previewY, totalRadius / zoomLevel, 0, Math.PI * 2); previewCtx.fill();
                } else {
                    const previewSize = brushOptions.size; const halfSize = previewSize / 2;
                    previewCtx.fillStyle = 'rgba(0, 0, 0, 0.6)'; previewCtx.fillRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize);
                    previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; previewCtx.lineWidth = 1 / zoomLevel;
                    previewCtx.strokeRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize);
                }
                previewCtx.restore();
            }

            function drawLinePreview(startX, startY, endX, endY) { /* Don't draw if waiting */
                 if (!previewCtx || waitingForInnerHoleClick) return;
                 clearPreviewCanvas(); previewCtx.save(); previewCtx.beginPath();
                 previewCtx.moveTo(startX, startY); previewCtx.lineTo(endX, endY);
                 previewCtx.strokeStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                 previewCtx.lineWidth = Math.max(1 / zoomLevel, brushOptions.size * 0.1);
                 previewCtx.setLineDash([5 / zoomLevel, 5 / zoomLevel]); previewCtx.stroke(); previewCtx.restore();
            }

            function applyMaskModification(drawX, drawY, tool, options) { /* No change */
                if (!maskCtx) return;
                const isEraser = tool === 'eraser' || tool === 'eraser-line';
                maskCtx.save();
                maskCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
                const size = options.size; const halfSize = size / 2;
                const feather = options.feather; const opacity = options.opacity;
                if (options.shape === 'circle') {
                    const solidRadius = halfSize * (1 - feather);
                    const gradient = maskCtx.createRadialGradient(drawX, drawY, solidRadius, drawX, drawY, halfSize);
                    if (isEraser) { gradient.addColorStop(0, `rgba(0,0,0, ${opacity})`); gradient.addColorStop(1, 'rgba(0,0,0, 0)'); }
                    else { gradient.addColorStop(0, `rgba(255,255,255, ${opacity})`); gradient.addColorStop(1, 'rgba(255,255,255, 0)'); }
                    maskCtx.fillStyle = gradient; maskCtx.beginPath(); maskCtx.arc(drawX, drawY, halfSize, 0, Math.PI * 2); maskCtx.fill();
                } else {
                    maskCtx.fillStyle = isEraser ? `rgba(0,0,0, ${opacity})` : `rgba(255,255,255, ${opacity})`;
                    maskCtx.fillRect(drawX - halfSize, drawY - halfSize, size, size);
                }
                maskCtx.restore();
            }

            function getInteractionPos(evt) { /* No change */
                if (!canvasOuterContainer) return { screenX:0, screenY:0, imageX: 0, imageY: 0 };
                const rect = canvasOuterContainer.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.pageX; const clientY = evt.clientY ?? evt.pageY;
                const screenX = clientX - rect.left; const screenY = clientY - rect.top;
                const imageX = (screenX - panX) / zoomLevel; const imageY = (screenY - panY) / zoomLevel;
                return { screenX, screenY, imageX, imageY };
            }

            function handleInteractionStart(e) {
                 if (!originalImage || isFloodFilling) return; // No interactuar si no hay imagen o se está procesando auto
                 if (e.preventDefault && e.cancelable) e.preventDefault();
                 const { screenX, screenY, imageX, imageY } = getInteractionPos(e);

                 // --- Handle Inner Hole Click First ---
                 if (waitingForInnerHoleClick) {
                     console.log(`Click detectado para eliminar hueco en: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                     removeInnerHoleAt(imageX, imageY); // Execute the removal
                     // --- MODIFICATION REMOVED ---
                     // cancelInnerHoleClickMode(); // <<< NO LONGER CANCELLING HERE for sticky mode
                     // --- END MODIFICATION ---
                     return; // Stop further processing for this click
                 }

                 // --- Original Interaction Logic ---
                 if (isSpacePressed) {
                    isPanning = true; panStartX = screenX - panX; panStartY = screenY - panY;
                    canvasOuterContainer.style.cursor = 'grabbing';
                 } else if (currentTool === 'line' || currentTool === 'eraser-line') {
                    if (!isDrawingLine) {
                         isDrawingLine = true; lineStartX = imageX; lineStartY = imageY;
                         console.log(`Inicio línea (${currentTool}) en: ${lineStartX.toFixed(0)}, ${lineStartY.toFixed(0)}`);
                         clearPreviewCanvas(); previewCtx.fillStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                         previewCtx.beginPath(); previewCtx.arc(lineStartX, lineStartY, 5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill();
                         canvasOuterContainer.style.cursor = 'crosshair';
                     } else {
                         console.log(`Fin línea (${currentTool}) en: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                         drawLineOnMask(lineStartX, lineStartY, imageX, imageY, currentTool, brushOptions);
                         saveStateToHistory(); requestRender(); isDrawingLine = false; clearPreviewCanvas();
                         setActiveTool(currentTool);
                     }
                 } else { // Brush or Eraser tool
                    isDrawing = true; lastX = imageX; lastY = imageY;
                    applyMaskModification(imageX, imageY, currentTool, brushOptions);
                    canvasOuterContainer.style.cursor = 'crosshair';
                 }
            }

            function handleInteractionMove(e) { /* Ignore move if waiting for click */
                 if (!originalImage || isFloodFilling || waitingForInnerHoleClick) return;
                 const { screenX, screenY, imageX, imageY } = getInteractionPos(e);
                 currentMousePos = { x: imageX, y: imageY };
                 if (isPanning) { panX = screenX - panStartX; panY = screenY - panStartY; updateTransform(); updateStatusBar(); }
                 else if (isDrawing) { drawLineOnMask(lastX, lastY, imageX, imageY, currentTool, brushOptions); lastX = imageX; lastY = imageY; requestRender(); drawBrushPreview(imageX, imageY); }
                 else if (isDrawingLine) { drawLinePreview(lineStartX, lineStartY, imageX, imageY); }
                 else { drawBrushPreview(imageX, imageY); }
            }

            function handleInteractionEnd(e) { /* No change needed here */
                if (isPanning) { isPanning = false; canvasOuterContainer.style.cursor = getToolCursor(); }
                else if (isDrawing) { isDrawing = false; saveStateToHistory(); clearPreviewCanvas(); drawBrushPreview(currentMousePos.x, currentMousePos.y); }
            }

             function drawLineOnMask(imgX1, imgY1, imgX2, imgY2, tool, options) { /* No change */
                 if (!maskCtx) return;
                 const isEraser = tool === 'eraser' || tool === 'eraser-line'; const size = options.size; const opacity = options.opacity;
                 maskCtx.save(); maskCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
                 maskCtx.beginPath(); maskCtx.moveTo(imgX1, imgY1); maskCtx.lineTo(imgX2, imgY2);
                 maskCtx.lineWidth = size; maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
                 maskCtx.strokeStyle = isEraser ? `rgba(0, 0, 0, ${opacity})` : `rgba(255, 255, 255, ${opacity})`;
                 maskCtx.stroke(); maskCtx.restore();
             }

            function setActiveTool(tool) {
                 // --- MODIFICATION: Cancel hole mode if changing TO another tool ---
                 if (tool !== 'hole-remover' && waitingForInnerHoleClick) {
                     cancelInnerHoleClickMode();
                 }
                 // --- END MODIFICATION ---

                 currentTool = tool; console.log("Herramienta activa:", tool);
                 // Remove active class from manual tool buttons
                 [brushBtn, eraserBtn, lineBtn, eraserLineBtn].forEach(btn => btn.classList.remove('active-tool'));

                 // Only add active class if it's one of the manual tool buttons
                 if (['brush', 'eraser', 'line', 'eraser-line'].includes(tool)) {
                    const activeBtn = document.getElementById(`${tool}-tool`);
                    if (activeBtn) activeBtn.classList.add('active-tool');
                 }
                 // Note: active state for hole remover is handled separately by its specific class

                 const isBrushOrEraser = tool === 'brush' || tool === 'eraser';
                 const isLineTool = tool === 'line' || tool === 'eraser-line';
                 const showBrushOptions = isBrushOrEraser || isLineTool; // Show size for lines too

                 featherOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none';
                 shapeOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none';
                 brushOptionsSection.style.display = showBrushOptions ? 'block' : 'none'; // Hide options if not brush/eraser/line

                 if (isDrawingLine && !isLineTool) {
                    isDrawingLine = false; clearPreviewCanvas(); console.log("Línea cancelada por cambio de herramienta.");
                 }
                 canvasOuterContainer.style.cursor = getToolCursor();
                 updateStatusBar();
            }


             function getToolCursor() {
                 if (waitingForInnerHoleClick) return 'crosshair'; // Cursor for clicking the hole
                 if (isSpacePressed) return 'grab';
                 if (isPanning) return 'grabbing';
                 if (isDrawingLine || currentTool === 'line' || currentTool === 'eraser-line') return 'crosshair';
                 return 'crosshair'; // Usar crosshair para pincel/borrador también
             }

            function updateToolOptionsDisplay() { /* No change */
                brushSizeValue.textContent = brushOptions.size; brushFeatherValue.textContent = brushOptions.feather.toFixed(2); brushOpacityValue.textContent = brushOptions.opacity.toFixed(2);
                shapeCircleBtn.classList.toggle('active-shape', brushOptions.shape === 'circle'); shapeSquareBtn.classList.toggle('active-shape', brushOptions.shape === 'square');
            }

            // --- History & State ---
            function updateActionButtonsState() {
                 const imageLoaded = !!originalImage && !!ctx && !!maskCtx;
                 const canUndo = history.length > 1;
                 // Standard buttons
                 undoBtn.disabled = !canUndo || isFloodFilling || waitingForInnerHoleClick; // Disable during hole mode too
                 undoCountSpan.textContent = Math.max(0, history.length - 1);
                 resetBtn.disabled = !imageLoaded || !canUndo || isFloodFilling || waitingForInnerHoleClick; // Disable during hole mode too
                 exportBtn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick;
                 copyBtn.disabled = !imageLoaded || !isClipboardWriteSupported || isFloodFilling || waitingForInnerHoleClick;
                 pasteBtn.disabled = !isClipboardReadSupported || isFloodFilling || waitingForInnerHoleClick;
                 // Manual tools
                 [brushBtn, eraserBtn, lineBtn, eraserLineBtn].forEach(btn => btn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick);
                 [brushSizeSlider, brushFeatherSlider, brushOpacitySlider, shapeCircleBtn, shapeSquareBtn].forEach(control => control.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick);
                 // Auto tools
                 removeEdgeBgBtn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick;
                 removeInnerHoleBtn.disabled = !imageLoaded || isFloodFilling; // Don't disable if waitingForInnerHoleClick is true, allow cancelling
                 edgeColorToleranceSlider.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick;
            }

            function checkClipboardSupport() { /* No change */
                 if (!isClipboardReadSupported) { pasteSupportWarning.classList.remove('hidden'); pasteBtn.disabled = true; pasteBtn.title = "Pegar no soportado/permitido."; console.warn("Clipboard API (read) no soportada."); }
                 else { pasteSupportWarning.classList.add('hidden'); }
                 if (!isClipboardWriteSupported) { clipboardSupportWarning.classList.remove('hidden'); copyBtn.disabled = true; copyBtn.title = "Copiar no soportado/permitido."; console.warn("Clipboard API (write) no soportada."); }
                 else { clipboardSupportWarning.classList.add('hidden'); }
            }

            function saveStateToHistory() { /* No change */
                 if (!maskCtx || !maskCanvas) return;
                 console.log("Guardando historial...");
                 history.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
                 if (history.length > MAX_HISTORY + 1) { history.shift(); }
                 console.log(`   Historial: ${history.length} estados.`);
                 updateActionButtonsState();
            }

            function undo() { /* Check for hole mode */
                if (history.length <= 1 || isFloodFilling || waitingForInnerHoleClick) return;
                console.log("Deshaciendo..."); history.pop();
                const previousState = history[history.length - 1];
                maskCtx.putImageData(previousState, 0, 0); requestRender(); updateActionButtonsState();
                console.log(`   Restaurado estado ${history.length}.`);
            }

            // --- Zoom/Pan ---
            function handleWheelZoom(e) { /* Prevent zoom while waiting */
                if (!originalImage || isFloodFilling || waitingForInnerHoleClick) return;
                e.preventDefault();
                const { screenX, screenY } = getInteractionPos(e);
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                zoomInOut(zoomFactor, screenX, screenY);
            }
            function updateTransform() { if (canvasInnerContainer) canvasInnerContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
            function updateStatusBar() { /* Updated to show hole remover status */
                zoomLevelSpan.textContent = Math.round(zoomLevel * 100);
                let toolName = 'Ninguna';
                if (waitingForInnerHoleClick) { // Show hole remover status first
                    toolName = 'Eliminar Hueco (Clic)';
                } else {
                    switch (currentTool) {
                         case 'brush': toolName = 'Pincel'; break;
                         case 'eraser': toolName = 'Borrador'; break;
                         case 'line': toolName = 'Línea (Guardar)'; break;
                         case 'eraser-line': toolName = 'Línea (Borrar)'; break;
                     }
                    if (isDrawingLine) toolName += ' (dibujando)';
                 }
                 currentToolSpan.textContent = toolName;
            }
            function handleKeyDown(e) { /* Added Esc key to cancel hole mode */
                 // Allow Escape key to cancel inner hole click mode
                 if (e.key === 'Escape' && waitingForInnerHoleClick) {
                    cancelInnerHoleClickMode();
                    e.preventDefault();
                    return;
                 }
                 // Prevent panning while waiting
                 if (e.key === ' ' && !isSpacePressed && !e.repeat && !waitingForInnerHoleClick) {
                    isSpacePressed = true; if (!isPanning) canvasOuterContainer.style.cursor = 'grab';
                 }
                 // Allow undo even in hole mode if needed (or keep disabled via updateActionButtonsState)
                 if (e.ctrlKey && e.key === 'z' && !e.repeat) {
                    e.preventDefault(); undo();
                 }
            }
            function handleKeyUp(e) { /* No change */
                 if (e.key === ' ') {
                     isSpacePressed = false;
                     if (!isPanning) canvasOuterContainer.style.cursor = getToolCursor();
                 }
            }
             function zoomInOut(factor, pivotX, pivotY) { /* No change */
                 if (!originalImage) return; const newZoomLevel = Math.max(0.1, Math.min(zoomLevel * factor, 15));
                 if (newZoomLevel === zoomLevel) return; const dx = (pivotX - panX) * (newZoomLevel / zoomLevel - 1);
                 const dy = (pivotY - panY) * (newZoomLevel / zoomLevel - 1); panX -= dx; panY -= dy;
                 zoomLevel = newZoomLevel; updateTransform(); updateStatusBar(); clearPreviewCanvas();
                 drawBrushPreview(currentMousePos.x, currentMousePos.y); // Don't draw if waiting
             }

            // --- UI Feedback ---
            function showButtonFeedback(button, status, message = null, duration = 1500) { /* No change */
                 if (!button) return;
                 // Clean previous status unless it's the active hole remover style we want to keep temporarily
                 if (!button.classList.contains('active-hole-remover')) {
                    button.classList.remove('success', 'error', 'working', 'cancelling');
                 } else {
                     // If it's the active hole remover, only remove specific feedback classes
                     button.classList.remove('success', 'error');
                 }

                 const originalText = button.dataset.originalHtml || button.innerHTML;
                 if (!button.dataset.originalHtml) button.dataset.originalHtml = originalText;
                 const originalTitle = button.dataset.originalTitle || button.title;
                 if (!button.dataset.originalTitle) button.dataset.originalTitle = originalTitle;

                 const statusClass = `btn-feedback ${status}`;
                 // Apply status class (like success/error)
                 button.classList.add(...statusClass.split(' '));

                 if (message) {
                      if (message.startsWith('<i class="fas ') || message.startsWith('<i class="fa ')) button.innerHTML = message;
                      else button.textContent = message;
                 }
                 // Disable only if working or cancelling, allow clicks for success/error feedback
                 button.disabled = (status === 'working' || status === 'cancelling');

                 // Clear the generic feedback timeout if it exists
                 if (button.feedbackTimeout) clearTimeout(button.feedbackTimeout);

                 // Set timeout to remove the status class and restore original state *unless* it's the hole remover button being handled specially
                 if (status !== 'working' && status !== 'cancelling' && button.id !== 'remove-inner-hole-btn') {
                      button.feedbackTimeout = setTimeout(() => {
                          button.classList.remove('success', 'error'); // Remove specific status
                          button.innerHTML = originalText; // Restore HTML
                          button.title = originalTitle; // Restore title
                          button.disabled = !originalImage; // Reset basic disabled state
                          delete button.dataset.originalHtml; // Clean up stored data
                          delete button.dataset.originalTitle;
                          updateActionButtonsState(); // Re-evaluate general state
                      }, duration);
                 } else if (button.id === 'remove-inner-hole-btn') {
                    // Special handling for hole remover button is done within removeInnerHoleAt
                 }
            }

            function showProcessingOverlay(message) { processingStatusText.textContent = message || "Procesando..."; processingOverlay.classList.remove('hidden'); }
            function hideProcessingOverlay() { processingOverlay.classList.add('hidden'); }

            // --- Export / Copy / Paste ---
            async function createFinalImageBlob(format = 'image/png') { /* No change */
                 if (!originalImage || !maskCanvas) return null; console.log("Creando Blob final...");
                 const finalCanvas = document.createElement('canvas'); finalCanvas.width = originalImage.naturalWidth; finalCanvas.height = originalImage.naturalHeight;
                 const finalCtx = finalCanvas.getContext('2d'); if (!finalCtx) { console.error("No se pudo crear contexto final."); return null; }
                 finalCtx.drawImage(originalImage, 0, 0); finalCtx.globalCompositeOperation = 'destination-in'; finalCtx.drawImage(maskCanvas, 0, 0);
                 return new Promise((resolve) => finalCanvas.toBlob(resolve, format));
            }
            async function exportImage() { /* No change */
                if (!originalImage || exportBtn.disabled) return; showButtonFeedback(exportBtn, 'working', 'Exportando...');
                 try {
                     const blob = await createFinalImageBlob(); if (!blob) throw new Error("No se pudo generar Blob.");
                     const url = URL.createObjectURL(blob); const a = document.createElement('a');
                     a.href = url; a.download = `${imageFilename}_sin_fondo.png`; document.body.appendChild(a);
                     a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                     showButtonFeedback(exportBtn, 'success', '<i class="fas fa-check"></i> Exportado');
                 } catch (error) { console.error("Error exportando:", error); alert(`Error al exportar: ${error.message}`); showButtonFeedback(exportBtn, 'error', '<i class="fas fa-times"></i> Error'); }
                 finally { updateActionButtonsState(); } // Re-enable based on state
            }
            async function copyImageToClipboard() { /* No change */
                 if (!originalImage || !isClipboardWriteSupported || copyBtn.disabled) return;
                 showButtonFeedback(copyBtn, 'working', 'Copiando...');
                 try {
                     const blob = await createFinalImageBlob('image/png'); if (!blob) throw new Error("No se pudo generar Blob.");
                     const item = new ClipboardItem({ 'image/png': blob }); await navigator.clipboard.write([item]);
                     showButtonFeedback(copyBtn, 'success', '<i class="fas fa-check"></i> Copiado');
                 } catch (error) { console.error("Error copiando:", error); let msg = error.name === 'NotAllowedError' ? "Permiso denegado." : "Error al copiar."; alert(`No se pudo copiar: ${msg}\n${error.message}`); showButtonFeedback(copyBtn, 'error', '<i class="fas fa-times"></i> Error'); }
                 finally { updateActionButtonsState(); } // Re-enable based on state
            }
            async function handlePasteButtonClick() { /* No change */
                 if (!isClipboardReadSupported || pasteBtn.disabled) return; console.log("Intentando pegar (botón)...");
                 showButtonFeedback(pasteBtn, 'working', 'Pegando...');
                 try {
                      const permission = await navigator.permissions.query({ name: 'clipboard-read' });
                      if (permission.state === 'denied') throw new Error("Permiso denegado.");
                      const clipboardItems = await navigator.clipboard.read(); let imageFound = false;
                      for (const item of clipboardItems) {
                          const imageType = item.types.find(type => type.startsWith("image/"));
                          if (imageType) { console.log(`Imagen encontrada: ${imageType}`); const blob = await item.getType(imageType); handleFile(new File([blob], "imagen_pegada.png", { type: imageType })); imageFound = true; break; }
                      }
                      if (imageFound) showButtonFeedback(pasteBtn, 'success', '<i class="fas fa-check"></i> Pegado');
                      else { console.log("No se encontró imagen."); showButtonFeedback(pasteBtn, 'error', 'No hay imagen', 1000); }
                 } catch (error) { console.error("Error pegando:", error); let msg = error.name === 'NotAllowedError' || error.message.includes("denied") ? "Permiso denegado." : "Error al pegar."; alert(`No se pudo pegar: ${msg}\n${error.message}`); showButtonFeedback(pasteBtn, 'error', '<i class="fas fa-times"></i> Error'); }
                 finally { updateActionButtonsState(); } // Re-enable based on state
            }
            function handleClipboardPaste(clipboardData) { /* No change */
                 if (!clipboardData?.items) return false; let imageFound = false;
                 for (const item of clipboardData.items) {
                     if (item.kind === 'file' && item.type.startsWith('image/')) {
                         const file = item.getAsFile(); if (file) { handleFile(file); imageFound = true; break; }
                     }
                 } return imageFound;
            }

            // --- Color Distance Utility ---
            function colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2; const dg = g1 - g2; const db = b1 - b2; return dr * dr + dg * dg + db * db; }

            // --- Flood Fill Background Removal (Edge Based) ---
            // (floodFillMask and handleRemoveBackgroundByFloodFill remain largely the same, focused on edge detection)
            function floodFillMask(originalData, maskData, startX, startY, toleranceSq, visited) {
                const width = originalData.width; const height = originalData.height;
                const originalPixels = originalData.data; const maskPixels = maskData.data;
                if (startX < 0 || startX >= width || startY < 0 || startY >= height || visited[startY][startX]) return false; // Return false if already visited or out of bounds
                const startIndex = (startY * width + startX) * 4;
                const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2];
                if (originalPixels[startIndex + 3] < 128) { visited[startY][startX] = true; return false; } // Ignore if the start is transparent

                const queue = [[startX, startY]]; visited[startY][startX] = true; maskPixels[startIndex + 3] = 0; // Erase starting point
                let iterations = 0; const maxIterations = width * height * 1.5;

                while (queue.length > 0) {
                    iterations++;
                    if (iterations % 500 === 0) {
                        if (cancelFloodFillRequest) {
                             console.log(`   *** Cancelación detectada DENTRO de floodFillMask desde (${startX}, ${startY}) ***`);
                             return true; // Indicate cancellation
                        }
                    }
                    if (iterations > maxIterations) { console.warn(`Flood fill (edge) excedió límite desde (${startX}, ${startY}).`); break; }

                    const [x, y] = queue.shift();
                    const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ];
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                             const nIndex = (ny * width + nx) * 4;
                             if (originalPixels[nIndex + 3] < 128) { visited[ny][nx] = true; continue; } // Ignore transparent neighbors
                             const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2];
                             const distSq = colorDistance(startR, startG, startB, nR, nG, nB);
                             if (distSq <= toleranceSq) {
                                 visited[ny][nx] = true; queue.push([nx, ny]); maskPixels[nIndex + 3] = 0; // Erase neighbor
                             }
                        }
                    }
                }
                return false; // Completed without cancelling
            }

            async function handleRemoveBackgroundByFloodFill() { // Edge-based removal
                console.log(`%c>>> handleRemoveBackgroundByFloodFill EJECUTADO - ${new Date().toLocaleTimeString()}`, 'color: blue; font-weight: bold; font-size: 1.2em;');
                 if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache) { // Check for cache too
                     console.warn("Flood Fill (edge) cancelado: Faltan elementos o cache de imagen original.");
                     alert("Error: No se pueden leer los píxeles originales para el fondo automático.");
                     return;
                 }
                 if (isFloodFilling) { console.warn("Flood Fill (edge) ya en proceso."); return; }

                isFloodFilling = true; cancelFloodFillRequest = false;
                updateActionButtonsState();
                showButtonFeedback(removeEdgeBgBtn, 'working', 'Analizando...');
                showProcessingOverlay('Analizando bordes...');
                await new Promise(resolve => setTimeout(resolve, 50)); // UI update delay

                try {
                    if (cancelFloodFillRequest) throw new Error("Cancelled");
                    processingStatusText.textContent = "Procesando fondo...";
                    const tolerance = parseInt(edgeColorToleranceSlider.value, 10);
                    const toleranceSq = tolerance * tolerance * 3;
                    console.log(`   Tolerancia (edge): ${tolerance}, Dist^2 <= ${toleranceSq.toFixed(0)}`);

                    // Use the cached original image data
                    const originalData = originalImageDataCache;
                    const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                    const width = maskImageData.width; const height = maskImageData.height;
                    const visited = Array(height).fill(null).map(() => Array(width).fill(false));
                    console.log("   Iniciando bucles Flood Fill (edge)...");
                    const startTime = performance.now();
                    let cancelledInsideLoop = false;

                    // Edge loops
                    for (let x = 0; x < width; x++) {
                         if (cancelFloodFillRequest) { cancelledInsideLoop = true; break; }
                         if (floodFillMask(originalData, maskImageData, x, 0, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                         if (floodFillMask(originalData, maskImageData, x, height - 1, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                    }
                    if (!cancelledInsideLoop) {
                         for (let y = 1; y < height - 1; y++) {
                             if (cancelFloodFillRequest) { cancelledInsideLoop = true; break; }
                             if (floodFillMask(originalData, maskImageData, 0, y, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                             if (floodFillMask(originalData, maskImageData, width - 1, y, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                         }
                    }

                    const endTime = performance.now();
                    console.log(`   Bucles Flood Fill (edge) terminados en ${((endTime - startTime)/1000).toFixed(2)}s. Cancelado en bucle: ${cancelledInsideLoop}`);

                    if (cancelFloodFillRequest || cancelledInsideLoop) throw new Error("Cancelled");

                    console.log("   Aplicando máscara (edge)...");
                    maskCtx.putImageData(maskImageData, 0, 0);
                    console.log("   Guardando y renderizando (edge)...");
                    saveStateToHistory(); renderCanvas();
                    console.log("<<< Fondo Automático (Edge) Completado.");
                    showButtonFeedback(removeEdgeBgBtn, 'success', '<i class="fas fa-check"></i> Hecho');

                } catch (error) {
                    if (error.message === "Cancelled") {
                        console.log("%cProceso Flood Fill (Edge) CANCELADO.", 'color: orange; font-weight: bold;');
                        showButtonFeedback(removeEdgeBgBtn, 'error', 'Cancelado', 1500);
                    } else {
                        console.error("Error durante Flood Fill (Edge):", error);
                        alert(`Error en proceso automático: ${error.message}`);
                        showButtonFeedback(removeEdgeBgBtn, 'error', '<i class="fas fa-times"></i> Error');
                    }
                } finally {
                     console.log("   Finally Flood Fill (Edge): Limpiando estado.");
                    isFloodFilling = false; cancelFloodFillRequest = false;
                    hideProcessingOverlay();
                     // Ensure button state is reset correctly if not showing final feedback
                     if (!removeEdgeBgBtn.classList.contains('success') && !removeEdgeBgBtn.classList.contains('error')) {
                         removeEdgeBgBtn.classList.remove('working', 'cancelling');
                         if (removeEdgeBgBtn.dataset.originalHtml) removeEdgeBgBtn.innerHTML = removeEdgeBgBtn.dataset.originalHtml;
                         if (removeEdgeBgBtn.dataset.originalTitle) removeEdgeBgBtn.title = removeEdgeBgBtn.dataset.originalTitle;
                     }
                    updateActionButtonsState();
                }
            }

            // --- NEW: Inner Hole Removal Logic ---
            function activateInnerHoleClickMode() {
                if (!originalImage || isFloodFilling || waitingForInnerHoleClick) return;
                console.log("Activando modo 'Eliminar Hueco Interno' (Pegajoso)");
                // Deactivate other tools visually
                setActiveTool('hole-remover'); // Set currentTool to specific identifier
                waitingForInnerHoleClick = true;
                removeInnerHoleBtn.classList.add('active-hole-remover'); // Visual feedback on button
                // Clear any previous feedback timeout for this button
                if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);
                // Ensure original HTML is stored if not already
                if (!removeInnerHoleBtn.dataset.originalHtml) removeInnerHoleBtn.dataset.originalHtml = removeInnerHoleBtn.innerHTML;
                if (!removeInnerHoleBtn.dataset.originalTitle) removeInnerHoleBtn.dataset.originalTitle = removeInnerHoleBtn.title;

                removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                canvasOuterContainer.style.cursor = 'crosshair'; // Indicate click mode
                updateStatusBar();
                updateActionButtonsState(); // Disable other buttons
                clearPreviewCanvas(); // Clear any brush preview
            }

            function cancelInnerHoleClickMode() {
                if (!waitingForInnerHoleClick) return;
                console.log("Cancelando modo 'Eliminar Hueco Interno'");
                waitingForInnerHoleClick = false;
                removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error'); // Remove active and feedback classes
                // Clear any pending feedback timeout
                if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);
                // Restore original button text/icon using the stored data-attribute
                if (removeInnerHoleBtn.dataset.originalHtml) {
                    removeInnerHoleBtn.innerHTML = removeInnerHoleBtn.dataset.originalHtml;
                } else { // Fallback
                     removeInnerHoleBtn.innerHTML = '<i class="fas fa-highlighter mr-1"></i> Eliminar Hueco Interno';
                }
                 // Restore default tool or previous tool if tracked
                setActiveTool('eraser'); // Setting to eraser is simpler
                updateStatusBar();
                updateActionButtonsState(); // Re-enable buttons
            }

            function removeInnerHoleAt(startX, startY) {
                console.log(`%c>>> removeInnerHoleAt (${startX.toFixed(0)}, ${startY.toFixed(0)})`, 'color: purple; font-weight: bold;');
                 if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache) {
                     console.warn("Eliminar Hueco cancelado: Faltan elementos o cache.");
                     alert("Error: No se pueden leer los datos de píxeles originales o la máscara.");
                      // --- MODIFICATION: Reset button text even on early exit ---
                      if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);
                      removeInnerHoleBtn.classList.add('error'); // Add error class temporarily
                      removeInnerHoleBtn.innerHTML = '<i class="fas fa-times"></i> Error';
                      holeRemoverFeedbackTimeout = setTimeout(() => {
                          if (waitingForInnerHoleClick) { // Check if still active
                               removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                               removeInnerHoleBtn.classList.remove('error'); // Ensure error class is removed
                          } else {
                              cancelInnerHoleClickMode(); // Fully cancel if mode changed during timeout
                          }
                      }, 1000); // Reset after 1 second
                      // --- END MODIFICATION ---
                     return;
                 }

                 const width = maskCanvas.width; const height = maskCanvas.height;
                 startX = Math.floor(startX); startY = Math.floor(startY);
                 if (startX < 0 || startX >= width || startY < 0 || startY >= height) {
                     console.log("   Clic fuera de los límites.");
                     // Optionally provide feedback that click was outside
                     return;
                 }

                 let pixelsChanged = 0;
                 let success = false;
                 let message = '';
                 let statusClass = 'error'; // Default to error for feedback

                 try {
                    const maskImageData = maskCtx.getImageData(0, 0, width, height);
                    const maskPixels = maskImageData.data;
                    const originalPixels = originalImageDataCache.data;
                    const tolerance = parseInt(edgeColorToleranceSlider.value, 10);
                    const toleranceSq = tolerance * tolerance * 3;
                    const startIndex = (startY * width + startX) * 4;

                    if (maskPixels[startIndex + 3] < 128) {
                        console.log("   El área clicada ya es transparente.");
                        message = 'Ya Transparente';
                        statusClass = 'error'; // Keep as error/warning feedback
                    } else {
                        const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2];
                        console.log(`   Color original en clic: R=${startR} G=${startG} B=${startB}, Tolerancia^2: ${toleranceSq}`);
                        const visited = Array(height).fill(null).map(() => Array(width).fill(false));
                        const queue = [[startX, startY]]; visited[startY][startX] = true; maskPixels[startIndex + 3] = 0; pixelsChanged = 1;
                        let iterations = 0; const maxIterations = width * height;

                        while (queue.length > 0) {
                            iterations++; if (iterations > maxIterations) { console.warn(`Flood fill (hueco) excedió límite.`); break; }
                            const [x, y] = queue.shift();
                            const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ];
                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                                    const nIndex = (ny * width + nx) * 4;
                                    if (maskPixels[nIndex + 3] > 128) { // Check MASK opacity
                                        const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2];
                                        const distSq = colorDistance(startR, startG, startB, nR, nG, nB); // Check ORIGINAL color
                                        if (distSq <= toleranceSq) {
                                            visited[ny][nx] = true; queue.push([nx, ny]); maskPixels[nIndex + 3] = 0; pixelsChanged++; // ERASE MASK
                                        }
                                    } else { visited[ny][nx] = true; } // Mark visited if already transparent in mask
                                }
                            }
                        }
                        console.log(`   Flood fill (hueco) completado. ${pixelsChanged} píxeles de máscara borrados.`);
                        if (pixelsChanged > 0) {
                            maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender();
                            message = '<i class="fas fa-check"></i> Hueco Borrado'; statusClass = 'success'; success = true;
                        } else {
                            message = 'No Cambios'; statusClass = 'error'; success = false; // Should not happen if start pixel was opaque
                        }
                    }
                 } catch (error) {
                    console.error("Error durante la eliminación de hueco interno:", error);
                    alert(`Error al eliminar hueco: ${error.message}`);
                    message = '<i class="fas fa-times"></i> Error'; statusClass = 'error'; success = false;
                 } finally {
                     // --- MODIFICATION: Handle button feedback and reset ---
                     const feedbackDuration = 1000; // How long to show success/error message

                     // Clear previous specific timeout if any
                     if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);

                     // Apply feedback styles and message
                     removeInnerHoleBtn.classList.remove('success', 'error'); // Clear previous feedback first
                     removeInnerHoleBtn.classList.add(statusClass); // Add current status class
                     removeInnerHoleBtn.innerHTML = message; // Show message

                     // Set timeout to revert text back to "active" state
                     holeRemoverFeedbackTimeout = setTimeout(() => {
                         removeInnerHoleBtn.classList.remove('success', 'error'); // Remove status class
                         if (waitingForInnerHoleClick) { // Check if mode is *still* active
                              removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                         } else {
                             // If mode got cancelled during the timeout, cancelInnerHoleClickMode should have reset the text already,
                             // but we can double-check or call it again for safety.
                             // console.log("Hole mode cancelled during feedback timeout.");
                             // cancelInnerHoleClickMode(); // Optionally call again
                         }
                     }, feedbackDuration);
                     // --- END MODIFICATION ---
                 }
            }


        }); // End DOMContentLoaded
    </script>
</body>
</html>
