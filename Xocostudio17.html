<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliminador de Fondos (Multi-Forma + Perímetro + Brush Shapes) - XocoStudio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- === Dependencias img-comparison-slider === -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/img-comparison-slider@8/dist/index.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/img-comparison-slider@8/dist/style.css" />
    <!-- === FIN Dependencias === -->

<style>
    /* --- Estilos CSS --- */
    body { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    /* Fondos */
    .checkerboard-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; background-color: #e5e5e5;}
    .solid-bg { background-image: none !important; }
    /* Botones Activos */
    .tool-btn.active-tool { background-color: #d1d5db; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); }
    .tool-btn.active-hole-remover { background-color: #fde047 !important; color: #713f12 !important; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #ca8a04; }
    .tool-btn.active-color-picker { background-color: #a5b4fc !important; color: #3730a3 !important; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #6366f1; }
    .brush-shape.active-shape { border-color: #3b82f6 !important; border-width: 2px !important; background-color: #eff6ff !important; /* Light blue background */ } /* Estilo más prominente para forma de pincel activa */
    .active-bg-option { background-color: #dbeafe !important; border-color: #60a5fa !important; }
    /* Canvas y Contenedores */
    #canvas-outer-container { width: 100%; height: 100%; overflow: hidden; position: relative; cursor: default; transition: background-color 0.3s ease; }
    #canvas-inner-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
    #image-canvas, #preview-canvas { display: block; position: absolute; top: 0; left: 0; max-width: none; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
    #preview-canvas { pointer-events: none; z-index: 1;} #image-canvas { z-index: 0; }
    main { height: calc(100vh - 64px - 32px); } /* Ajuste altura main */
    /* Iconos Compuestos (Líneas/Trazos) */
    .fa-line-eraser::before { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 1; } .fa-line-eraser::after { content: ""; position: absolute; left: 15%; top: 50%; width: 70%; height: 2px; background-color: currentColor; transform: translateY(-50%) rotate(0deg); opacity: 0.6; z-index: 0; } .tool-btn .fa-line-eraser { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } #eraser-line-tool i { font-size: 0.9em; } .fa-continuous-eraser-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } .fa-continuous-eraser-line::before { content: "\f55b"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; } .fa-continuous-eraser-line::after { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #ef4444; } #continuous-eraser-line-tool i { font-size: 1em; } .fa-continuous-keep-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; } .fa-continuous-keep-line::before { content: "\f55b"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; } .fa-continuous-keep-line::after { content: "\f55d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #22c55e; } #continuous-keep-line-tool i { font-size: 1em; }
    /* Feedback Botones */
    .btn-feedback { transition: background-color 0.2s ease-out, color 0.2s ease-out, border-color 0.2s ease-out; } .btn-feedback.success { background-color: #22c55e !important; color: white !important; border-color: #16a34a !important; } .btn-feedback.error { background-color: #ef4444 !important; color: white !important; border-color: #dc2626 !important; } .btn-feedback.working { background-color: #eab308 !important; color: white !important; border-color: #ca8a04 !important; cursor: wait; } .btn-feedback.cancelling { background-color: #f97316 !important; color: white !important; border-color: #ea580c !important; cursor: default; }
    /* Overlay Procesamiento */
    .processing-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: none; } .processing-overlay i { margin-bottom: 10px; } .processing-overlay p { margin-top: 0px; font-size: 1.1rem; }
    /* Estilos Colores Seleccionados */
    .color-tag { display: inline-flex; align-items: center; background-color: #e5e7eb; border-radius: 9999px; padding: 2px 8px; margin: 2px; font-size: 0.8rem; line-height: 1; }
    .color-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; border: 1px solid #9ca3af; display: inline-block; }
    .remove-color-btn { margin-left: 4px; cursor: pointer; color: #ef4444; background: none; border: none; padding: 0; font-weight: bold; line-height: 1; }
    .remove-color-btn:hover { color: #dc2626; }
    #selected-colors-list { max-height: 80px; overflow-y: auto; background-color: #f9fafb; padding: 4px; border-radius: 4px; border: 1px solid #d1d5db; }
    /* === Estilos Popup Comparación === */
    #compare-popup-overlay { backdrop-filter: blur(3px); }
    #compare-popup-content img-comparison-slider { max-width: 100%; max-height: 100%; min-height: 200px; outline: none; border-radius: 0.25rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1); }
    img-comparison-slider::part(handle) { color: #3b82f6; }
    img-comparison-slider::part(divider) { background-color: #3b82f6; }
    .compare-handle-icon { width: 100%; height: 100%; }
    /* === Iconos Herramientas Específicas === */
    #polygonal-lasso-tool i, #rectangle-erase-tool i, #shape-erase-square-tool i, #shape-erase-circle-tool i, #shape-erase-oval-tool i, #shape-erase-triangle-tool i, #shape-erase-pentagon-tool i, #shape-erase-hexagon-tool i, #shape-erase-heptagon-tool i, #shape-erase-octagon-tool i, #shape-erase-diamond-tool i, #shape-erase-trapezoid-tool i, #shape-erase-parallelogram-tool i, #shape-erase-star-tool i, #shape-erase-heart-tool i, #shape-erase-cross-tool i, #spline-lasso-erase-tool i, #interpolating-spline-lasso-erase-tool i, #eraser-tool i, #eraser-line-tool i > i, #continuous-eraser-line-tool i > i { color: #ef4444; }
    #polygonal-lasso-keep-tool i { color: #16a34a; }
    #polygonal-lasso-invert-tool i { color: magenta; }
    #brush-tool i, #line-tool i, #continuous-keep-line-tool i > i { color: initial; }

</style>
</head>
<body class="bg-gray-100 flex flex-col min-h-screen overflow-hidden">
<header class="bg-white shadow-md p-4 flex-shrink-0 flex items-center">
    <a href="https://xocostudio.com/" target="_blank" rel="noopener noreferrer" class="mr-4 flex-shrink-0"><img src="https://xocostudio.com/assets/images/xocostudio-354x128.png" alt="XocoStudio Logo" class="h-8"></a>
    <h1 class="text-xl md:text-2xl font-bold text-gray-800">Eliminador de Fondos (Multi-Forma + Perímetro + Brush Shapes)</h1>
</header>

<main class="flex-grow flex flex-col md:flex-row p-4 gap-4">
    <!-- Panel de Controles -->
    <aside class="w-full md:w-72 bg-white p-4 rounded-lg shadow space-y-6 flex-shrink-0 overflow-y-auto">
        <!-- Carga -->
        <div id="upload-section">
           <h2 class="text-lg font-semibold mb-2">1. Cargar Imagen</h2>
            <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors">
                <p>Arrastra y suelta</p>
                <p class="text-sm text-gray-500 my-2">o</p>
                <div class="flex flex-col items-center space-y-2">
                    <input type="file" id="file-input" accept="image/*" class="hidden">
                    <button id="upload-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded btn-feedback"><i class="fas fa-upload mr-1"></i> Seleccionar</button>
                    <button id="paste-btn" class="w-full bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Pegar (Ctrl+V)"><i class="fas fa-paste mr-1"></i> Pegar</button>
                </div>
                <p id="paste-support-warning" class="text-xs text-red-600 mt-2 hidden">Pegar no soportado.</p>
            </div>
            <p id="filename-display" class="text-xs text-gray-600 mt-2 truncate"></p>
        </div>
        <!-- Herramientas -->
        <div id="tools-section" class="space-y-4 hidden pt-4 border-t">
            <h2 class="text-lg font-semibold mb-2">2. Herramientas</h2>
            <!-- Auto / Color -->
            <div class="mb-4 space-y-2">
                <button id="remove-edge-bg-btn" class="w-full bg-cyan-600 hover:bg-cyan-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Fondo Automático basado en bordes"><i class="fas fa-wand-magic-sparkles mr-1"></i> Auto (Bordes)</button>
                <button id="remove-inner-hole-btn" class="tool-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Eliminar Hueco Interno (Clic en el hueco)"><i class="fas fa-highlighter mr-1"></i> Hueco (Clic)</button>
                <button id="apply-color-removal-btn" class="w-full bg-indigo-600 hover:bg-indigo-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50" title="Aplicar Eliminación por Color Seleccionado"><i class="fas fa-fill-drip mr-1"></i> Aplicar Color</button>
                <div class="mt-2">
                    <label for="edge-color-tolerance" class="block text-sm font-medium text-gray-700">Tolerancia (<span id="edge-color-tolerance-value">30</span>):</label>
                    <input type="range" id="edge-color-tolerance" min="1" max="150" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled>
                    <p class="text-xs text-gray-500 mt-1">Sensibilidad Auto/Hueco/Color/Varita.</p>
                </div>
            </div>
            <!-- Manual -->
            <div class="border-t pt-4">
                <p class="text-sm font-medium text-gray-700 mb-2">Ajuste manual:</p>
                 <div class="flex space-x-1 flex-wrap gap-y-1">
                    <button id="color-picker-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Seleccionar Color (P)" disabled><i class="fas fa-eye-dropper fa-fw"></i></button>
                    <button id="brush-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Pincel Conservar (B)" disabled><i class="fas fa-paint-brush fa-fw"></i></button>
                    <button id="eraser-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Borrador Eliminar (E)" disabled><i class="fas fa-eraser fa-fw"></i></button>
                    <button id="magic-wand-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Varita Mágica Eliminar (V)" disabled><i class="fas fa-wand-sparkles fa-fw"></i></button>
                    <!-- Formas (Borrar Interior) -->
                    <button id="rectangle-erase-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Rectángulo (Borrar Interior) (R)" disabled><i class="fas fa-vector-square fa-fw"></i></button>
                    <button id="shape-erase-square-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Cuadrado (Borrar Interior) (Shift+R)" disabled><i class="fas fa-square fa-fw"></i></button>
                    <button id="shape-erase-circle-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Círculo (Borrar Interior) (Shift+C)" disabled><i class="fas fa-circle fa-fw"></i></button>
                    <button id="shape-erase-oval-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Óvalo (Borrar Interior)" disabled><i class="fas fa-circle fa-fw" style="transform: scaleX(1.5);"></i></button>
                    <button id="shape-erase-triangle-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Triángulo (Borrar Interior)" disabled><i class="fas fa-play fa-fw" style="transform: rotate(-90deg);"></i></button>
                    <button id="shape-erase-pentagon-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Pentágono (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="shape-erase-hexagon-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Hexágono (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="shape-erase-heptagon-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Heptágono (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="shape-erase-octagon-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Octágono (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="shape-erase-diamond-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Rombo (Borrar Interior)" disabled><i class="fas fa-gem fa-fw"></i></button>
                    <button id="shape-erase-trapezoid-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trapecio (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="shape-erase-parallelogram-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Paralelogramo (Borrar Interior)" disabled><i class="fas fa-draw-polygon fa-fw" style="transform: skewX(-20deg);"></i></button>
                    <button id="shape-erase-star-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Estrella (Borrar Interior)" disabled><i class="fas fa-star fa-fw"></i></button>
                    <button id="shape-erase-heart-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Corazón (Borrar Interior)" disabled><i class="fas fa-heart fa-fw"></i></button>
                    <button id="shape-erase-cross-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Cruz (Borrar Interior)" disabled><i class="fas fa-plus fa-fw"></i></button>
                    <!-- Lazos -->
                    <button id="polygonal-lasso-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Lazo Poligonal (Borrar Interior) (O)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="polygonal-lasso-keep-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Lazo Poligonal (Conservar Interior) (K)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="polygonal-lasso-invert-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Lazo Poligonal (Borrar Exterior) (I)" disabled><i class="fas fa-draw-polygon fa-fw"></i></button>
                    <button id="spline-lasso-erase-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Lazo Curvo (Quad) (Borrar Interior) (S)" disabled><i class="fas fa-bezier-curve fa-fw"></i></button>
                    <button id="interpolating-spline-lasso-erase-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Lazo Curvo (Interp) (Borrar Interior) (Shift+S)" disabled><i class="fas fa-bezier-curve fa-fw"></i></button>
                    <!-- Líneas -->
                    <button id="line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Conservar (L)" disabled><i class="fas fa-minus fa-fw"></i></button>
                    <button id="eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Borrador (Shift+L)" disabled><i class="fa-line-eraser"></i></button>
                    <button id="continuous-keep-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trazo Conservar (C/W)" disabled><i class="fa-continuous-keep-line"></i></button>
                    <button id="continuous-eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trazo Borrar (X/Q)" disabled><i class="fa-continuous-eraser-line"></i></button>
                </div>
            </div>
             <!-- Colores Seleccionados -->
             <div id="selected-colors-section" class="space-y-2 hidden pt-4 border-t">
                 <label class="block text-sm font-medium text-gray-700">Colores Seleccionados:</label>
                 <div id="selected-colors-list" class="text-xs text-gray-600">
                     <p id="no-colors-selected" class="italic text-center p-2">Ningún color. Usa <i class="fas fa-eye-dropper fa-fw"></i></p>
                 </div>
             </div>
             <!-- Opciones Herramienta -->
             <div id="brush-options-section" class="space-y-3 pt-4 border-t">
                 <p class="text-sm font-medium text-gray-700 mb-2">Opciones Herramienta:</p>
                 <div><label for="brush-size">Tamaño/Grosor: <span id="brush-size-value">50</span>px</label><input type="range" id="brush-size" min="1" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                 <div id="feather-option"><label for="brush-feather">Difuminado: <span id="brush-feather-value">0.10</span></label><input type="range" id="brush-feather" min="0" max="1" step="0.05" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" title="Suavizado borde (Pincel/Borrador/Color/Lazo/Forma)" disabled></div>
                 <div><label for="brush-opacity">Opacidad (Pincel): <span id="brush-opacity-value">1.00</span></label><input type="range" id="brush-opacity" min="0.05" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                 <!-- Forma del Pincel/Borrador -->
                 <div id="shape-option">
                     <label>Forma (Pincel/Borrador):</label>
                     <div class="flex space-x-1 flex-wrap gap-y-1 mt-1">
                         <button id="brush-shape-circle" class="brush-shape p-1 border rounded-full w-6 h-6 bg-gray-700 disabled:opacity-50 flex items-center justify-center" title="Circular" disabled></button>
                         <button id="brush-shape-square" class="brush-shape p-1 border rounded w-6 h-6 bg-gray-700 disabled:opacity-50 flex items-center justify-center" title="Cuadrado" disabled></button>
                         <!-- Nuevas formas de pincel -->
                         <button id="brush-shape-diamond" class="brush-shape p-1 border rounded disabled:opacity-50 flex items-center justify-center w-6 h-6 hover:bg-gray-100" title="Rombo" disabled>
                             <i class="fas fa-gem fa-xs"></i>
                         </button>
                         <button id="brush-shape-hline" class="brush-shape p-1 border rounded disabled:opacity-50 flex items-center justify-center w-6 h-6 hover:bg-gray-100" title="Línea Horizontal" disabled>
                             <i class="fas fa-minus fa-xs"></i>
                         </button>
                         <button id="brush-shape-vline" class="brush-shape p-1 border rounded disabled:opacity-50 flex items-center justify-center w-6 h-6 hover:bg-gray-100" title="Línea Vertical" disabled>
                             <i class="fas fa-minus fa-xs" style="transform: rotate(90deg);"></i>
                         </button>
                    </div>
                </div>
             </div>
             <!-- Acciones -->
             <div class="pt-4 border-t space-y-3">
                 <!-- Historial y Acciones Máscara -->
                 <div class="flex space-x-2 flex-wrap gap-y-2">
                     <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Deshacer (Ctrl+Z)" disabled><i class="fas fa-undo"></i> (<span id="undo-count">0</span>)</button>
                     <button id="redo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Rehacer (Ctrl+Y)" disabled><i class="fas fa-redo"></i> (<span id="redo-count">0</span>)</button>
                     <button id="reset-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Resetear Máscara" disabled><i class="fas fa-trash-alt"></i> Reset</button>
                     <button id="invert-mask-btn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed btn-feedback" title="Invertir Selección Completa (Máscara)" disabled><i class="fas fa-exchange-alt"></i> Invertir Todo</button>
                 </div>
                 <!-- Fondo Previsualización -->
                 <div id="preview-bg-section" class="hidden space-y-1 pt-3 border-t">
                     <label class="block text-sm font-medium text-gray-700">Fondo Previsualización:</label>
                     <div class="flex items-center space-x-2 flex-wrap gap-y-1">
                         <button id="preview-bg-toggle-btn" class="p-2 rounded hover:bg-gray-200 disabled:opacity-50 border border-gray-300" title="Fondo damero" disabled>
                             <i id="preview-bg-icon" class="fas fa-th fa-fw"></i>
                         </button>
                         <button id="preview-bg-black-btn" class="p-2 rounded hover:bg-gray-200 disabled:opacity-50 border border-gray-300" title="Fondo negro sólido" disabled>
                             <i class="fas fa-square fa-fw" style="color: black;"></i>
                         </button>
                         <input type="color" id="preview-bg-color-input" value="#FFFFFF" class="h-8 w-10 border border-gray-300 rounded disabled:opacity-50 p-1 cursor-pointer" title="Color fondo sólido personalizado" disabled>
                         <button id="preview-perimeter-toggle-btn" class="p-2 rounded hover:bg-gray-200 disabled:opacity-50 border border-gray-300" title="Mostrar/Ocultar Perímetro Imagen" disabled>
                            <i class="fas fa-border-all fa-fw"></i>
                        </button>
                     </div>
                 </div>
             </div>
        </div> <!-- Fin Tools Section -->

        <!-- Exportar / Copiar / Comparar -->
         <div id="export-section" class="hidden pt-4 border-t space-y-2">
             <h2 class="text-lg font-semibold mb-2">3. Guardar / Copiar</h2>
             <button id="export-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-download mr-1"></i> Exportar PNG</button>
             <button id="copy-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-copy mr-1"></i> Copiar Imagen</button>
             <button id="compare-btn" class="w-full bg-teal-500 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback mt-2" disabled><i class="fas fa-columns mr-1"></i> Comparar</button>
             <p id="clipboard-support-warning" class="text-xs text-red-600 text-center hidden">Copiar no soportado.</p>
        </div>
    </aside>
    <!-- Área de Trabajo -->
    <section class="flex-grow bg-gray-300 rounded-lg shadow overflow-hidden relative" id="canvas-section">
        <div id="canvas-outer-container">
            <div id="canvas-inner-container">
                <canvas id="image-canvas" class="hidden"></canvas>
                <canvas id="preview-canvas" class="hidden"></canvas>
            </div>
             <p id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">Carga una imagen</p>
        </div>
        <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-50 pointer-events-none"> <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i> <p class="text-lg font-semibold ml-3">Cargando...</p> </div>
        <div id="processing-overlay" class="processing-overlay hidden"> <i class="fas fa-spinner fa-spin fa-3x"></i> <p id="processing-status-text">Procesando...</p> </div>
        <div id="status-bar" class="absolute bottom-0 left-0 bg-black bg-opacity-60 text-white text-xs p-1 rounded-tr z-10 pointer-events-none">Zoom: <span id="zoom-level">100</span>% | Herramienta: <span id="current-tool-status">Ninguna</span> | Rueda=Zoom, Espacio+Arrastrar=Mover</div>
    </section>
</main>

<!-- === Popup de Comparación === -->
<div id="compare-popup-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[1000] hidden p-4">
   <div id="compare-popup-content" class="bg-gray-100 p-4 md:p-6 rounded-lg shadow-xl max-w-5xl w-full relative flex flex-col max-h-[90vh]">
        <button id="compare-popup-close" class="absolute top-2 right-2 text-gray-500 hover:text-red-600 text-3xl leading-none z-10 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow">×</button>
        <h3 class="text-xl md:text-2xl font-semibold mb-4 text-center text-gray-800 flex-shrink-0">Comparación Antes / Después</h3>
        <div id="compare-container-wrapper" class="relative w-full flex-grow overflow-auto flex items-center justify-center p-2 bg-gray-300 rounded">
            <img-comparison-slider class="rendered">
                <img id="compare-before-img" slot="first" src="" alt="Antes" />
                <img id="compare-after-img" slot="second" src="" alt="Después" />
                 <svg slot="handle" class="compare-handle-icon" xmlns="http://www.w3.org/2000/svg" width="40" viewBox="-8 -3 16 6">
                     <path d="M -5 -2 L -7 -2 L -7 2 L -5 2 L -5 3 L 5 3 L 5 2 L 7 2 L 7 -2 L 5 -2 L 5 -3 L -5 -3 L -5 -2" fill="currentColor" />
                     <path d="M -4 -1 L -4 1 L -2 1 L -2 -1 L -4 -1 M 2 -1 L 2 1 L 4 1 L 4 -1 L 2 -1" fill="#fff"/>
                 </svg>
            </img-comparison-slider>
        </div>
        <p class="text-center text-sm text-gray-600 mt-2 flex-shrink-0">Arrastra el control deslizante</p>
    </div>
</div>
<!-- === FIN Popup === -->


<script>
    document.addEventListener('DOMContentLoaded', async () => {
        await customElements.whenDefined('img-comparison-slider');
        console.log("DOM Cargado - XocoStudio BG Remover (Multi-Forma V10 + Perímetro + Brush Shapes) - img-comparison-slider definido"); // V10

        // --- DOM Elements ---
        const dropZone = document.getElementById('drop-zone'),
            fileInput = document.getElementById('file-input'),
            uploadBtn = document.getElementById('upload-btn'),
            pasteBtn = document.getElementById('paste-btn'),
            pasteSupportWarning = document.getElementById('paste-support-warning'),
            filenameDisplay = document.getElementById('filename-display'),
            canvasSection = document.getElementById('canvas-section'),
            canvasOuterContainer = document.getElementById('canvas-outer-container'),
            canvasInnerContainer = document.getElementById('canvas-inner-container'),
            canvas = document.getElementById('image-canvas'),
            previewCanvas = document.getElementById('preview-canvas'),
            canvasPlaceholder = document.getElementById('canvas-placeholder'),
            loadingSpinner = document.getElementById('loading-spinner'),
            toolsSection = document.getElementById('tools-section'),
            exportSection = document.getElementById('export-section'),
            // Tool Buttons
            colorPickerBtn = document.getElementById('color-picker-tool'),
            brushBtn = document.getElementById('brush-tool'),
            eraserBtn = document.getElementById('eraser-tool'),
            magicWandBtn = document.getElementById('magic-wand-tool'),
            // Shape Tools
            rectangleEraseBtn = document.getElementById('rectangle-erase-tool'),
            shapeEraseSquareBtn = document.getElementById('shape-erase-square-tool'),
            shapeEraseCircleBtn = document.getElementById('shape-erase-circle-tool'),
            shapeEraseOvalBtn = document.getElementById('shape-erase-oval-tool'),
            shapeEraseTriangleBtn = document.getElementById('shape-erase-triangle-tool'),
            shapeErasePentagonBtn = document.getElementById('shape-erase-pentagon-tool'),
            shapeEraseHexagonBtn = document.getElementById('shape-erase-hexagon-tool'),
            shapeEraseHeptagonBtn = document.getElementById('shape-erase-heptagon-tool'),
            shapeEraseOctagonBtn = document.getElementById('shape-erase-octagon-tool'),
            shapeEraseDiamondBtn = document.getElementById('shape-erase-diamond-tool'),
            shapeEraseTrapezoidBtn = document.getElementById('shape-erase-trapezoid-tool'),
            shapeEraseParallelogramBtn = document.getElementById('shape-erase-parallelogram-tool'),
            shapeEraseStarBtn = document.getElementById('shape-erase-star-tool'),
            shapeEraseHeartBtn = document.getElementById('shape-erase-heart-tool'),
            shapeEraseCrossBtn = document.getElementById('shape-erase-cross-tool'),
            // Lasso Tools
            polygonalLassoBtn = document.getElementById('polygonal-lasso-tool'),
            polygonalLassoKeepBtn = document.getElementById('polygonal-lasso-keep-tool'),
            polygonalLassoInvertBtn = document.getElementById('polygonal-lasso-invert-tool'),
            splineLassoEraseBtn = document.getElementById('spline-lasso-erase-tool'), // Quad Spline
            interpolatingSplineLassoEraseBtn = document.getElementById('interpolating-spline-lasso-erase-tool'), // Interpolating Spline
            // Line Tools
            lineBtn = document.getElementById('line-tool'),
            eraserLineBtn = document.getElementById('eraser-line-tool'),
            continuousKeepLineBtn = document.getElementById('continuous-keep-line-tool'),
            continuousEraserLineBtn = document.getElementById('continuous-eraser-line-tool'),
            // Action Buttons
            removeEdgeBgBtn = document.getElementById('remove-edge-bg-btn'),
            removeInnerHoleBtn = document.getElementById('remove-inner-hole-btn'),
            applyColorRemovalBtn = document.getElementById('apply-color-removal-btn'),
            // Options
            brushOptionsSection = document.getElementById('brush-options-section'),
            featherOptionDiv = document.getElementById('feather-option'),
            shapeOptionDiv = document.getElementById('shape-option'), // Div para formas de PINCEL
            brushSizeSlider = document.getElementById('brush-size'),
            brushSizeValue = document.getElementById('brush-size-value'),
            brushFeatherSlider = document.getElementById('brush-feather'),
            brushFeatherValue = document.getElementById('brush-feather-value'),
            brushOpacitySlider = document.getElementById('brush-opacity'),
            brushOpacityValue = document.getElementById('brush-opacity-value'),
            shapeCircleBtn = document.getElementById('brush-shape-circle'), // Botones forma PINCEL
            shapeSquareBtn = document.getElementById('brush-shape-square'),
            shapeDiamondBtn = document.getElementById('brush-shape-diamond'), // <-- NUEVO pincel forma
            shapeHLineBtn = document.getElementById('brush-shape-hline'),   // <-- NUEVO pincel forma
            shapeVLineBtn = document.getElementById('brush-shape-vline'),   // <-- NUEVO pincel forma
            edgeColorToleranceSlider = document.getElementById('edge-color-tolerance'),
            edgeColorToleranceValueSpan = document.getElementById('edge-color-tolerance-value'),
            // Selected Colors UI
            selectedColorsSection = document.getElementById('selected-colors-section'),
            selectedColorsListDiv = document.getElementById('selected-colors-list'),
            noColorsSelectedP = document.getElementById('no-colors-selected'),
            // History & Mask Actions
            undoBtn = document.getElementById('undo-btn'),
            undoCountSpan = document.getElementById('undo-count'),
            redoBtn = document.getElementById('redo-btn'),
            redoCountSpan = document.getElementById('redo-count'),
            resetBtn = document.getElementById('reset-btn'),
            invertMaskBtn = document.getElementById('invert-mask-btn'),
            // Preview Background Controls
            previewBgSection = document.getElementById('preview-bg-section'),
            previewBgToggleBtn = document.getElementById('preview-bg-toggle-btn'),
            previewBgIcon = document.getElementById('preview-bg-icon'),
            previewBgBlackBtn = document.getElementById('preview-bg-black-btn'),
            previewBgColorInput = document.getElementById('preview-bg-color-input'),
            previewPerimeterToggleBtn = document.getElementById('preview-perimeter-toggle-btn'),
            // Export/Copy/Compare
            exportBtn = document.getElementById('export-btn'),
            copyBtn = document.getElementById('copy-btn'),
            clipboardSupportWarning = document.getElementById('clipboard-support-warning'),
            compareBtn = document.getElementById('compare-btn'),
            // Status/Overlays
            zoomLevelSpan = document.getElementById('zoom-level'),
            currentToolSpan = document.getElementById('current-tool-status'),
            processingOverlay = document.getElementById('processing-overlay'),
            processingStatusText = document.getElementById('processing-status-text'),
            // Compare Popup Elements
            comparePopupOverlay = document.getElementById('compare-popup-overlay'),
            comparePopupContent = document.getElementById('compare-popup-content'),
            comparePopupCloseBtn = document.getElementById('compare-popup-close'),
            compareBeforeImg = document.getElementById('compare-before-img'),
            compareAfterImg = document.getElementById('compare-after-img');

        // --- State Variables ---
        let ctx = null, previewCtx = null, maskCtx = null, originalImage = null, originalImageDataCache = null, maskCanvas = null, imageFilename = 'imagen';
        let isDrawing = false, lastX = 0, lastY = 0, history = [], redoHistory = [];
        let currentTool = 'eraser', currentShapeType = null;
        let brushOptions = { size: 50, feather: 0.1, opacity: 1.0, shape: 'circle' }; // Shape ahora también incluye 'diamond', 'hline', 'vline'
        let zoomLevel = 1.0, panX = 0, panY = 0, isPanning = false, panStartX = 0, panStartY = 0, isSpacePressed = false;
        let isDrawingLine = false, lineStartX = 0, lineStartY = 0;
        let isDrawingContinuousLine = false, lastContinuousLinePoint = null;
        let currentMousePos = { x: 0, y: 0 };
        let isClipboardWriteSupported = !!(navigator.clipboard && navigator.clipboard.write);
        let isClipboardReadSupported = !!(navigator.clipboard && navigator.clipboard.read);
        let isFloodFilling = false, cancelFloodFillRequest = false;
        let waitingForInnerHoleClick = false, holeRemoverFeedbackTimeout = null;
        let isColorPickingActive = false, selectedBackgroundColors = [], isProcessingColorRemoval = false;
        let previewMode = 'checkerboard', previewBackgroundColor = '#FFFFFF', showPerimeter = false;
        let isComparePopupOpen = false;
        let isProcessingMagicWand = false;
        // Shape Drawing State (Generic for SHAPE TOOLS, not brush shapes)
        let isDrawingShape = false, shapeStartX = 0, shapeStartY = 0, shapeCurrentX = 0, shapeCurrentY = 0;
        // Lasso States
        let isDrawingPolygon = false, polygonPoints = [];
        let isDrawingQuadraticSpline = false;
        let isDrawingInterpolatingSpline = false;
        let splinePoints = [];
        let wasDrawingShapeBeforePan = null;
        const MAX_HISTORY = 30;

        // --- Performance Throttling ---
        let lastRenderTime = 0; const RENDER_THROTTLE = 16; // ms

        // --- Verification ---
        if (!canvas || !previewCanvas || !dropZone || !fileInput || !uploadBtn || !pasteBtn ||
            !removeEdgeBgBtn || !removeInnerHoleBtn || !magicWandBtn ||
            !rectangleEraseBtn || !shapeEraseSquareBtn || !shapeEraseCircleBtn || !shapeEraseOvalBtn ||
            !shapeEraseTriangleBtn || !shapeErasePentagonBtn || !shapeEraseHexagonBtn || !shapeEraseHeptagonBtn ||
            !shapeEraseOctagonBtn || !shapeEraseDiamondBtn || !shapeEraseTrapezoidBtn || !shapeEraseParallelogramBtn ||
            !shapeEraseStarBtn || !shapeEraseHeartBtn || !shapeEraseCrossBtn ||
            !polygonalLassoBtn || !polygonalLassoKeepBtn || !polygonalLassoInvertBtn ||
            !splineLassoEraseBtn || !interpolatingSplineLassoEraseBtn ||
            !continuousKeepLineBtn || !continuousEraserLineBtn ||
            !canvasOuterContainer || !canvasInnerContainer || !previewBgSection || !previewBgToggleBtn ||
            !previewBgIcon || !previewBgBlackBtn || !previewBgColorInput || !previewPerimeterToggleBtn ||
            !toolsSection || !exportSection ||
            !colorPickerBtn || !applyColorRemovalBtn || !selectedColorsSection || !selectedColorsListDiv ||
            !compareBtn || !comparePopupOverlay || !comparePopupCloseBtn || !compareBeforeImg || !compareAfterImg ||
            !undoBtn || !redoBtn || !resetBtn || !invertMaskBtn ||
            !shapeCircleBtn || !shapeSquareBtn || !shapeDiamondBtn || !shapeHLineBtn || !shapeVLineBtn // Verificar botones de forma de pincel
           ) {
            console.error("ERROR CRÍTICO: Falta elemento DOM.");
            alert("Error: No se pudo iniciar la aplicación debido a elementos faltantes.");
            return;
        }
        console.log("Elementos DOM verificados OK.");

        // --- Initialization ---
        setActiveTool('eraser');
        updateToolOptionsDisplay();
        setupImageLoadingListeners();
        setupInteractionListeners();
        setupToolControlListeners();
        setupPreviewBackgroundListeners();
        setupComparePopupListeners();
        checkClipboardSupport();
        updateActionButtonsState();
        updatePreviewBackground();
        updateSelectedColorsUI();
        console.log("Inicialización completada.");

        // --- Helper Functions ---
        function cancelContinuousLineDrawing(silent = false) { if (isDrawingContinuousLine) { if (!silent) console.log("Cancelando trazo continuo."); isDrawingContinuousLine = false; lastContinuousLinePoint = null; clearPreviewCanvas(); updateStatusBar(); canvasOuterContainer.style.cursor = getToolCursor(); updateActionButtonsState(); if (!isComparePopupOpen && !isColorPickingActive && !isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape) drawToolPreview(currentMousePos.x, currentMousePos.y); return true; } return false; }
        function cancelCurrentAction(silent = false) {
             let actionCancelled = false;
             if (isColorPickingActive) { if (!silent) console.log("Cancelando modo Selección Color."); isColorPickingActive = false; actionCancelled = true; }
             if (waitingForInnerHoleClick) { if (!silent) console.log("Cancelando modo Eliminar Hueco."); waitingForInnerHoleClick = false; if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout); holeRemoverFeedbackTimeout = null; if (removeInnerHoleBtn) { removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error', 'working', 'cancelling'); if (removeInnerHoleBtn.dataset.originalHtml) removeInnerHoleBtn.innerHTML = removeInnerHoleBtn.dataset.originalHtml; if (removeInnerHoleBtn.dataset.originalTitle) removeInnerHoleBtn.title = removeInnerHoleBtn.dataset.originalTitle; } actionCancelled = true; }
             if (isDrawingLine) { if (!silent) console.log("Cancelando dibujo de línea."); isDrawingLine = false; clearPreviewCanvas(); actionCancelled = true; }
             if (isDrawingPolygon) { if (!silent) console.log("Cancelando Lazo Poligonal."); isDrawingPolygon = false; polygonPoints = []; clearPreviewCanvas(); actionCancelled = true;}
             if (isDrawingQuadraticSpline) { if (!silent) console.log("Cancelando Lazo Spline Cuadrático."); isDrawingQuadraticSpline = false; splinePoints = []; clearPreviewCanvas(); actionCancelled = true;}
             if (isDrawingInterpolatingSpline) { if (!silent) console.log("Cancelando Lazo Spline Interpolante."); isDrawingInterpolatingSpline = false; splinePoints = []; clearPreviewCanvas(); actionCancelled = true;}
             if (isDrawingShape) { if (!silent) console.log("Cancelando dibujo de forma (herramienta)."); isDrawingShape = false; shapeStartX = shapeStartY = shapeCurrentX = shapeCurrentY = 0; clearPreviewCanvas(); actionCancelled = true;}
             if (cancelContinuousLineDrawing(silent)) actionCancelled = true;
             if (isDrawing) { if (!silent) console.log("Cancelando dibujo (pincel/borrador)."); isDrawing = false; actionCancelled = true; }
             if (actionCancelled) {
                 wasDrawingShapeBeforePan = null; canvasOuterContainer.style.cursor = getToolCursor(); updateStatusBar(); updateActionButtonsState(); updateSelectedColorsUI();
                 if (!isComparePopupOpen && !isColorPickingActive && !waitingForInnerHoleClick && !isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape) {
                     clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y);
                 }
             }
             return actionCancelled;
        } // Fin cancelCurrentAction
        function simulateEscapeKeyPressLogic() { if (isComparePopupOpen) { closeComparePopup(); console.log("Popup cerrado por Esc."); return true; } if (cancelCurrentAction(true)) { console.log("Acción cancelada por Esc."); if (!isComparePopupOpen && !isColorPickingActive && !waitingForInnerHoleClick && !isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape) { clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); } return true; } return false; }
        function isGenerallyIdle() { return !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape && !waitingForInnerHoleClick && !isColorPickingActive && !isFloodFilling && !isProcessingColorRemoval && !isProcessingMagicWand && !isPanning; }

        // --- Setup Functions ---
        function setupImageLoadingListeners() { console.log("Configurando listeners carga..."); dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); const f = e.dataTransfer?.files?.[0]; if (f?.type.startsWith('image/')) handleFile(f); else if (f) alert('Suelta imagen válida.'); }); uploadBtn.addEventListener('click', () => fileInput.click()); pasteBtn.addEventListener('click', handlePasteButtonClick); fileInput.addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f?.type.startsWith('image/')) { handleFile(f); e.target.value = null; } else if (f) alert('Selecciona imagen válida.'); }); window.addEventListener('paste', (e) => { const a = document.activeElement; if (isComparePopupOpen || a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.isContentEditable) return; if (handleClipboardPaste(e.clipboardData)) e.preventDefault(); }); console.log("Listeners carga añadidos."); }
        function setupInteractionListeners() { console.log("Configurando listeners interacción..."); window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); canvasOuterContainer.addEventListener('mousedown', handleInteractionStart); canvasOuterContainer.addEventListener('mousemove', handleInteractionMove); window.addEventListener('mouseup', handleInteractionEnd); canvasOuterContainer.addEventListener('touchstart', (e) => handleInteractionStart(e.touches[0]), { passive: false }); canvasOuterContainer.addEventListener('touchmove', (e) => handleInteractionMove(e.touches[0]), { passive: false }); window.addEventListener('touchend', (e) => handleInteractionEnd(e.changedTouches[0])); window.addEventListener('touchcancel', (e) => handleInteractionEnd(e.changedTouches[0])); canvasOuterContainer.addEventListener('wheel', handleWheelZoom, { passive: false }); canvasOuterContainer.addEventListener('mouseleave', () => { if (!isDrawingLine && !isDrawingContinuousLine && !isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape && !isComparePopupOpen && !isColorPickingActive && !isPanning) clearPreviewCanvas(); }); console.log("Listeners interacción añadidos."); }
        function setupToolControlListeners() {
             console.log("Configurando listeners herramientas (Multi-Shape)...");
             // Botones básicos
             colorPickerBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('color-picker'); });
             brushBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('brush'); });
             eraserBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('eraser'); });
             magicWandBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('magic-wand'); });
             // Botones de Forma HERRAMIENTA
             rectangleEraseBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('rectangle'); });
             shapeEraseSquareBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('square'); });
             shapeEraseCircleBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('circle'); });
             shapeEraseOvalBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('oval'); });
             shapeEraseTriangleBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('triangle'); });
             shapeErasePentagonBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('pentagon'); });
             shapeEraseHexagonBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('hexagon'); });
             shapeEraseHeptagonBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('heptagon'); });
             shapeEraseOctagonBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('octagon'); });
             shapeEraseDiamondBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('diamond'); });
             shapeEraseTrapezoidBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('trapezoid'); });
             shapeEraseParallelogramBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('parallelogram'); });
             shapeEraseStarBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('star'); });
             shapeEraseHeartBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('heart'); });
             shapeEraseCrossBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveShapeTool('cross'); });
             // Lazos y Líneas
             polygonalLassoBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('polygonal-lasso'); });
             polygonalLassoKeepBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('polygonal-lasso-keep'); });
             polygonalLassoInvertBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('polygonal-lasso-invert'); });
             splineLassoEraseBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('spline-lasso-erase'); });
             interpolatingSplineLassoEraseBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('interpolating-spline-lasso-erase'); });
             lineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('line'); });
             eraserLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('eraser-line'); });
             continuousKeepLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('continuous-keep-line'); });
             continuousEraserLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; setActiveTool('continuous-eraser-line'); });
             // Opciones Pincel/Borrador/General
             brushSizeSlider.addEventListener('input', (e) => { if (isComparePopupOpen) return; brushOptions.size = parseInt(e.target.value); updateToolOptionsDisplay(); if (!isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape && !isPanning) drawToolPreview(currentMousePos.x, currentMousePos.y); });
             brushFeatherSlider.addEventListener('input', (e) => { if (isComparePopupOpen || isColorPickingActive) return; brushOptions.feather = parseFloat(e.target.value); updateToolOptionsDisplay(); if (!isDrawingPolygon && !isDrawingQuadraticSpline && !isDrawingInterpolatingSpline && !isDrawingShape && !isPanning) drawToolPreview(currentMousePos.x, currentMousePos.y);});
             brushOpacitySlider.addEventListener('input', (e) => { if (isComparePopupOpen) return; brushOptions.opacity = parseFloat(e.target.value); updateToolOptionsDisplay(); });
             // FORMAS DE PINCEL/BORRADOR
             shapeCircleBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'circle'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             shapeSquareBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'square'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             shapeDiamondBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'diamond'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             shapeHLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'hline'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             shapeVLineBtn.addEventListener('click', () => { if (isComparePopupOpen) return; brushOptions.shape = 'vline'; updateToolOptionsDisplay(); drawToolPreview(currentMousePos.x, currentMousePos.y); });
             edgeColorToleranceSlider.addEventListener('input', (e) => { edgeColorToleranceValueSpan.textContent = e.target.value; });
             // Acciones
             undoBtn.addEventListener('click', () => { if (isComparePopupOpen) return; undo(); });
             redoBtn.addEventListener('click', () => { if (isComparePopupOpen) return; redo(); });
             resetBtn.addEventListener('click', () => { if (isComparePopupOpen || !originalImage || history.length <= 1) return; if (confirm('¿Estás seguro de que quieres resetear todas las ediciones?')) { cancelCurrentAction(true); resetMask(); selectedBackgroundColors = []; updateSelectedColorsUI(); } });
             invertMaskBtn.addEventListener('click', () => { if (isComparePopupOpen || !originalImage || !isGenerallyIdle()) return; invertMask(); });
             exportBtn.addEventListener('click', exportImage); copyBtn.addEventListener('click', copyImageToClipboard);
             removeEdgeBgBtn.addEventListener('click', () => { if (isComparePopupOpen) return; cancelCurrentAction(true); if (isFloodFilling) { console.log("%cSolicitando cancelación BG...", 'color: orange;'); cancelFloodFillRequest = true; processingStatusText.textContent = "Cancelando..."; showButtonFeedback(removeEdgeBgBtn, 'cancelling', 'Cancelando...', 60000); } else if (isGenerallyIdle()) { handleRemoveBackgroundByFloodFill(); } else console.warn("Intento Auto BG mientras no idle."); }); removeInnerHoleBtn.addEventListener('click', () => { if (isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) { console.warn("Ignorando clic en Hueco: Proceso activo."); showButtonFeedback(removeInnerHoleBtn, 'error', 'Ocupado', 1000); return; } if (waitingForInnerHoleClick) { cancelCurrentAction(true); } else { cancelCurrentAction(true); activateInnerHoleClickMode(); } }); applyColorRemovalBtn.addEventListener('click', () => { if (isComparePopupOpen) return; cancelCurrentAction(true); if (!originalImage || selectedBackgroundColors.length === 0 || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) { console.warn("Aplicar Color bloqueado."); return; } if (isGenerallyIdle()) applyColorRemoval(); else console.warn("Intento Aplicar Color no idle."); });
             selectedColorsListDiv.addEventListener('click', (e) => { if (e.target.classList.contains('remove-color-btn')) { const r = parseInt(e.target.dataset.r, 10), g = parseInt(e.target.dataset.g, 10), b = parseInt(e.target.dataset.b, 10); removeSelectedColor(r, g, b); } });
             console.log("Listeners herramientas añadidos (Multi-Shape + Brush Shapes).");
        } // Fin setupToolControlListeners
        function setupPreviewBackgroundListeners() {
            console.log("Configurando listeners preview bg (con Perímetro)...");
            if (!previewBgToggleBtn || !previewBgBlackBtn || !previewBgColorInput || !previewPerimeterToggleBtn) { console.error("Faltan controles preview bg."); return; }
            previewBgToggleBtn.addEventListener('click', () => { if (!originalImage || isComparePopupOpen) return; if (previewMode !== 'checkerboard') { previewMode = 'checkerboard'; console.log("Modo fondo:", previewMode); updatePreviewBackground(); updateActionButtonsState(); } });
            previewBgBlackBtn.addEventListener('click', () => { if (!originalImage || isComparePopupOpen) return; previewMode = 'solid'; previewBackgroundColor = '#000000'; previewBgColorInput.value = '#000000'; console.log("Modo fondo: solid (negro)"); updatePreviewBackground(); updateActionButtonsState(); });
            previewBgColorInput.addEventListener('input', (e) => { if (!originalImage || isComparePopupOpen) return; previewBackgroundColor = e.target.value; if (previewMode !== 'solid') { previewMode = 'solid'; } console.log("Modo fondo: solid (personalizado)", previewBackgroundColor); updatePreviewBackground(); updateActionButtonsState(); });
            previewPerimeterToggleBtn.addEventListener('click', () => {
                if (!originalImage || isComparePopupOpen) return; showPerimeter = !showPerimeter; console.log("Mostrar Perímetro:", showPerimeter); updatePreviewBackgroundVisualState(); clearPreviewCanvas(); if(isGenerallyIdle()){ drawToolPreview(currentMousePos.x, currentMousePos.y); }
            });
            console.log("Listeners preview bg (con Perímetro) añadidos.");
        } // Fin setupPreviewBackgroundListeners
        function setupComparePopupListeners() { console.log("Configurando listeners popup compare..."); if (!compareBtn || !comparePopupOverlay || !comparePopupCloseBtn) { console.error("Faltan elementos popup compare."); return; } compareBtn.addEventListener('click', openComparePopup); comparePopupCloseBtn.addEventListener('click', closeComparePopup); comparePopupOverlay.addEventListener('click', (e) => { if (e.target === comparePopupOverlay) closeComparePopup(); }); console.log("Listeners popup compare añadidos."); }

        // --- Core Logic ---
        function handleFile(file) { console.log('>>> handleFile:', file?.name); cancelCurrentAction(true); if (!file?.type?.startsWith('image/')) { alert('Archivo no válido.'); console.error('Tipo inválido:', file?.type); return; } const reader = new FileReader(); reader.onloadstart = () => { console.log('   onloadstart'); showLoadingState(file.name); }; reader.onload = (e) => { console.log('   onload'); if (!e.target?.result) { handleLoadingError(file.name, 'Error leer archivo.'); return; } originalImage = new Image(); originalImage.onload = () => { console.log(`  onload OK: ${originalImage.naturalWidth}x${originalImage.naturalHeight}`); if (originalImage.naturalWidth === 0 || originalImage.naturalHeight === 0) { handleLoadingError(file.name, 'Dimensiones 0x0.'); originalImage = null; return; } initializeEditor(file.name, originalImage); }; originalImage.onerror = (err) => { console.error('onerror:', err); handleLoadingError(file.name, 'Error decodificar imagen.'); originalImage = null; }; originalImage.src = e.target.result; }; reader.onerror = (err) => { console.error('reader.onerror:', err); handleLoadingError(file.name, 'Error lectura.'); }; try { reader.readAsDataURL(file); } catch (error) { console.error("Error readAsDataURL:", error); handleLoadingError(file.name, 'Error iniciar lectura.'); } }
        function showLoadingState(fileName) { console.log("Loading state:", fileName); cancelCurrentAction(true); closeComparePopup(true); loadingSpinner.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden'); filenameDisplay.textContent = `Cargando: ${fileName}...`; toolsSection.classList.add('hidden'); previewBgSection.classList.add('hidden'); exportSection.classList.add('hidden'); canvas.classList.add('hidden'); previewCanvas.classList.add('hidden'); originalImage = null; originalImageDataCache = null; ctx = previewCtx = maskCtx = null; history = []; redoHistory = []; selectedBackgroundColors = []; updateSelectedColorsUI(); showPerimeter = false; updateActionButtonsState(); }
        function handleLoadingError(fileName, message) { console.error(`Error cargando ${fileName || 'img'}: ${message}`); cancelCurrentAction(true); closeComparePopup(true); alert(`Error cargar "${fileName || 'img'}":\n${message}`); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.remove('hidden'); filenameDisplay.textContent = `Error carga`; toolsSection.classList.add('hidden'); previewBgSection.classList.add('hidden'); exportSection.classList.add('hidden'); originalImage = null; originalImageDataCache = null; ctx = previewCtx = maskCtx = null; history = []; redoHistory = []; selectedBackgroundColors = []; updateSelectedColorsUI(); showPerimeter = false; updateActionButtonsState(); }
        function initializeEditor(fileName, loadedImage) { console.log(">>> initializeEditor:", fileName); cancelCurrentAction(true); closeComparePopup(true); if (!loadedImage || !loadedImage.naturalWidth || !loadedImage.naturalHeight) { handleLoadingError(fileName, "Datos imagen inválidos."); return; } imageFilename = fileName.replace(/\.[^/.]+$/, "") || 'imagen_editada'; filenameDisplay.textContent = `Editando: ${fileName} (${loadedImage.naturalWidth}x${loadedImage.naturalHeight})`; try { ctx = canvas.getContext('2d', { willReadFrequently: false }); previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true }); if (!ctx || !previewCtx) throw new Error("Contextos principales null."); console.log("   Contextos OK."); } catch (e) { console.error("ERROR FATAL contextos:", e); handleLoadingError(fileName, "Error interno contexto."); return; } if (!setupCanvases(loadedImage)) { handleLoadingError(fileName, "Error configurando lienzos."); return; } cacheOriginalImageData(); resetMask(); selectedBackgroundColors = []; updateSelectedColorsUI(); centerAndFitImage(); requestRender(); toolsSection.classList.remove('hidden'); previewBgSection.classList.remove('hidden'); exportSection.classList.remove('hidden'); canvas.classList.remove('hidden'); previewCanvas.classList.remove('hidden'); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.add('hidden'); setActiveTool('eraser'); updatePreviewBackground(); showPerimeter = false; updateActionButtonsState(); console.log("<<< initializeEditor completado."); }
        function setupCanvases(img) { console.log(">>> setupCanvases"); if (!img?.naturalWidth || !img?.naturalHeight || !canvas || !previewCanvas || !canvasInnerContainer) return false; const w = img.naturalWidth, h = img.naturalHeight; canvas.width = w; canvas.height = h; previewCanvas.width = w; previewCanvas.height = h; canvasInnerContainer.style.width = `${w}px`; canvasInnerContainer.style.height = `${h}px`; try { maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h; maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true }); if (!maskCtx) throw new Error("maskCtx null."); console.log("   maskCtx creado."); } catch (e) { alert("Error fatal: No se pudo crear máscara."); console.error("Error creando maskCtx:", e); maskCanvas = maskCtx = null; return false; } console.log(`   Canvases ${w}x${h}`); return true; }
        function cacheOriginalImageData() { if (!originalImage || !canvas || !maskCanvas) { originalImageDataCache = null; console.warn("No se pudo cachear ImageData."); return; } console.log("Cacheando ImageData..."); const tempC = document.createElement('canvas'); tempC.width = originalImage.naturalWidth; tempC.height = originalImage.naturalHeight; const tempCtx = tempC.getContext('2d', { willReadFrequently: true }); if (!tempCtx) { console.error("Error ctx temporal cache."); originalImageDataCache = null; return; } try { tempCtx.drawImage(originalImage, 0, 0); originalImageDataCache = tempCtx.getImageData(0, 0, tempC.width, tempC.height); console.log("   ImageData cacheada OK."); } catch (e) { console.error("Error getImageData cache (¿CORS?):", e); alert("Advertencia: No se pudo acceder a píxeles originales (¿CORS?). Herramientas auto/color/varita pueden fallar."); originalImageDataCache = null; } }
        function centerAndFitImage() { if (!originalImage || !canvasOuterContainer) return; const imgW = originalImage.naturalWidth, imgH = originalImage.naturalHeight; const contW = canvasOuterContainer.clientWidth, contH = canvasOuterContainer.clientHeight; if (contW <= 0 || contH <= 0) { console.warn("Contenedor sin dimensiones."); return; } zoomLevel = Math.min(1, Math.min(contW / imgW, contH / imgH) * 0.95); panX = (contW - imgW * zoomLevel) / 2; panY = (contH - imgH * zoomLevel) / 2; updateTransform(); updateStatusBar(); console.log(`Imagen centrada: zoom=${zoomLevel.toFixed(2)}, panX=${panX.toFixed(0)}, panY=${panY.toFixed(0)}`); }
        function resetMask() { if (!maskCtx || !maskCanvas || !originalImage) return; console.log("Reseteando máscara."); maskCtx.fillStyle = 'white'; maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height); history = []; redoHistory = []; saveStateToHistory(); updateActionButtonsState(); requestRender(); }

        // --- Rendering & Previews ---
        function requestRender() { const n = performance.now(); if (n - lastRenderTime >= RENDER_THROTTLE) { renderCanvas(); lastRenderTime = n; } }
        function renderCanvas() { if (!ctx || !originalImage || !maskCanvas) return; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(originalImage, 0, 0); ctx.globalCompositeOperation = 'destination-in'; ctx.drawImage(maskCanvas, 0, 0); ctx.globalCompositeOperation = 'source-over'; }
        function clearPreviewCanvas() {
            if (previewCtx) {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                if (showPerimeter && originalImage) {
                    drawPerimeterPreview();
                }
            }
        } // Fin clearPreviewCanvas
        function drawPerimeterPreview() {
            if (!previewCtx || !originalImage || !showPerimeter) return;
            previewCtx.save();
            previewCtx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
            previewCtx.lineWidth = 1 / zoomLevel;
            previewCtx.setLineDash([4 / zoomLevel, 2 / zoomLevel]);
            previewCtx.strokeRect(0, 0, originalImage.naturalWidth, originalImage.naturalHeight);
            previewCtx.setLineDash([]);
            previewCtx.restore();
        } // Fin drawPerimeterPreview
        function drawToolPreview(ix, iy) {
             if (isPanning) { clearPreviewCanvas(); return; }
             clearPreviewCanvas(); // Limpia y redibuja perímetro si activo
             if (isComparePopupOpen || isColorPickingActive || waitingForInnerHoleClick || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) return;

             const isAnyPolygonalLasso = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert'].includes(currentTool);
             const isQuadraticSplineLasso = currentTool === 'spline-lasso-erase';
             const isInterpolatingSplineLasso = currentTool === 'interpolating-spline-lasso-erase';
             const isShapeEraseTool = currentTool === 'shape-erase';

             if (currentTool === 'brush' || currentTool === 'eraser') drawBrushPreview(ix, iy);
             else if (isDrawingLine && (currentTool === 'line' || currentTool === 'eraser-line')) { drawSimpleLineMarker(lineStartX, lineStartY); drawSimpleLinePreview(lineStartX, lineStartY, ix, iy); }
             else if (isDrawingContinuousLine && (currentTool === 'continuous-keep-line' || currentTool === 'continuous-eraser-line')) { if (lastContinuousLinePoint) { drawContinuousLineMarker(lastContinuousLinePoint.x, lastContinuousLinePoint.y); drawContinuousLinePreview(lastContinuousLinePoint.x, lastContinuousLinePoint.y, ix, iy); } }
             else if (isShapeEraseTool && isDrawingShape) { drawShapePreview(); }
             else if (isAnyPolygonalLasso && isDrawingPolygon) { drawPolygonPreview(); }
             else if (isQuadraticSplineLasso && isDrawingQuadraticSpline) { drawQuadraticSplineLassoPreview(); }
             else if (isInterpolatingSplineLasso && isDrawingInterpolatingSpline) { drawInterpolatingSplineLassoPreview(); }
             else if (['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line', 'magic-wand'].includes(currentTool) || isAnyPolygonalLasso || isQuadraticSplineLasso || isInterpolatingSplineLasso || isShapeEraseTool ) drawCrosshairPreview(ix, iy);
        } // Fin drawToolPreview
        function drawBrushPreview(ix, iy) {
            if (!previewCtx || !originalImage) return;
            const s = brushOptions.size; const hs = s / 2;
            previewCtx.save(); previewCtx.globalAlpha = 0.6;
            const isEraser = currentTool === 'eraser';
            const pc = isEraser ? 'rgba(255,0,0,0.7)' : 'rgba(0,0,0,0.7)'; // Preview color
            const oc = 'rgba(255,255,255,0.9)'; // Outline color
            const lineWidth = 1 / zoomLevel;

            previewCtx.beginPath(); // Iniciar path para todas las formas

            switch (brushOptions.shape) {
                case 'circle':
                    const f = s * brushOptions.feather;
                    const sr = Math.max(0, hs - f / 2);
                    const tr = hs;
                    const g = previewCtx.createRadialGradient(ix, iy, sr, ix, iy, tr);
                    g.addColorStop(0, pc); g.addColorStop(1, 'rgba(0,0,0,0)');
                    previewCtx.fillStyle = g;
                    previewCtx.arc(ix, iy, tr, 0, Math.PI * 2);
                    previewCtx.fill();
                    previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.stroke(); // Stroke outline for circle
                    break;
                case 'square':
                    previewCtx.fillStyle = pc;
                    previewCtx.fillRect(ix - hs, iy - hs, s, s);
                    previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.strokeRect(ix - hs, iy - hs, s, s); // Stroke outline for square
                    break;
                case 'diamond':
                    previewCtx.fillStyle = pc;
                    previewCtx.moveTo(ix, iy - hs);       // Top
                    previewCtx.lineTo(ix + hs, iy);       // Right
                    previewCtx.lineTo(ix, iy + hs);       // Bottom
                    previewCtx.lineTo(ix - hs, iy);       // Left
                    previewCtx.closePath();
                    previewCtx.fill();
                    previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.stroke(); // Stroke outline
                    break;
                case 'hline':
                    const hLineHeight = Math.max(1, Math.min(3, s * 0.1)); // Grosor relativo con límites
                    previewCtx.fillStyle = pc;
                    previewCtx.fillRect(ix - hs, iy - hLineHeight / 2, s, hLineHeight);
                    // Podríamos añadir borde, pero puede ser confuso
                    // previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.strokeRect(ix - hs, iy - hLineHeight / 2, s, hLineHeight);
                    break;
                 case 'vline':
                    const vLineWidth = Math.max(1, Math.min(3, s * 0.1)); // Grosor relativo con límites
                    previewCtx.fillStyle = pc;
                    previewCtx.fillRect(ix - vLineWidth / 2, iy - hs, vLineWidth, s);
                    // previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.strokeRect(ix - vLineWidth / 2, iy - hs, vLineWidth, s);
                    break;
                default: // Fallback to circle if shape is unknown
                     previewCtx.fillStyle = pc; previewCtx.arc(ix, iy, hs, 0, Math.PI * 2); previewCtx.fill();
                     previewCtx.strokeStyle = oc; previewCtx.lineWidth = lineWidth; previewCtx.stroke();
                     break;
            } // Fin switch
            previewCtx.restore();
        } // Fin drawBrushPreview
        function drawSimpleLineMarker(ix, iy) { if (!previewCtx) return; const k = currentTool === 'line'; previewCtx.fillStyle = k ? 'rgba(0,255,0,0.7)' : 'rgba(255,0,0,0.7)'; previewCtx.beginPath(); previewCtx.arc(ix, iy, 5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }
        function drawSimpleLinePreview(sx, sy, ex, ey) { if (!previewCtx) return; const k = currentTool === 'line'; previewCtx.save(); previewCtx.beginPath(); previewCtx.moveTo(sx, sy); previewCtx.lineTo(ex, ey); previewCtx.strokeStyle = k ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'; previewCtx.lineWidth = brushOptions.size; previewCtx.lineCap = 'round'; previewCtx.stroke(); previewCtx.restore(); }
        function drawContinuousLineMarker(ix, iy) { if (!previewCtx) return; const k = currentTool === 'continuous-keep-line'; previewCtx.fillStyle = k ? 'rgba(0,255,0,0.8)' : 'rgba(255,0,0,0.8)'; previewCtx.beginPath(); previewCtx.arc(ix, iy, 4 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }
        function drawContinuousLinePreview(sx, sy, ex, ey) { if (!previewCtx) return; const k = currentTool === 'continuous-keep-line'; previewCtx.save(); previewCtx.beginPath(); previewCtx.moveTo(sx, sy); previewCtx.lineTo(ex, ey); previewCtx.strokeStyle = k ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'; previewCtx.lineWidth = brushOptions.size; previewCtx.lineCap = 'round'; previewCtx.stroke(); previewCtx.restore(); }
        function drawCrosshairPreview(ix, iy) { if (!previewCtx) return; const cs = 10 / zoomLevel; previewCtx.save(); previewCtx.strokeStyle = 'rgba(0,0,0,0.6)'; previewCtx.lineWidth = 1 / zoomLevel; previewCtx.beginPath(); previewCtx.moveTo(ix - cs, iy); previewCtx.lineTo(ix + cs, iy); previewCtx.moveTo(ix, iy - cs); previewCtx.lineTo(ix, iy + cs); previewCtx.stroke(); previewCtx.restore(); }
        function drawShapePreview() {
            if (!previewCtx || !isDrawingShape || currentTool !== 'shape-erase') return;
            clearPreviewCanvas(); // Limpia y redibuja perímetro si activo
            previewCtx.save();
            const wRaw = shapeCurrentX - shapeStartX; const hRaw = shapeCurrentY - shapeStartY; const absW = Math.abs(wRaw); const absH = Math.abs(hRaw); const x = wRaw < 0 ? shapeCurrentX : shapeStartX; const y = hRaw < 0 ? shapeCurrentY : shapeStartY;
            const scaledLineWidth = 1.5 / zoomLevel; const scaledDash = [4 / zoomLevel, 4 / zoomLevel];
            previewCtx.lineWidth = scaledLineWidth; previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.fillStyle = 'rgba(255, 0, 0, 0.1)'; previewCtx.setLineDash(scaledDash);
            previewCtx.beginPath();
            switch (currentShapeType) {
                case 'rectangle': previewCtx.rect(x, y, absW, absH); break;
                case 'square': const size = Math.min(absW, absH); const sqX = wRaw < 0 ? x + absW - size : x; const sqY = hRaw < 0 ? y + absH - size : y; previewCtx.rect(sqX, sqY, size, size); break;
                case 'circle': const radiusC = Math.min(absW, absH) / 2; previewCtx.arc(x + absW / 2, y + absH / 2, radiusC, 0, Math.PI * 2); break;
                case 'oval': previewCtx.ellipse(x + absW / 2, y + absH / 2, absW / 2, absH / 2, 0, 0, Math.PI * 2); break;
                case 'triangle': previewCtx.moveTo(x + absW / 2, y); previewCtx.lineTo(x + absW, y + absH); previewCtx.lineTo(x, y + absH); previewCtx.closePath(); break;
                case 'pentagon': drawRegularPolygonHelper(previewCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 5); previewCtx.closePath(); break;
                case 'hexagon': drawRegularPolygonHelper(previewCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 6); previewCtx.closePath(); break;
                case 'heptagon': drawRegularPolygonHelper(previewCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 7); previewCtx.closePath(); break;
                case 'octagon': drawRegularPolygonHelper(previewCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 8); previewCtx.closePath(); break;
                case 'diamond': previewCtx.moveTo(x + absW / 2, y); previewCtx.lineTo(x + absW, y + absH / 2); previewCtx.lineTo(x + absW / 2, y + absH); previewCtx.lineTo(x, y + absH / 2); previewCtx.closePath(); break;
                case 'trapezoid': const topWidthTrap = absW * 0.6; const topOffsetTrap = (absW - topWidthTrap) / 2; previewCtx.moveTo(x + topOffsetTrap, y); previewCtx.lineTo(x + topOffsetTrap + topWidthTrap, y); previewCtx.lineTo(x + absW, y + absH); previewCtx.lineTo(x, y + absH); previewCtx.closePath(); break;
                case 'parallelogram': const skewFactorP = absW * 0.2; previewCtx.moveTo(x + skewFactorP, y); previewCtx.lineTo(x + absW, y); previewCtx.lineTo(x + absW - skewFactorP, y + absH); previewCtx.lineTo(x, y + absH); previewCtx.closePath(); break;
                case 'star': drawStarHelper(previewCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, Math.min(absW, absH) / 4, 5); previewCtx.closePath(); break;
                case 'heart': drawHeartHelper(previewCtx, x, y, absW, absH); previewCtx.closePath(); break;
                case 'cross': drawCrossHelper(previewCtx, x, y, absW, absH); break;
                default: previewCtx.rect(x, y, absW, absH);
            } // Fin switch
            previewCtx.fill(); previewCtx.setLineDash([]); previewCtx.stroke(); previewCtx.restore();
        } // Fin drawShapePreview


        // --- Mask Modification ---
        function applyMaskModification(dx, dy, t, o) {
            if (!maskCtx) return;
            const isEraser = t === 'eraser';
            if (t !== 'brush' && !isEraser) return;

            maskCtx.save();
            maskCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
            const s = o.size; const hs = s / 2;
            const f = o.feather; const op = o.opacity;
            const c = isEraser ? '0,0,0' : '255,255,255'; // Color para fillStyle

            maskCtx.beginPath(); // Empezar path para todas las formas

            switch (o.shape) {
                case 'circle':
                    // Aplicar feathering solo para círculo
                    const sr = Math.max(0, hs * (1 - f));
                    const g = maskCtx.createRadialGradient(dx, dy, sr, dx, dy, hs);
                    g.addColorStop(0, `rgba(${c}, ${op})`);
                    g.addColorStop(1, `rgba(${c}, 0)`);
                    maskCtx.fillStyle = g;
                    maskCtx.arc(dx, dy, hs, 0, Math.PI * 2);
                    break;
                case 'square':
                    // Sin feathering para cuadrado por simplicidad
                    maskCtx.fillStyle = `rgba(${c}, ${op})`;
                    maskCtx.rect(dx - hs, dy - hs, s, s);
                    break;
                case 'diamond':
                     // Sin feathering
                    maskCtx.fillStyle = `rgba(${c}, ${op})`;
                    maskCtx.moveTo(dx, dy - hs); maskCtx.lineTo(dx + hs, dy); maskCtx.lineTo(dx, dy + hs); maskCtx.lineTo(dx - hs, dy); maskCtx.closePath();
                    break;
                 case 'hline':
                    // Sin feathering
                    const hLineHeight = Math.max(1, Math.min(3, s * 0.1)); // Mismo grosor que preview
                    maskCtx.fillStyle = `rgba(${c}, ${op})`;
                    maskCtx.rect(dx - hs, dy - hLineHeight / 2, s, hLineHeight);
                    break;
                 case 'vline':
                     // Sin feathering
                    const vLineWidth = Math.max(1, Math.min(3, s * 0.1));
                    maskCtx.fillStyle = `rgba(${c}, ${op})`;
                    maskCtx.rect(dx - vLineWidth / 2, dy - hs, vLineWidth, s);
                    break;
                default: // Fallback a círculo sin feather
                    maskCtx.fillStyle = `rgba(${c}, ${op})`;
                    maskCtx.arc(dx, dy, hs, 0, Math.PI * 2);
                    break;
            } // Fin switch

            maskCtx.fill();
            maskCtx.restore();
        } // Fin applyMaskModification
        function drawLineOnMask(x1, y1, x2, y2, t, o) { if (!maskCtx) return; const ie = t === 'eraser' || t === 'eraser-line' || t === 'continuous-eraser-line', s = o.size, op = o.opacity; maskCtx.save(); maskCtx.globalCompositeOperation = ie ? 'destination-out' : 'source-over'; maskCtx.beginPath(); maskCtx.moveTo(x1, y1); maskCtx.lineTo(x2, y2); maskCtx.lineWidth = s; maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round'; const c = ie ? `rgba(0,0,0,${op})` : `rgba(255,255,255,${op})`; maskCtx.strokeStyle = c; maskCtx.stroke(); maskCtx.restore(); requestRender(); }
        function applyShapeErase() {
            if (!maskCtx || !maskCanvas || currentTool !== 'shape-erase') { console.error("applyShapeErase: Contexto inválido o herramienta incorrecta"); return; }
            const wRaw = shapeCurrentX - shapeStartX; const hRaw = shapeCurrentY - shapeStartY; const absW = Math.abs(wRaw); const absH = Math.abs(hRaw); const x = wRaw < 0 ? shapeCurrentX : shapeStartX; const y = hRaw < 0 ? shapeCurrentY : shapeStartY;
            if (absW < 1 || absH < 1) { console.log("Forma inválida (área 0), no se aplica."); return; }
            console.log(`Aplicando Forma [${currentShapeType}] Borrar Interior`);
            maskCtx.save(); maskCtx.globalCompositeOperation = 'destination-out'; maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; maskCtx.beginPath();
             switch (currentShapeType) {
                 case 'rectangle': maskCtx.rect(x, y, absW, absH); break;
                case 'square': const size = Math.min(absW, absH); const sqX = wRaw < 0 ? x + absW - size : x; const sqY = hRaw < 0 ? y + absH - size : y; maskCtx.rect(sqX, sqY, size, size); break;
                case 'circle': const radiusC = Math.min(absW, absH) / 2; maskCtx.arc(x + absW / 2, y + absH / 2, radiusC, 0, Math.PI * 2); break;
                case 'oval': maskCtx.ellipse(x + absW / 2, y + absH / 2, absW / 2, absH / 2, 0, 0, Math.PI * 2); break;
                case 'triangle': maskCtx.moveTo(x + absW / 2, y); maskCtx.lineTo(x + absW, y + absH); maskCtx.lineTo(x, y + absH); maskCtx.closePath(); break;
                case 'pentagon': drawRegularPolygonHelper(maskCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 5); break;
                case 'hexagon': drawRegularPolygonHelper(maskCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 6); break;
                case 'heptagon': drawRegularPolygonHelper(maskCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 7); break;
                case 'octagon': drawRegularPolygonHelper(maskCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, 8); break;
                case 'diamond': maskCtx.moveTo(x + absW / 2, y); maskCtx.lineTo(x + absW, y + absH / 2); maskCtx.lineTo(x + absW / 2, y + absH); maskCtx.lineTo(x, y + absH / 2); maskCtx.closePath(); break;
                case 'trapezoid': const topWidthTrap = absW * 0.6; const topOffsetTrap = (absW - topWidthTrap) / 2; maskCtx.moveTo(x + topOffsetTrap, y); maskCtx.lineTo(x + topOffsetTrap + topWidthTrap, y); maskCtx.lineTo(x + absW, y + absH); maskCtx.lineTo(x, y + absH); maskCtx.closePath(); break;
                case 'parallelogram': const skewFactorP = absW * 0.2; maskCtx.moveTo(x + skewFactorP, y); maskCtx.lineTo(x + absW, y); maskCtx.lineTo(x + absW - skewFactorP, y + absH); maskCtx.lineTo(x, y + absH); maskCtx.closePath(); break;
                case 'star': drawStarHelper(maskCtx, x + absW / 2, y + absH / 2, Math.min(absW, absH) / 2, Math.min(absW, absH) / 4, 5); break;
                case 'heart': drawHeartHelper(maskCtx, x, y, absW, absH); break;
                case 'cross': drawCrossHelper(maskCtx, x, y, absW, absH); break;
                default: maskCtx.rect(x, y, absW, absH);
            } // Fin switch
            maskCtx.fill(); maskCtx.restore();
            const featherAmount = parseFloat(brushFeatherSlider.value);
            if (featherAmount > 0) {
                try { console.log(`  Aplicando difuminado global post-forma (valor: ${featherAmount})...`); let maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height); maskImageData = applyFeatherToMask(maskImageData, maskCanvas.width, maskCanvas.height, featherAmount); maskCtx.putImageData(maskImageData, 0, 0); console.log("  Difuminado aplicado post-forma."); }
                catch(e) { console.error("Error aplicando difuminado post-forma:", e); alert("Error al aplicar el difuminado a la forma.") }
            } // Fin if feather
            requestRender();
        } // Fin applyShapeErase

        // --- Helper Functions for Drawing Shapes ---
        function drawRegularPolygonHelper(ctx, cx, cy, radius, sides) { if (sides < 3 || radius <= 0) return; const angleStep = (Math.PI * 2) / sides; const startAngle = -Math.PI / 2; ctx.moveTo(cx + radius * Math.cos(startAngle), cy + radius * Math.sin(startAngle)); for (let i = 1; i <= sides; i++) { const angle = startAngle + i * angleStep; ctx.lineTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle)); } }
        function drawStarHelper(ctx, cx, cy, outerRadius, innerRadius, points) { if (points < 2 || outerRadius <= 0 || innerRadius <= 0) return; const angleStep = Math.PI / points; let currentAngle = -Math.PI / 2; ctx.moveTo(cx + outerRadius * Math.cos(currentAngle), cy + outerRadius * Math.sin(currentAngle)); for (let i = 0; i < points; i++) { currentAngle += angleStep; ctx.lineTo(cx + innerRadius * Math.cos(currentAngle), cy + innerRadius * Math.sin(currentAngle)); currentAngle += angleStep; ctx.lineTo(cx + outerRadius * Math.cos(currentAngle), cy + outerRadius * Math.sin(currentAngle)); } }
        function drawHeartHelper(ctx, x, y, width, height) { if (width <= 0 || height <= 0) return; const topCurveHeight = height * 0.3; const bottomPointY = y + height; const controlPointXOffset = width * 0.5; const controlPointYOffset = height * 0.1; const sideControlPointYOffset = height * 0.8; ctx.moveTo(x + width / 2, y + topCurveHeight); ctx.bezierCurveTo(x + controlPointXOffset / 2, y + controlPointYOffset, x, y + topCurveHeight / 2, x, y + topCurveHeight); ctx.bezierCurveTo(x, y + sideControlPointYOffset, x + width / 2, bottomPointY - controlPointYOffset*2, x + width / 2, bottomPointY); ctx.bezierCurveTo(x + width / 2, bottomPointY - controlPointYOffset*2, x + width, y + sideControlPointYOffset, x + width, y + topCurveHeight); ctx.bezierCurveTo(x + width, y + topCurveHeight / 2, x + width - controlPointXOffset / 2, y + controlPointYOffset, x + width / 2, y + topCurveHeight); }
        function drawCrossHelper(ctx, x, y, width, height) { if (width <= 0 || height <= 0) return; const hThickness = Math.max(1, height / 3); const vThickness = Math.max(1, width / 3); const hY = y + (height - hThickness) / 2; const vX = x + (width - vThickness) / 2; ctx.moveTo(x, hY); ctx.lineTo(vX, hY); ctx.lineTo(vX, y); ctx.lineTo(vX + vThickness, y); ctx.lineTo(vX + vThickness, hY); ctx.lineTo(x + width, hY); ctx.lineTo(x + width, hY + hThickness); ctx.lineTo(vX + vThickness, hY + hThickness); ctx.lineTo(vX + vThickness, y + height); ctx.lineTo(vX, y + height); ctx.lineTo(vX, hY + hThickness); ctx.lineTo(x, hY + hThickness); ctx.closePath(); }


        // --- Interaction Handling ---
        function getInteractionPos(e) { if (!canvasOuterContainer) return { screenX: 0, screenY: 0, imageX: 0, imageY: 0 }; const r = canvasOuterContainer.getBoundingClientRect(), cx = e.clientX ?? e.pageX ?? 0, cy = e.clientY ?? e.pageY ?? 0, sx = cx - r.left, sy = cy - r.top, ix = (sx - panX) / zoomLevel, iy = (sy - panY) / zoomLevel; return { screenX: sx, screenY: sy, imageX: ix, imageY: iy }; }
        function handleInteractionStart(e) {
            if (isColorPickingActive && !isComparePopupOpen) { if (!originalImage) return; if (e.preventDefault && e.cancelable) e.preventDefault(); const { imageX: ix, imageY: iy } = getInteractionPos(e); pickColorAt(ix, iy); return; }
            if (waitingForInnerHoleClick) { if (!originalImage || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) { console.warn("Interacción Clic-Hueco ignorada."); return; } if (e.preventDefault && e.cancelable) e.preventDefault(); const { imageX: ix, imageY: iy } = getInteractionPos(e); removeInnerHoleAt(ix, iy); return; }
            if (isComparePopupOpen || !originalImage || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) { return; }

            if (e.preventDefault && e.cancelable) e.preventDefault();
            const { screenX: sx, screenY: sy, imageX: ix, imageY: iy } = getInteractionPos(e);

            if (isSpacePressed) { isPanning = true; panStartX = sx - panX; panStartY = sy - panY; if (isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape) { wasDrawingShapeBeforePan = currentTool === 'shape-erase' ? currentShapeType : currentTool; } else { wasDrawingShapeBeforePan = null; } canvasOuterContainer.style.cursor = 'grabbing'; clearPreviewCanvas(); return; }

            switch (currentTool) {
                case 'magic-wand': applyMagicWand(ix, iy); break;
                case 'shape-erase': isDrawingShape = true; shapeStartX = ix; shapeStartY = iy; shapeCurrentX = ix; shapeCurrentY = iy; updateActionButtonsState(); updateStatusBar(); drawShapePreview(); canvasOuterContainer.style.cursor = 'crosshair'; console.log(`Iniciada forma [${currentShapeType}] en:`, ix.toFixed(1), iy.toFixed(1)); break;
                case 'polygonal-lasso': case 'polygonal-lasso-keep': case 'polygonal-lasso-invert': if (!isDrawingPolygon) { isDrawingPolygon = true; polygonPoints = [[ix, iy]]; updateActionButtonsState(); updateStatusBar(); drawPolygonPreview(); console.log(`Iniciado lazo poligonal (${currentTool}) en:`, ix.toFixed(1), iy.toFixed(1)); } else { const firstPoint = polygonPoints[0]; const distanceToStart = Math.sqrt(Math.pow(ix - firstPoint[0], 2) + Math.pow(iy - firstPoint[1], 2)); const closeThreshold = 10 / zoomLevel; if (polygonPoints.length >= 2 && distanceToStart < closeThreshold) { console.log(`Cerrando lazo poligonal (${currentTool}).`); finalizePolygon(true); } else { polygonPoints.push([ix, iy]); console.log(`Añadido punto a lazo poligonal (${currentTool}):`, ix.toFixed(1), iy.toFixed(1)); drawPolygonPreview(); } } break;
                case 'spline-lasso-erase': if (!isDrawingQuadraticSpline) { isDrawingQuadraticSpline = true; splinePoints = [[ix, iy]]; updateActionButtonsState(); updateStatusBar(); drawQuadraticSplineLassoPreview(); console.log(`Iniciado lazo spline cuadrático (${currentTool}) en:`, ix.toFixed(1), iy.toFixed(1)); } else { const firstPoint = splinePoints[0]; const distanceToStart = Math.sqrt(Math.pow(ix - firstPoint[0], 2) + Math.pow(iy - firstPoint[1], 2)); const closeThreshold = 10 / zoomLevel; if (splinePoints.length >= 2 && distanceToStart < closeThreshold) { console.log(`Cerrando lazo spline cuadrático (${currentTool}).`); finalizeQuadraticSplineLasso(true); } else { splinePoints.push([ix, iy]); console.log(`Añadido punto a lazo spline cuadrático (${currentTool}):`, ix.toFixed(1), iy.toFixed(1)); drawQuadraticSplineLassoPreview(); } } break;
                case 'interpolating-spline-lasso-erase': if (!isDrawingInterpolatingSpline) { isDrawingInterpolatingSpline = true; splinePoints = [[ix, iy]]; updateActionButtonsState(); updateStatusBar(); drawInterpolatingSplineLassoPreview(); console.log(`Iniciado lazo spline interpolante (${currentTool}) en:`, ix.toFixed(1), iy.toFixed(1)); } else { const firstPoint = splinePoints[0]; const distanceToStart = Math.sqrt(Math.pow(ix - firstPoint[0], 2) + Math.pow(iy - firstPoint[1], 2)); const closeThreshold = 10 / zoomLevel; if (splinePoints.length >= 2 && distanceToStart < closeThreshold) { console.log(`Cerrando lazo spline interpolante (${currentTool}).`); finalizeInterpolatingSplineLasso(true); } else { splinePoints.push([ix, iy]); console.log(`Añadido punto a lazo spline interpolante (${currentTool}):`, ix.toFixed(1), iy.toFixed(1)); drawInterpolatingSplineLassoPreview(); } } break;
                case 'line': case 'eraser-line': if (!isDrawingLine) { isDrawingLine = true; lineStartX = ix; lineStartY = iy; updateActionButtonsState(); drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'crosshair'; } else { drawLineOnMask(lineStartX, lineStartY, ix, iy, currentTool, brushOptions); saveStateToHistory(); isDrawingLine = false; clearPreviewCanvas(); updateActionButtonsState(); canvasOuterContainer.style.cursor = getToolCursor(); drawToolPreview(ix, iy); } break;
                case 'continuous-keep-line': case 'continuous-eraser-line': if (!isDrawingContinuousLine) { isDrawingContinuousLine = true; lastContinuousLinePoint = { x: ix, y: iy }; updateActionButtonsState(); drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'crosshair'; } else { drawLineOnMask(lastContinuousLinePoint.x, lastContinuousLinePoint.y, ix, iy, currentTool, brushOptions); lastContinuousLinePoint = { x: ix, y: iy }; saveStateToHistory(); drawToolPreview(ix, iy); } break;
                case 'brush': case 'eraser': default: if (isDrawingLine) { isDrawingLine = false; clearPreviewCanvas(); updateActionButtonsState(); } cancelContinuousLineDrawing(true); cancelCurrentAction(true); isDrawing = true; lastX = ix; lastY = iy; updateActionButtonsState(); applyMaskModification(ix, iy, currentTool, brushOptions); requestRender(); canvasOuterContainer.style.cursor = 'none'; drawToolPreview(ix, iy); break;
            } // Fin switch
        } // Fin handleInteractionStart
        function handleInteractionMove(e) { if ((isComparePopupOpen && !waitingForInnerHoleClick) || isColorPickingActive) { canvasOuterContainer.style.cursor = getToolCursor(); return; } if (waitingForInnerHoleClick) { canvasOuterContainer.style.cursor = getToolCursor(); return; } if (!originalImage) return; const { screenX: sx, screenY: sy, imageX: ix, imageY: iy } = getInteractionPos(e); currentMousePos = { x: ix, y: iy }; const busy = isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand; if (isPanning) { panX = sx - panStartX; panY = sy - panStartY; updateTransform(); updateStatusBar(); return; } if (busy) { canvasOuterContainer.style.cursor = getToolCursor(); clearPreviewCanvas(); } else if (isDrawingShape) { shapeCurrentX = ix; shapeCurrentY = iy; drawShapePreview(); canvasOuterContainer.style.cursor = 'crosshair'; } else if (isDrawingPolygon) { drawPolygonPreview(); canvasOuterContainer.style.cursor = getToolCursor(); } else if (isDrawingQuadraticSpline) { drawQuadraticSplineLassoPreview(); canvasOuterContainer.style.cursor = getToolCursor(); } else if (isDrawingInterpolatingSpline) { drawInterpolatingSplineLassoPreview(); canvasOuterContainer.style.cursor = getToolCursor(); } else if (isDrawing) { drawLineOnMask(lastX, lastY, ix, iy, currentTool, brushOptions); lastX = ix; lastY = iy; drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = 'none'; } else { drawToolPreview(ix, iy); canvasOuterContainer.style.cursor = (currentTool === 'brush' || currentTool === 'eraser') ? 'none' : getToolCursor(); } }
        function handleInteractionEnd(e) { if (isComparePopupOpen || isColorPickingActive) return; if (isPanning) { isPanning = false; canvasOuterContainer.style.cursor = isSpacePressed ? 'grab' : getToolCursor(); if (!isSpacePressed && wasDrawingShapeBeforePan) { restoreDrawingPreview(wasDrawingShapeBeforePan); wasDrawingShapeBeforePan = null; } } else if (isDrawingShape) { isDrawingShape = false; applyShapeErase(); saveStateToHistory(); updateActionButtonsState(); updateStatusBar(); clearPreviewCanvas(); canvasOuterContainer.style.cursor = getToolCursor(); drawToolPreview(currentMousePos.x, currentMousePos.y); } else if (isDrawing) { isDrawing = false; saveStateToHistory(); updateActionButtonsState(); canvasOuterContainer.style.cursor = 'none'; drawToolPreview(currentMousePos.x, currentMousePos.y); } }
        function restoreDrawingPreview(toolOrShapeType) { if (!toolOrShapeType) return; console.log("Restaurando preview para:", toolOrShapeType); if (toolOrShapeType.startsWith('polygonal-lasso')) { drawPolygonPreview(); } else if (toolOrShapeType === 'spline-lasso-erase') { drawQuadraticSplineLassoPreview(); } else if (toolOrShapeType === 'interpolating-spline-lasso-erase') { drawInterpolatingSplineLassoPreview(); } else { if (currentTool === 'shape-erase' && isDrawingShape && currentShapeType === toolOrShapeType) { drawShapePreview(); } else { drawToolPreview(currentMousePos.x, currentMousePos.y); } } }
        function handleKeyDown(e) { if (isComparePopupOpen && e.key === 'Escape') { e.preventDefault(); closeComparePopup(); return; } if (isComparePopupOpen) return; const finp = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable; if (e.key === 'Escape') { const c = simulateEscapeKeyPressLogic(); if (c || !finp) e.preventDefault(); return; } if (e.key === ' ' && !isSpacePressed && !e.repeat && !finp) { isSpacePressed = true; if (isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape) { wasDrawingShapeBeforePan = currentTool === 'shape-erase' ? currentShapeType : currentTool; } else { wasDrawingShapeBeforePan = null; } canvasOuterContainer.style.cursor = 'grab'; clearPreviewCanvas(); e.preventDefault(); } const idle = isGenerallyIdle(); if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey && !e.repeat) { if (idle) { e.preventDefault(); undo(); } else console.log("Undo bloqueado."); } if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z')) && !e.repeat) { if (idle) { e.preventDefault(); redo(); } else console.log("Redo bloqueado."); } if (idle && !finp && !e.ctrlKey && !e.altKey && !e.metaKey) { const k = e.key.toLowerCase(); let targetTool = null; let shapeType = null; switch (k) { case 'p': targetTool = 'color-picker'; break; case 'b': targetTool = 'brush'; break; case 'e': targetTool = 'eraser'; break; case 'v': targetTool = 'magic-wand'; break; case 'r': targetTool = 'shape-erase'; shapeType = e.shiftKey ? 'square' : 'rectangle'; break; case 'o': targetTool = 'polygonal-lasso'; break; case 'k': targetTool = 'polygonal-lasso-keep'; break; case 'i': targetTool = 'polygonal-lasso-invert'; break; case 's': targetTool = e.shiftKey ? 'interpolating-spline-lasso-erase' : 'spline-lasso-erase'; break; case 'l': targetTool = e.shiftKey ? 'eraser-line' : 'line'; break; case 'c': if (e.shiftKey) { targetTool = 'shape-erase'; shapeType = 'circle'; } else { targetTool = 'continuous-keep-line'; } break; case 'w': targetTool = 'continuous-keep-line'; break; case 'x': case 'q': targetTool = 'continuous-eraser-line'; break; } if (targetTool === 'shape-erase' && shapeType) { e.preventDefault(); setActiveShapeTool(shapeType); } else if (targetTool) { e.preventDefault(); setActiveTool(targetTool); } } const isAnyPolygonalLasso = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert'].includes(currentTool); const isQuadraticSplineLasso = currentTool === 'spline-lasso-erase'; const isInterpolatingSplineLasso = currentTool === 'interpolating-spline-lasso-erase'; if (isAnyPolygonalLasso && isDrawingPolygon && e.key === 'Enter' && !e.repeat) { e.preventDefault(); console.log(`Finalizando lazo poligonal ${currentTool} con Enter.`); finalizePolygon(polygonPoints.length >= 3); } else if (isQuadraticSplineLasso && isDrawingQuadraticSpline && e.key === 'Enter' && !e.repeat) { e.preventDefault(); console.log(`Finalizando lazo spline cuadrático ${currentTool} con Enter.`); finalizeQuadraticSplineLasso(splinePoints.length >= 3); } else if (isInterpolatingSplineLasso && isDrawingInterpolatingSpline && e.key === 'Enter' && !e.repeat) { e.preventDefault(); console.log(`Finalizando lazo spline interpolante ${currentTool} con Enter.`); finalizeInterpolatingSplineLasso(splinePoints.length >= 3); } }
        function handleKeyUp(e) { if (isComparePopupOpen && e.key !== ' ') return; if (e.key === ' ') { isSpacePressed = false; if (!isPanning) { canvasOuterContainer.style.cursor = getToolCursor(); if (wasDrawingShapeBeforePan) { restoreDrawingPreview(wasDrawingShapeBeforePan); } } wasDrawingShapeBeforePan = null; e.preventDefault(); } }
        function handleWheelZoom(e) { const isAnyShapeDrawing = isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape; const isBlockingAction = isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand || isDrawing || isDrawingLine || isDrawingContinuousLine || waitingForInnerHoleClick || isColorPickingActive; if (isComparePopupOpen || !originalImage || (isBlockingAction && !isAnyShapeDrawing) ) { console.log("Zoom bloqueado:", {isComparePopupOpen, originalImage: !!originalImage, isBlockingAction, isAnyShapeDrawing}); return; } e.preventDefault(); const { screenX: sx, screenY: sy } = getInteractionPos(e); const zf = e.deltaY < 0 ? 1.1 : 1 / 1.1; zoomInOut(zf, sx, sy); }
        function zoomInOut(f, px, py) { if (!originalImage) return; const cz = zoomLevel; const nz = Math.max(0.1, Math.min(cz * f, 15)); if (nz === cz) return; const dx = (px - panX) * (nz / cz - 1); const dy = (py - panY) * (nz / cz - 1); zoomLevel = nz; panX -= dx; panY -= dy; updateTransform(); updateStatusBar(); clearPreviewCanvas(); if (isDrawingPolygon) drawPolygonPreview(); else if (isDrawingQuadraticSpline) drawQuadraticSplineLassoPreview(); else if (isDrawingInterpolatingSpline) drawInterpolatingSplineLassoPreview(); else if (isDrawingShape) drawShapePreview(); else if (!isColorPickingActive && !waitingForInnerHoleClick) { drawToolPreview(currentMousePos.x, currentMousePos.y); } }


        // --- Tool Management ---
        function setActiveShapeTool(shapeType) { if (isComparePopupOpen) return; if (currentTool !== 'shape-erase' || isDrawingShape) { cancelCurrentAction(true); } currentTool = 'shape-erase'; currentShapeType = shapeType; isColorPickingActive = false; waitingForInnerHoleClick = false; console.log(`Herramienta activa: shape-erase, Forma: ${shapeType}`); const allToolButtons = [ colorPickerBtn, brushBtn, eraserBtn, magicWandBtn, rectangleEraseBtn, shapeEraseSquareBtn, shapeEraseCircleBtn, shapeEraseOvalBtn, shapeEraseTriangleBtn, shapeErasePentagonBtn, shapeEraseHexagonBtn, shapeEraseHeptagonBtn, shapeEraseOctagonBtn, shapeEraseDiamondBtn, shapeEraseTrapezoidBtn, shapeEraseParallelogramBtn, shapeEraseStarBtn, shapeEraseHeartBtn, shapeEraseCrossBtn, polygonalLassoBtn, polygonalLassoKeepBtn, polygonalLassoInvertBtn, splineLassoEraseBtn, interpolatingSplineLassoEraseBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn, removeInnerHoleBtn ]; allToolButtons.forEach(b => b?.classList.remove('active-tool', 'active-color-picker', 'active-hole-remover')); let activeBtnId = `shape-erase-${shapeType}-tool`; if (shapeType === 'rectangle') activeBtnId = 'rectangle-erase-tool'; const activeBtn = document.getElementById(activeBtnId); activeBtn?.classList.add('active-tool'); const showFeather = true; const showBrushSizeOpacityShape = false; if(brushOptionsSection) brushOptionsSection.style.display = 'block'; if(brushSizeSlider?.parentElement) brushSizeSlider.parentElement.style.display = showBrushSizeOpacityShape ? 'block' : 'none'; if(featherOptionDiv) featherOptionDiv.style.display = showFeather ? 'block' : 'none'; if(shapeOptionDiv) shapeOptionDiv.style.display = showBrushSizeOpacityShape ? 'block' : 'none'; if(brushOpacitySlider?.parentElement) brushOpacitySlider.parentElement.style.display = showBrushSizeOpacityShape ? 'block' : 'none'; if(selectedColorsSection) selectedColorsSection.style.display = 'none'; canvasOuterContainer.style.cursor = getToolCursor(); updateStatusBar(); updateToolOptionsDisplay(); updateActionButtonsState(); clearPreviewCanvas(); if (!isDrawingShape) { drawToolPreview(currentMousePos.x, currentMousePos.y); } }
        function setActiveTool(tool) { if (isComparePopupOpen) return; if (tool === 'shape-erase') { console.log("setActiveTool ignorado para shape-erase, usar setActiveShapeTool."); return; } const isCurrentToolShape = currentTool === 'shape-erase'; const isAnyLassoDrawing = isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline; const drawingInterrupted = (isAnyLassoDrawing && !tool.includes('lasso')) || (isDrawingShape && tool !== 'shape-erase') || (isDrawing && !['brush', 'eraser'].includes(tool)) || (isDrawingLine && !tool.includes('line')) || (isDrawingContinuousLine && !tool.includes('continuous')); if (currentTool !== tool || drawingInterrupted) { cancelCurrentAction(true); } currentTool = tool; currentShapeType = null; isColorPickingActive = (tool === 'color-picker'); waitingForInnerHoleClick = false; console.log("Herramienta activa:", tool); const allToolButtons = [ colorPickerBtn, brushBtn, eraserBtn, magicWandBtn, rectangleEraseBtn, shapeEraseSquareBtn, shapeEraseCircleBtn, shapeEraseOvalBtn, shapeEraseTriangleBtn, shapeErasePentagonBtn, shapeEraseHexagonBtn, shapeEraseHeptagonBtn, shapeEraseOctagonBtn, shapeEraseDiamondBtn, shapeEraseTrapezoidBtn, shapeEraseParallelogramBtn, shapeEraseStarBtn, shapeEraseHeartBtn, shapeEraseCrossBtn, polygonalLassoBtn, polygonalLassoKeepBtn, polygonalLassoInvertBtn, splineLassoEraseBtn, interpolatingSplineLassoEraseBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn, removeInnerHoleBtn ]; allToolButtons.forEach(b => b?.classList.remove('active-tool', 'active-color-picker', 'active-hole-remover')); if (isColorPickingActive) { colorPickerBtn?.classList.add('active-color-picker'); } else { const activeBtn = document.getElementById(`${tool}-tool`); activeBtn?.classList.add('active-tool'); } const isBrushOrEraser = tool === 'brush' || tool === 'eraser'; const isAnyLineBasedTool = ['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line'].includes(tool); const isAnyLasso = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert', 'spline-lasso-erase', 'interpolating-spline-lasso-erase'].includes(tool); const showBrushOptionsPanel = isBrushOrEraser || isAnyLineBasedTool || isAnyLasso; const showFeather = isBrushOrEraser || tool === 'color-picker' || tool === 'apply-color' || isAnyLasso; const showSize = isBrushOrEraser || isAnyLineBasedTool; const showOpacity = isBrushOrEraser || isAnyLineBasedTool; const showShape = isBrushOrEraser; if(brushOptionsSection) brushOptionsSection.style.display = showBrushOptionsPanel ? 'block' : 'none'; if(brushSizeSlider?.parentElement) brushSizeSlider.parentElement.style.display = showSize ? 'block' : 'none'; if(featherOptionDiv) featherOptionDiv.style.display = showFeather ? 'block' : 'none'; if(shapeOptionDiv) shapeOptionDiv.style.display = showShape ? 'block' : 'none'; if(brushOpacitySlider?.parentElement) brushOpacitySlider.parentElement.style.display = showOpacity ? 'block' : 'none'; if(selectedColorsSection) selectedColorsSection.style.display = (isColorPickingActive && originalImage) ? 'block' : 'none'; canvasOuterContainer.style.cursor = getToolCursor(); updateStatusBar(); updateToolOptionsDisplay(); updateActionButtonsState(); clearPreviewCanvas(); if (!isColorPickingActive && !waitingForInnerHoleClick) { drawToolPreview(currentMousePos.x, currentMousePos.y); } }
        function getToolCursor() { if (isColorPickingActive) return 'crosshair'; if (waitingForInnerHoleClick) return 'crosshair'; if (isComparePopupOpen) return 'default'; if (isSpacePressed && !isPanning) return 'grab'; if (isPanning) return 'grabbing'; if (currentTool === 'brush' || currentTool === 'eraser') return 'none'; const isAnyShapeTool = currentTool === 'shape-erase'; const isAnyLassoTool = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert', 'spline-lasso-erase', 'interpolating-spline-lasso-erase'].includes(currentTool); if (['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line', 'magic-wand'].includes(currentTool) || isAnyLassoTool || isAnyShapeTool ) return 'crosshair'; return 'default'; }
        function updateToolOptionsDisplay() {
            if (brushSizeValue) brushSizeValue.textContent = brushOptions.size;
            if (brushFeatherValue) brushFeatherValue.textContent = brushOptions.feather.toFixed(2);
            if (brushOpacityValue) brushOpacityValue.textContent = brushOptions.opacity.toFixed(2);
            // Actualizar botones de forma de PINCEL
            const brushShapeButtons = [shapeCircleBtn, shapeSquareBtn, shapeDiamondBtn, shapeHLineBtn, shapeVLineBtn];
            brushShapeButtons.forEach(btn => {
                if (btn) {
                    const shapeValue = btn.id.replace('brush-shape-', '').replace('-tool', ''); // Extraer valor ('circle', 'square', etc.)
                    btn.classList.toggle('active-shape', brushOptions.shape === shapeValue);
                }
            });
        } // Fin updateToolOptionsDisplay
        function updateTransform() { if (canvasInnerContainer) canvasInnerContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
        function updateStatusBar() { if (zoomLevelSpan) zoomLevelSpan.textContent = Math.round(zoomLevel * 100); if (!currentToolSpan) return; let tn = 'Ninguna'; if (waitingForInnerHoleClick) tn = 'Eliminar Hueco (Clic)'; else if (isColorPickingActive) tn = 'Seleccionar Color (P)'; else if (isComparePopupOpen) tn = 'Comparando'; else if (!originalImage) tn = 'Ninguna (Carga imagen)'; else { switch (currentTool) { case 'brush': tn = 'Pincel (B)'; break; case 'eraser': tn = 'Borrador (E)'; break; case 'magic-wand': tn = 'Varita Mágica (V)'; break; case 'shape-erase': const shapeNameMap = { rectangle: 'Rectángulo', square: 'Cuadrado', circle: 'Círculo', oval: 'Óvalo', triangle: 'Triángulo', pentagon: 'Pentágono', hexagon: 'Hexágono', heptagon: 'Heptágono', octagon: 'Octágono', diamond: 'Rombo', trapezoid: 'Trapecio', parallelogram: 'Paralelogramo', star: 'Estrella', heart: 'Corazón', cross: 'Cruz' }; const shapeShortcutMap = { rectangle: 'R', square: 'Shift+R', circle: 'Shift+C'}; const shapeName = shapeNameMap[currentShapeType] || 'Forma'; const shortcut = shapeShortcutMap[currentShapeType] ? ` (${shapeShortcutMap[currentShapeType]})` : ''; tn = `${shapeName} (Borrar)${shortcut}`; break; case 'polygonal-lasso': tn = 'Lazo Polig. (Borrar) (O)'; break; case 'polygonal-lasso-keep': tn = 'Lazo Polig. (Conservar) (K)'; break; case 'polygonal-lasso-invert': tn = 'Lazo Polig. (Invertir) (I)'; break; case 'spline-lasso-erase': tn = 'Lazo Curvo Quad (Borrar) (S)'; break; case 'interpolating-spline-lasso-erase': tn = 'Lazo Curvo Interp (Borrar) (Shift+S)'; break; case 'line': tn = 'Línea Conservar (L)'; break; case 'eraser-line': tn = 'Línea Borrar (Shift+L)'; break; case 'continuous-keep-line': tn = 'Trazo Conservar (C/W)'; break; case 'continuous-eraser-line': tn = 'Trazo Borrar (X/Q)'; break; default: tn = 'Desconocido'; } if (isDrawingLine) tn += ' (Dibujando...)'; else if (isDrawingContinuousLine) tn += ' (Trazando...)'; else if (isDrawingShape) tn += ' (Dibujando forma...)'; else if (isDrawingPolygon) tn += ' (Dibujando lazo polig...)'; else if (isDrawingQuadraticSpline) tn += ' (Dibujando lazo quad...)'; else if (isDrawingInterpolatingSpline) tn += ' (Dibujando lazo interp...)'; else if (isDrawing) tn += ' (Pintando...)'; else if (isPanning) tn += ' (Moviendo...)'; else if (isProcessingMagicWand) tn += ' (Procesando Varita...)'; else if (isFloodFilling) tn += ' (Procesando Auto/Hueco...)'; else if (isProcessingColorRemoval) tn += ' (Procesando Color...)'; } currentToolSpan.textContent = tn; }
        function updateActionButtonsState() {
             const imageLoaded = !!originalImage && !!ctx && !!maskCtx; const canUndo = history.length > 1; const canRedo = redoHistory.length > 0; const idle = isGenerallyIdle(); const isAnyShapeDrawing = isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape || isDrawing || isDrawingLine || isDrawingContinuousLine; const isShapeToolActive = currentTool === 'shape-erase'; const isAnyLassoToolActive = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert', 'spline-lasso-erase', 'interpolating-spline-lasso-erase'].includes(currentTool); const isBrushEraserActive = ['brush', 'eraser'].includes(currentTool);
             if (isComparePopupOpen) { /* deshabilita todo */ return; }
             undoBtn.disabled = !(imageLoaded && canUndo && idle); redoBtn.disabled = !(imageLoaded && canRedo && idle); undoCountSpan.textContent = Math.max(0, history.length - 1); redoCountSpan.textContent = redoHistory.length; resetBtn.disabled = !(imageLoaded && canUndo && idle); invertMaskBtn.disabled = !(imageLoaded && canUndo && idle); exportBtn.disabled = !(imageLoaded && idle); copyBtn.disabled = !(imageLoaded && isClipboardWriteSupported && idle); pasteBtn.disabled = !(isClipboardReadSupported && idle); if (compareBtn) compareBtn.disabled = !(imageLoaded && idle);
             const manualDrawingTools = [ brushBtn, eraserBtn, magicWandBtn, rectangleEraseBtn, shapeEraseSquareBtn, shapeEraseCircleBtn, shapeEraseOvalBtn, shapeEraseTriangleBtn, shapeErasePentagonBtn, shapeEraseHexagonBtn, shapeEraseHeptagonBtn, shapeEraseOctagonBtn, shapeEraseDiamondBtn, shapeEraseTrapezoidBtn, shapeEraseParallelogramBtn, shapeEraseStarBtn, shapeEraseHeartBtn, shapeEraseCrossBtn, polygonalLassoBtn, polygonalLassoKeepBtn, polygonalLassoInvertBtn, splineLassoEraseBtn, interpolatingSplineLassoEraseBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn ];
             manualDrawingTools.forEach(btn => { if (btn) { btn.disabled = !(imageLoaded && (idle || isAnyShapeDrawing)); } });
             if (colorPickerBtn) colorPickerBtn.disabled = !(imageLoaded && (idle || isColorPickingActive));
             if (removeInnerHoleBtn) { removeInnerHoleBtn.disabled = !(imageLoaded && (idle || waitingForInnerHoleClick) && !isFloodFilling && !isProcessingColorRemoval && !isProcessingMagicWand); removeInnerHoleBtn.classList.toggle('active-hole-remover', waitingForInnerHoleClick && !removeInnerHoleBtn.disabled); }
             removeEdgeBgBtn.disabled = !(imageLoaded && idle && !isFloodFilling); applyColorRemovalBtn.disabled = !(imageLoaded && selectedBackgroundColors.length > 0 && idle && !isProcessingColorRemoval && !isProcessingMagicWand);
             const toolNeedsBrushOptions = ['brush', 'eraser'].includes(currentTool); const toolNeedsLineOptions = ['line', 'eraser-line', 'continuous-keep-line', 'continuous-eraser-line'].includes(currentTool); const toolNeedsFeather = toolNeedsBrushOptions || ['color-picker', 'apply-color'].includes(currentTool) || isAnyLassoToolActive || isShapeToolActive;
             if (brushSizeSlider) brushSizeSlider.disabled = !(imageLoaded && (idle || isAnyShapeDrawing) && (toolNeedsBrushOptions || toolNeedsLineOptions));
             if (brushFeatherSlider) brushFeatherSlider.disabled = !(imageLoaded && (idle || isAnyShapeDrawing) && toolNeedsFeather);
             if (brushOpacitySlider) brushOpacitySlider.disabled = !(imageLoaded && (idle || isAnyShapeDrawing) && (toolNeedsBrushOptions || toolNeedsLineOptions));
             // Habilitar/deshabilitar botones de forma de PINCEL
             const brushShapeButtons = [shapeCircleBtn, shapeSquareBtn, shapeDiamondBtn, shapeHLineBtn, shapeVLineBtn];
             brushShapeButtons.forEach(btn => { if (btn) btn.disabled = !(imageLoaded && (idle || isAnyShapeDrawing) && isBrushEraserActive); });
             if (edgeColorToleranceSlider) { const condition = imageLoaded && ( ( (idle || isAnyShapeDrawing) && ['magic-wand', 'remove-inner-hole', 'apply-color', 'remove-edge-bg'].includes(currentTool) ) || isColorPickingActive || waitingForInnerHoleClick ); edgeColorToleranceSlider.disabled = !condition; }
             if (previewBgToggleBtn) previewBgToggleBtn.disabled = !imageLoaded; if (previewBgBlackBtn) previewBgBlackBtn.disabled = !imageLoaded; if (previewBgColorInput) previewBgColorInput.disabled = !imageLoaded; if (previewPerimeterToggleBtn) previewPerimeterToggleBtn.disabled = !imageLoaded;
             // Asegurar botón activo visualmente
             let activeBtn = null; const allToolButtons = [ colorPickerBtn, brushBtn, eraserBtn, magicWandBtn, rectangleEraseBtn, shapeEraseSquareBtn, shapeEraseCircleBtn, shapeEraseOvalBtn, shapeEraseTriangleBtn, shapeErasePentagonBtn, shapeEraseHexagonBtn, shapeEraseHeptagonBtn, shapeEraseOctagonBtn, shapeEraseDiamondBtn, shapeEraseTrapezoidBtn, shapeEraseParallelogramBtn, shapeEraseStarBtn, shapeEraseHeartBtn, shapeEraseCrossBtn, polygonalLassoBtn, polygonalLassoKeepBtn, polygonalLassoInvertBtn, splineLassoEraseBtn, interpolatingSplineLassoEraseBtn, lineBtn, eraserLineBtn, continuousKeepLineBtn, continuousEraserLineBtn, removeInnerHoleBtn ];
             allToolButtons.forEach(b => b?.classList.remove('active-tool', 'active-color-picker', 'active-hole-remover'));
             if (isColorPickingActive) { colorPickerBtn?.classList.add('active-color-picker'); } else if (waitingForInnerHoleClick) { removeInnerHoleBtn?.classList.add('active-hole-remover'); } else if (currentTool === 'shape-erase') { let activeBtnId = `shape-erase-${currentShapeType}-tool`; if (currentShapeType === 'rectangle') activeBtnId = 'rectangle-erase-tool'; activeBtn = document.getElementById(activeBtnId); activeBtn?.classList.add('active-tool'); } else { activeBtn = document.getElementById(`${currentTool}-tool`); activeBtn?.classList.add('active-tool'); }
             updatePreviewBackgroundVisualState();
        } // Fin updateActionButtonsState
        function updatePreviewBackgroundVisualState() { if (!previewBgToggleBtn || !previewBgBlackBtn || !previewBgColorInput || !previewPerimeterToggleBtn) return; previewBgToggleBtn.classList.toggle('active-bg-option', previewMode === 'checkerboard'); previewBgBlackBtn.classList.toggle('active-bg-option', previewMode === 'solid' && previewBackgroundColor === '#000000'); previewBgColorInput.classList.toggle('active-bg-option', previewMode === 'solid' && previewBackgroundColor !== '#000000'); previewPerimeterToggleBtn.classList.toggle('active-bg-option', showPerimeter); }

        // --- Utility Functions ---
        function showButtonFeedback(button, status, message = null, duration = 1500) { if (!button) return; const isHoleRemoverButton = button.id === 'remove-inner-hole-btn'; const isColorPickerButton = button.id === 'color-picker-tool'; const isWorkingOrCancelling = status === 'working' || status === 'cancelling'; if (!button.dataset.originalHtml) button.dataset.originalHtml = button.innerHTML; if (!button.dataset.originalTitle) button.dataset.originalTitle = button.title; if (button.feedbackTimeout) clearTimeout(button.feedbackTimeout); button.feedbackTimeout = null; button.classList.remove('success', 'error', 'working', 'cancelling', 'active-hole-remover', 'active-color-picker'); if (status) button.classList.add(status); if (isHoleRemoverButton && waitingForInnerHoleClick) button.classList.add('active-hole-remover'); if (isColorPickerButton && isColorPickingActive) button.classList.add('active-color-picker'); let finalMessage = message; let finalTitle = button.dataset.originalTitle || button.title; if (isHoleRemoverButton && waitingForInnerHoleClick) { finalMessage = '<i class="fas fa-hand-pointer mr-1"></i> Clic Hueco'; finalTitle = "Haz clic en un área interna..."; } else if (isColorPickerButton && isColorPickingActive) { finalMessage = '<i class="fas fa-eye-dropper"></i> Seleccionar'; finalTitle = "Haz clic para seleccionar color (P)"; } else if (!message && (status === 'success' || status === 'error')) { finalMessage = button.dataset.originalHtml || button.innerHTML; } if (finalMessage && button.innerHTML !== finalMessage) { if (finalMessage.startsWith('<i class="')) button.innerHTML = finalMessage; else button.textContent = finalMessage; } button.title = finalTitle; button.disabled = isWorkingOrCancelling; const shouldRevert = (status === 'success' || status === 'error'); if (shouldRevert) { button.feedbackTimeout = setTimeout(() => { button.classList.remove(status); if (!(isHoleRemoverButton && waitingForInnerHoleClick) && !(isColorPickerButton && isColorPickingActive)) { if (button.dataset.originalHtml) button.innerHTML = button.dataset.originalHtml; if (button.dataset.originalTitle) button.title = button.dataset.originalTitle; } updateActionButtonsState(); }, duration); } else if (!isWorkingOrCancelling) { updateActionButtonsState(); } }
        function updatePreviewBackground() { if (!canvasOuterContainer || !previewBgIcon || !previewBgToggleBtn || !previewBgBlackBtn || !previewBgColorInput || !previewPerimeterToggleBtn) return; if (previewMode === 'solid') { canvasOuterContainer.classList.remove('checkerboard-bg'); canvasOuterContainer.classList.add('solid-bg'); canvasOuterContainer.style.backgroundColor = previewBackgroundColor; } else { canvasOuterContainer.classList.add('checkerboard-bg'); canvasOuterContainer.classList.remove('solid-bg'); canvasOuterContainer.style.backgroundColor = ''; } updatePreviewBackgroundVisualState(); }
        function checkClipboardSupport() { if (!isClipboardReadSupported) { if (pasteSupportWarning) pasteSupportWarning.classList.remove('hidden'); if (pasteBtn) { pasteBtn.disabled = true; pasteBtn.title = "Pegar no soportado."; } console.warn("Clipboard read no soportado."); } else { if (pasteSupportWarning) pasteSupportWarning.classList.add('hidden'); } if (!isClipboardWriteSupported) { if (clipboardSupportWarning) clipboardSupportWarning.classList.remove('hidden'); if (copyBtn) { copyBtn.disabled = true; copyBtn.title = "Copiar no soportado."; } console.warn("Clipboard write no soportado."); } else { if (clipboardSupportWarning) clipboardSupportWarning.classList.add('hidden'); } updateActionButtonsState(); }
        function saveStateToHistory() { if (!maskCtx || !maskCanvas) return; try { if (redoHistory.length > 0) { console.log("Nueva acción, limpiando historial Redo."); redoHistory = []; } const currentState = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height); history.push(currentState); if (history.length > MAX_HISTORY + 1) { history.shift(); } console.log("Historial:", history.length - 1, "Redo:", redoHistory.length); updateActionButtonsState(); } catch (e) { console.error("Error guardando estado en el historial:", e); } }
        function undo() { if (isComparePopupOpen || history.length <= 1 || !isGenerallyIdle()) return; console.log("Deshaciendo..."); try { const currentState = history.pop(); redoHistory.push(currentState); const previousState = history[history.length - 1]; if (previousState) { maskCtx.putImageData(previousState, 0, 0); requestRender(); } console.log("Historial:", history.length - 1, "Redo:", redoHistory.length); } catch (e) { console.error("Error al deshacer:", e); } finally { updateActionButtonsState(); clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); } }
        function redo() { if (isComparePopupOpen || redoHistory.length === 0 || !isGenerallyIdle()) return; console.log("Rehaciendo..."); try { const nextState = redoHistory.pop(); history.push(nextState); if (history.length > MAX_HISTORY + 1) { history.shift(); } maskCtx.putImageData(nextState, 0, 0); requestRender(); console.log("Historial:", history.length - 1, "Redo:", redoHistory.length); } catch (e) { console.error("Error al rehacer:", e); } finally { updateActionButtonsState(); clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); } }
        function showProcessingOverlay(m) { if (processingStatusText) processingStatusText.textContent = m || "Procesando..."; if (processingOverlay) processingOverlay.classList.remove('hidden'); }
        function hideProcessingOverlay() { if (processingOverlay) processingOverlay.classList.add('hidden'); }
        function drawCheckerboard(tCtx, w, h, s = 10) { tCtx.save(); tCtx.fillStyle = '#fff'; tCtx.fillRect(0, 0, w, h); tCtx.fillStyle = '#ccc'; for (let i = 0; i < w; i += s) { for (let j = 0; j < h; j += s) { if ((Math.floor(i / s) + Math.floor(j / s)) % 2 === 0) tCtx.fillRect(i, j, s, s); } } tCtx.restore(); }
        function colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2, dg = g1 - g2, db = b1 - b2; return dr * dr + dg * dg + db * db; }

        // --- Image Generation & Export/Copy/Paste ---
        async function createFinalImageBlob(f = 'image/png') { if (!originalImage || !maskCanvas) return null; console.log("Creando Blob final..."); const fc = document.createElement('canvas'); fc.width = originalImage.naturalWidth; fc.height = originalImage.naturalHeight; const fctx = fc.getContext('2d'); if (!fctx) { console.error("No ctx final."); return null; } fctx.clearRect(0, 0, fc.width, fc.height); fctx.drawImage(originalImage, 0, 0); fctx.globalCompositeOperation = 'destination-in'; fctx.drawImage(maskCanvas, 0, 0); fctx.globalCompositeOperation = 'source-over'; return new Promise(r => fc.toBlob(r, f)); }
        async function exportImage() { if (isComparePopupOpen || !originalImage || !exportBtn || exportBtn.disabled) return; showButtonFeedback(exportBtn, 'working', 'Exportando...'); try { const b = await createFinalImageBlob(); if (!b) throw new Error("Fallo Blob."); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = `${imageFilename}_sin_fondo.png`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(u); showButtonFeedback(exportBtn, 'success', '<i class="fas fa-check"></i> Exportado'); } catch (e) { console.error("Error exportando:", e); alert(`Error exportar: ${e.message}`); showButtonFeedback(exportBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        async function copyImageToClipboard() { if (isComparePopupOpen || !originalImage || !isClipboardWriteSupported || !copyBtn || copyBtn.disabled) return; showButtonFeedback(copyBtn, 'working', 'Copiando...'); try { const b = await createFinalImageBlob('image/png'); if (!b) throw new Error("Fallo Blob."); const i = new ClipboardItem({ 'image/png': b }); await navigator.clipboard.write([i]); showButtonFeedback(copyBtn, 'success', '<i class="fas fa-check"></i> Copiado'); } catch (e) { console.error("Error copiando:", e); let m = "Error desconocido."; if (e.name === 'NotAllowedError') m = "Permiso denegado."; else if (e.message?.toLowerCase().includes("large")) m = "Imagen grande."; else if (e.name === 'SecurityError') m = "Error seguridad."; alert(`No se pudo copiar: ${m}\nDetalles: ${e.message}`); showButtonFeedback(copyBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        async function handlePasteButtonClick() { if (isComparePopupOpen || !isClipboardReadSupported || !pasteBtn || pasteBtn.disabled) return; console.log("Intentando pegar (botón)..."); showButtonFeedback(pasteBtn, 'working', 'Pegando...'); try { const p = await navigator.permissions.query({ name: 'clipboard-read' }); if (p.state === 'denied') throw new Error("Permiso denegado."); const ci = await navigator.clipboard.read(); let found = false; for (const item of ci) { const it = item.types.find(t => t.startsWith("image/")); if (it) { const b = await item.getType(it); cancelCurrentAction(true); handleFile(new File([b], "img_pegada.png", { type: it })); found = true; break; } } if (found) showButtonFeedback(pasteBtn, 'success', '<i class="fas fa-check"></i> Pegado'); else showButtonFeedback(pasteBtn, 'error', 'No imagen', 1000); } catch (e) { console.error("Error pegando:", e); let m = "Error."; if (e.name === 'NotAllowedError' || e.message?.includes("denied")) m = "Permiso denegado."; else if (e.name === 'SecurityError') m = "Error seguridad."; else if (e.message?.includes("No valid data")) m = "No imagen."; else if (e.message?.includes("activation")) m = "Requiere interacción."; alert(`No se pudo pegar: ${m}\nDetalles: ${e.message}`); showButtonFeedback(pasteBtn, 'error', '<i class="fas fa-times"></i> Error'); } }
        function handleClipboardPaste(cd) { if (isComparePopupOpen || !cd?.items) return false; console.log("Evento paste..."); let found = false; for (const i of cd.items) { if (i.kind === 'file' && i.type.startsWith('image/')) { const f = i.getAsFile(); if (f) { cancelCurrentAction(true); handleFile(f); found = true; break; } } } if (!found) console.log("No imagen 'file' en paste."); return found; }

        // --- Compare Popup Functions ---
        async function openComparePopup() { if (!originalImage || !comparePopupOverlay || !compareBeforeImg || !compareAfterImg || isComparePopupOpen) { console.warn("No abrir comparación."); return; } const slider = comparePopupOverlay.querySelector("img-comparison-slider"); if (!slider) { console.error("Slider no encontrado."); alert("Error comparación."); return; } console.log("Abriendo popup comparación..."); cancelCurrentAction(true); isComparePopupOpen = true; updateActionButtonsState(); updateStatusBar(); document.body.style.overflow = 'hidden'; canvasOuterContainer.style.cursor = 'default'; compareBeforeImg.alt = `Antes (Cargando...)`; compareAfterImg.alt = 'Después (Cargando...)'; compareBeforeImg.src = ''; compareAfterImg.src = ''; showButtonFeedback(compareBtn, 'working', 'Generando...', 60000); try { compareBeforeImg.src = originalImage.src; compareBeforeImg.alt = `Antes (${originalImage.naturalWidth}×${originalImage.naturalHeight})`; const blob = await createFinalImageBlob('image/png'); if (!blob) throw new Error("Fallo blob 'Después'"); const dataUrl = await new Promise((res, rej) => { const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = e => rej(e); r.readAsDataURL(blob); }); compareAfterImg.src = dataUrl; compareAfterImg.alt = `Después (${originalImage.naturalWidth}×${originalImage.naturalHeight})`; console.log("   Imagen 'Después' cargada."); slider.value = 50; comparePopupOverlay.classList.remove('hidden'); showButtonFeedback(compareBtn, null); } catch (err) { console.error("Error generando imágenes popup:", err); alert(`Error generar comparación: ${err.message}`); showButtonFeedback(compareBtn, 'error', 'Error', 2000); closeComparePopup(true); } }
        function closeComparePopup(forceClose = false) { if (!isComparePopupOpen && !forceClose) return; console.log("Cerrando popup comparación..."); isComparePopupOpen = false; if (comparePopupOverlay) comparePopupOverlay.classList.add('hidden'); document.body.style.overflow = ''; if (compareBeforeImg) compareBeforeImg.src = ''; if (compareAfterImg) compareAfterImg.src = ''; updateActionButtonsState(); updateStatusBar(); canvasOuterContainer.style.cursor = getToolCursor(); if (!forceClose && compareBtn) { compareBtn.classList.remove('success', 'error', 'working', 'cancelling'); if (compareBtn.dataset.originalHtml) compareBtn.innerHTML = compareBtn.dataset.originalHtml; if (compareBtn.dataset.originalTitle) compareBtn.title = compareBtn.dataset.originalTitle; updateActionButtonsState(); } }

        // --- Flood Fill Logic ---
        async function handleRemoveBackgroundByFloodFill() { if (isComparePopupOpen) return; console.log(`%c>>> FloodFill Bordes`, 'color:blue;font-weight:bold'); if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || !isGenerallyIdle()) { console.warn("FloodFill abortado: Estado inválido"); if (!isFloodFilling) showButtonFeedback(removeEdgeBgBtn, 'error', 'Ocupado', 1000); return; } isFloodFilling = true; cancelFloodFillRequest = false; updateActionButtonsState(); showButtonFeedback(removeEdgeBgBtn, 'working', 'Analizando...'); showProcessingOverlay('Analizando bordes...'); await new Promise(r => setTimeout(r, 50)); try { if (cancelFloodFillRequest) throw new Error("CancelledBeforeStart"); processingStatusText.textContent = "Procesando fondo..."; const t = parseInt(edgeColorToleranceSlider.value, 10), tsq = t * t * 3; const oD = originalImageDataCache, miD = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height), w = miD.width, h = miD.height, v = Array(h).fill(null).map(() => Array(w).fill(false)); console.log(` FloodFill Bordes. Tol:${t}, DistSq:${tsq.toFixed(0)}`); const st = performance.now(); let canc = false; for (let x = 0; x < w; x++) { if (cancelFloodFillRequest) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, x, 0, tsq, v)) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, x, h - 1, tsq, v)) { canc = true; break; } } if (!canc) { for (let y = 1; y < h - 1; y++) { if (cancelFloodFillRequest) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, 0, y, tsq, v)) { canc = true; break; } if (await floodFillMaskAsync(oD, miD, w - 1, y, tsq, v)) { canc = true; break; } } } const et = performance.now(); console.log(` FloodFill terminado ${((et - st) / 1000).toFixed(2)}s. Cancelado:${canc || cancelFloodFillRequest}`); if (cancelFloodFillRequest || canc) throw new Error("Cancelled"); maskCtx.putImageData(miD, 0, 0); saveStateToHistory(); renderCanvas(); console.log("<<< FloodFill Completado."); showButtonFeedback(removeEdgeBgBtn, 'success', '<i class="fas fa-check"></i> Hecho'); } catch (e) { if (e.message === "Cancelled" || e.message === "CancelledBeforeStart") { console.log("%cFloodFill CANCELADO.", 'color:orange;'); showButtonFeedback(removeEdgeBgBtn, 'error', 'Cancelado', 1500); } else { console.error("Error FloodFill:", e); alert(`Error proceso:${e.message}`); showButtonFeedback(removeEdgeBgBtn, 'error', 'Error', 1500); } } finally { console.log(" Finally FloodFill: Limpiando."); isFloodFilling = false; cancelFloodFillRequest = false; hideProcessingOverlay(); if (removeEdgeBgBtn && !removeEdgeBgBtn.classList.contains('success') && !removeEdgeBgBtn.classList.contains('error')) { if (removeEdgeBgBtn.dataset.originalHtml) removeEdgeBgBtn.innerHTML = removeEdgeBgBtn.dataset.originalHtml; if (removeEdgeBgBtn.dataset.originalTitle) removeEdgeBgBtn.title = removeEdgeBgBtn.dataset.originalTitle; } updateActionButtonsState(); } } // Fin handleRemoveBackgroundByFloodFill
        async function floodFillMaskAsync(oD, mD, sx, sy, tsq, v) { const w = oD.width, h = oD.height, oP = oD.data, mP = mD.data, cInt = 5000; if (sx < 0 || sx >= w || sy < 0 || sy >= h || v[sy][sx]) return false; const sIdx = (sy * w + sx) * 4; if (mP[sIdx + 3] < 128 || oP[sIdx + 3] < 128) { v[sy][sx] = true; return false; } const sR = oP[sIdx], sG = oP[sIdx + 1], sB = oP[sIdx + 2]; const q = [[sx, sy]]; v[sy][sx] = true; mP[sIdx + 3] = 0; let pp = 0; while (q.length > 0) { pp++; if (pp % cInt === 0) { if (cancelFloodFillRequest) return true; await new Promise(r => setTimeout(r, 0)); if (cancelFloodFillRequest) return true; } const [x, y] = q.shift(); const n = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]]; for (const [nx, ny] of n) { if (nx >= 0 && nx < w && ny >= 0 && ny < h && !v[ny][nx]) { v[ny][nx] = true; const nIdx = (ny * w + nx) * 4; if (mP[nIdx + 3] >= 128 && oP[nIdx + 3] >= 128) { const nR = oP[nIdx], nG = oP[nIdx + 1], nB = oP[nIdx + 2]; if (colorDistance(sR, sG, sB, nR, nG, nB) <= tsq) { q.push([nx, ny]); mP[nIdx + 3] = 0; } } } } } return false; } // Fin floodFillMaskAsync
        function activateInnerHoleClickMode() { if (!originalImage || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine || isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape || isColorPickingActive) { console.warn("No se puede activar 'Eliminar Hueco'."); if (!isGenerallyIdle() && !waitingForInnerHoleClick) { showButtonFeedback(removeInnerHoleBtn, 'error', 'Ocupado', 1000); } return; } console.log("Activando modo 'Eliminar Hueco Interno'"); waitingForInnerHoleClick = true; showButtonFeedback(removeInnerHoleBtn, 'active-hole-remover'); updateStatusBar(); updateActionButtonsState(); clearPreviewCanvas(); canvasOuterContainer.style.cursor = 'crosshair'; }
        function removeInnerHoleAt(startX, startY) { console.log(`%c>>> removeInnerHoleAt (${startX.toFixed(0)}, ${startY.toFixed(0)})`, 'color: purple; font-weight: bold;'); if (!waitingForInnerHoleClick || !originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand) { console.warn("Eliminar Hueco abortado."); if (waitingForInnerHoleClick) { showButtonFeedback(removeInnerHoleBtn, 'error', 'Error Estado', 1500); cancelCurrentAction(true); } return; } const width = maskCanvas.width; const height = maskCanvas.height; startX = Math.floor(startX); startY = Math.floor(startY); if (startX < 0 || startX >= width || startY < 0 || startY >= height) { console.log("Clic fuera de límites."); showButtonFeedback(removeInnerHoleBtn, 'error', 'Fuera Imagen', 1000); cancelCurrentAction(true); return; } let pixelsChanged = 0; let success = false; let message = ''; let statusClass = 'error'; try { const maskImageData = maskCtx.getImageData(0, 0, width, height); const maskPixels = maskImageData.data; const originalPixels = originalImageDataCache.data; const tolerance = parseInt(edgeColorToleranceSlider.value, 10); const toleranceSq = tolerance * tolerance * 3; const startIndex = (startY * width + startX) * 4; if (maskPixels[startIndex + 3] < 128) { message = 'Ya Transparente'; statusClass = 'error'; success = false; } else { const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2]; const visited = new Uint8Array(width * height); const queue = [[startX, startY]]; visited[startY * width + startX] = 1; maskPixels[startIndex + 3] = 0; pixelsChanged = 1; let head = 0; const maxQueueSize = width * height * 1.5; while (head < queue.length && queue.length < maxQueueSize) { const [x, y] = queue[head++]; const neighbors = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]]; for (const [nx, ny] of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const nIndexLinear = ny * width + nx; if (visited[nIndexLinear] === 0) { visited[nIndexLinear] = 1; const nIndexRGBA = nIndexLinear * 4; if (maskPixels[nIndexRGBA + 3] >= 128) { const nR_orig = originalPixels[nIndexRGBA]; const nG_orig = originalPixels[nIndexRGBA + 1]; const nB_orig = originalPixels[nIndexRGBA + 2]; if (colorDistance(startR, startG, startB, nR_orig, nG_orig, nB_orig) <= toleranceSq) { queue.push([nx, ny]); maskPixels[nIndexRGBA + 3] = 0; pixelsChanged++; } } } } } } if (queue.length >= maxQueueSize) { console.warn(`Flood fill (hueco) alcanzó límite desde (${startX}, ${startY}).`); message = 'Área Muy Grande'; statusClass = 'error'; success = false; pixelsChanged = 0; } else if (pixelsChanged > 0) { maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender(); message = '<i class="fas fa-check"></i> Hueco Borrado'; statusClass = 'success'; success = true; console.log(`   Hueco eliminado, ${pixelsChanged} píxeles afectados.`); } else { message = 'No Cambios'; statusClass = 'error'; success = false; } } } catch (error) { console.error("Error eliminando hueco:", error); alert(`Error procesando hueco: ${error.message}`); message = '<i class="fas fa-times"></i> Error Interno'; statusClass = 'error'; success = false; } finally { waitingForInnerHoleClick = false; showButtonFeedback(removeInnerHoleBtn, statusClass, message, success ? 1200 : 2000); updateStatusBar(); updateActionButtonsState(); canvasOuterContainer.style.cursor = getToolCursor(); } } // Fin removeInnerHoleAt

        // --- Color Picker & Removal Logic ---
        function pickColorAt(ix, iy) { if (!originalImageDataCache || !originalImage) { console.warn("Pick color sin datos."); return; } const x = Math.floor(ix), y = Math.floor(iy), w = originalImage.naturalWidth, h = originalImage.naturalHeight; if (x < 0 || x >= w || y < 0 || y >= h) { console.log("Clic fuera para color."); showButtonFeedback(colorPickerBtn, 'error', 'Fuera', 800); return; } const idx = (y * w + x) * 4, r = originalImageDataCache.data[idx], g = originalImageDataCache.data[idx + 1], b = originalImageDataCache.data[idx + 2]; const exists = selectedBackgroundColors.some(c => c.r === r && c.g === g && c.b === b); if (!exists) { selectedBackgroundColors.push({ r, g, b }); console.log(`Color añadido: rgb(${r},${g},${b}). Total: ${selectedBackgroundColors.length}`); updateSelectedColorsUI(); updateActionButtonsState(); showButtonFeedback(colorPickerBtn, 'success', `<i class="fas fa-plus mr-1"></i>${r},${g},${b}`, 800); } else { console.log(`Color rgb(${r},${g},${b}) ya existe.`); showButtonFeedback(colorPickerBtn, 'error', 'Ya existe', 800); } }
        function removeSelectedColor(r, g, b) { selectedBackgroundColors = selectedBackgroundColors.filter(c => !(c.r === r && c.g === g && c.b === b)); console.log(`Color quitado: rgb(${r},${g},${b}). Restantes: ${selectedBackgroundColors.length}`); updateSelectedColorsUI(); updateActionButtonsState(); }
        function updateSelectedColorsUI() { if (!selectedColorsListDiv || !noColorsSelectedP || !selectedColorsSection) return; selectedColorsListDiv.innerHTML = ''; if (selectedBackgroundColors.length === 0) { if (noColorsSelectedP) { noColorsSelectedP.style.display = 'block'; } } else { if (noColorsSelectedP) noColorsSelectedP.style.display = 'none'; selectedBackgroundColors.forEach(c => { const tag = document.createElement('span'); tag.className = 'color-tag'; const dot = document.createElement('span'); dot.className = 'color-dot'; dot.style.backgroundColor = `rgb(${c.r},${c.g},${c.b})`; const txt = document.createElement('span'); txt.textContent = `${c.r},${c.g},${c.b}`; const btn = document.createElement('button'); btn.className = 'remove-color-btn'; btn.innerHTML = '×'; btn.title = 'Eliminar este color'; btn.type = 'button'; btn.dataset.r = c.r; btn.dataset.g = c.g; btn.dataset.b = c.b; tag.appendChild(dot); tag.appendChild(txt); tag.appendChild(btn); selectedColorsListDiv.appendChild(tag); }); } selectedColorsSection.style.display = (isColorPickingActive && originalImage) ? 'block' : 'none'; }
        function applyFeatherToMask(miD, w, h, f) { const r = Math.max(1, Math.round(f * 15)); if (r <= 0 || f <= 0) return miD; console.log(` Aplicando suavizado (radio ~${r}px, feather: ${f.toFixed(2)})`); const d = miD.data; const tempAlpha = new Uint8ClampedArray(w * h); const blurredAlpha = new Uint8ClampedArray(w * h); for (let i = 0; i < w * h; i++) { tempAlpha[i] = d[i * 4 + 3]; } /* Simple Box Blur */ for (let y = 0; y < h; y++) { for (let x = 0; x < w; x++) { let totalAlpha = 0; let count = 0; for (let ky = -r; ky <= r; ky++) { const ny = y + ky; if (ny < 0 || ny >= h) continue; for (let kx = -r; kx <= r; kx++) { const nx = x + kx; if (nx < 0 || nx >= w) continue; totalAlpha += tempAlpha[ny * w + nx]; count++; } } blurredAlpha[y * w + x] = count > 0 ? totalAlpha / count : tempAlpha[y * w + x]; } } for (let i = 0; i < w * h; i++) { d[i * 4 + 3] = blurredAlpha[i]; } console.log("   Suavizado aplicado."); return miD; }
        async function applyColorRemoval() { if (isComparePopupOpen) return; console.log("%c>>> Aplicando Eliminación por Color...", 'color:purple;font-weight:bold'); if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || selectedBackgroundColors.length === 0 || !isGenerallyIdle()) { console.warn("Eliminación por Color abortada."); showButtonFeedback(applyColorRemovalBtn, 'error', 'Error Estado', 1000); return; } isProcessingColorRemoval = true; updateActionButtonsState(); showButtonFeedback(applyColorRemovalBtn, 'working', 'Procesando...'); showProcessingOverlay('Eliminando colores...'); await new Promise(r => setTimeout(r, 50)); try { const tolerance = parseInt(edgeColorToleranceSlider.value, 10); const toleranceSq = tolerance * tolerance * 3; const featherAmount = parseFloat(brushFeatherSlider.value); const width = maskCanvas.width, height = maskCanvas.height; const originalPixels = originalImageDataCache.data; const maskImageData = maskCtx.getImageData(0, 0, width, height); const maskPixels = maskImageData.data; console.log(` Procesando ${width}x${height}. Colores: ${selectedBackgroundColors.length}, Tolerancia: ${tolerance}, Suavizado: ${featherAmount}`); const startTime = performance.now(); for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const idx = (y * width + x) * 4; if (originalPixels[idx + 3] < 128 || maskPixels[idx + 3] < 128) { continue; } const rO = originalPixels[idx]; const gO = originalPixels[idx + 1]; const bO = originalPixels[idx + 2]; let match = false; for (const bgColor of selectedBackgroundColors) { if (colorDistance(rO, gO, bO, bgColor.r, bgColor.g, bgColor.b) <= toleranceSq) { match = true; break; } } if (match) { maskPixels[idx + 3] = 0; } } } let finalMaskData = maskImageData; if (featherAmount > 0) { finalMaskData = applyFeatherToMask(maskImageData, width, height, featherAmount); } maskCtx.putImageData(finalMaskData, 0, 0); const endTime = performance.now(); console.log(` Eliminación por Color completada en ${((endTime - startTime) / 1000).toFixed(2)}s.`); saveStateToHistory(); requestRender(); showButtonFeedback(applyColorRemovalBtn, 'success', '<i class="fas fa-check"></i> Colores Aplicados'); } catch (e) { console.error("Error durante eliminación por color:", e); alert(`Error al aplicar colores: ${e.message}`); showButtonFeedback(applyColorRemovalBtn, 'error', 'Error Proceso', 1500); } finally { console.log(" Finally Eliminación Color: Limpiando estado."); isProcessingColorRemoval = false; hideProcessingOverlay(); if (applyColorRemovalBtn && !applyColorRemovalBtn.classList.contains('success')) { if (applyColorRemovalBtn.dataset.originalHtml) applyColorRemovalBtn.innerHTML = applyColorRemovalBtn.dataset.originalHtml; if (applyColorRemovalBtn.dataset.originalTitle) applyColorRemovalBtn.title = applyColorRemovalBtn.dataset.originalTitle; } updateActionButtonsState(); } } // Fin applyColorRemoval

        // --- Lógica Varita Mágica ---
        async function applyMagicWand(startX, startY) {
             console.log(`%c>>> Varita Mágica en (${startX.toFixed(0)}, ${startY.toFixed(0)})`, 'color: magenta; font-weight: bold;');
             if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || isFloodFilling || isProcessingColorRemoval || isProcessingMagicWand || isDrawing || isDrawingLine || isDrawingContinuousLine || isDrawingPolygon || isDrawingQuadraticSpline || isDrawingInterpolatingSpline || isDrawingShape || waitingForInnerHoleClick || isComparePopupOpen) { console.warn("Varita Mágica abortada: Estado inválido o proceso activo."); showButtonFeedback(magicWandBtn, 'error', 'Ocupado', 1000); return; }
             const width = maskCanvas.width; const height = maskCanvas.height; startX = Math.floor(startX); startY = Math.floor(startY); if (startX < 0 || startX >= width || startY < 0 || startY >= height) { showButtonFeedback(magicWandBtn, 'error', 'Fuera Imagen', 1000); return; }
             isProcessingMagicWand = true; updateActionButtonsState(); showProcessingOverlay("Analizando con Varita Mágica..."); await new Promise(resolve => setTimeout(resolve, 20));
             let pixelsChanged = 0; let success = false; let message = 'Error Desconocido'; let statusClass = 'error';
             try {
                 const maskImageData = maskCtx.getImageData(0, 0, width, height); const maskPixels = maskImageData.data; const originalPixels = originalImageDataCache.data; const tolerance = parseInt(edgeColorToleranceSlider.value, 10); const toleranceSq = tolerance * tolerance * 3; const startIndex = (startY * width + startX) * 4; const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2]; const startA = originalPixels[startIndex + 3]; if(startA < 128) { message = 'Clic en Transparente'; statusClass = 'error'; success = false; throw new Error("Clic en área transparente original"); }
                 const visited = new Uint8Array(width * height); const queue = [[startX, startY]]; const matchedPixelsCoords = []; visited[startY * width + startX] = 1; if (maskPixels[startIndex + 3] >= 128) { matchedPixelsCoords.push([startX, startY]); }
                 let head = 0; const maxQueueSize = width * height * 1.5;
                 while (head < queue.length && queue.length < maxQueueSize) {
                     const [x, y] = queue[head++]; const neighbors = [[x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]];
                     for (const [nx, ny] of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const nIndexLinear = ny * width + nx; if (visited[nIndexLinear] === 0) { visited[nIndexLinear] = 1; const nIndexRGBA = nIndexLinear * 4; const nR_orig = originalPixels[nIndexRGBA]; const nG_orig = originalPixels[nIndexRGBA + 1]; const nB_orig = originalPixels[nIndexRGBA + 2]; const nA_orig = originalPixels[nIndexRGBA + 3]; if (nA_orig >= 128 && colorDistance(startR, startG, startB, nR_orig, nG_orig, nB_orig) <= toleranceSq) { queue.push([nx, ny]); if (maskPixels[nIndexRGBA + 3] >= 128) { matchedPixelsCoords.push([nx, ny]); } } } } } }
                 if (queue.length >= maxQueueSize) { console.warn(`Varita Mágica alcanzó límite cola`); message = 'Área Muy Grande'; statusClass = 'error'; success = false; }
                 else if (matchedPixelsCoords.length > 0) { console.log(`   Varita encontró ${matchedPixelsCoords.length} píxeles opacos coincidentes para borrar.`); for (const [mx, my] of matchedPixelsCoords) { const mIndex = (my * width + mx) * 4; if (maskPixels[mIndex + 3] >= 128) { maskPixels[mIndex + 3] = 0; pixelsChanged++; } } if (pixelsChanged > 0) { maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender(); message = `<i class="fas fa-check"></i> Área Eliminada (${pixelsChanged}px)`; statusClass = 'success'; success = true; } else { message = 'No Cambios Visibles'; statusClass = 'error'; success = false; console.log("   Varita: Píxeles ya eran transparentes."); } }
                 else { message = 'Nada que borrar'; statusClass = 'error'; success = false; console.log("   Varita no encontró píxeles opacos coincidentes."); }
             } catch (error) { if(error.message !== "Clic en área transparente original") { console.error("Error Varita Mágica:", error); alert(`Error Varita: ${error.message}`); message = '<i class="fas fa-times"></i> Error Interno'; statusClass = 'error'; success = false; } }
             finally { hideProcessingOverlay(); showButtonFeedback(magicWandBtn, statusClass, message, success ? 1500 : 2500); isProcessingMagicWand = false; updateActionButtonsState(); }
        } // Fin applyMagicWand


        // --- Lógica Lazo Poligonal ---
        function drawPolygonPreview() { const isAnyPolygonalLasso = ['polygonal-lasso', 'polygonal-lasso-keep', 'polygonal-lasso-invert'].includes(currentTool); if (!previewCtx || !isDrawingPolygon || polygonPoints.length === 0 || !isAnyPolygonalLasso) { clearPreviewCanvas(); return; } clearPreviewCanvas(); previewCtx.save(); let strokeColor = 'rgba(255, 0, 0, 0.8)', fillColor = 'rgba(255, 0, 0, 0.9)'; if (currentTool === 'polygonal-lasso-keep') { strokeColor = 'rgba(0, 255, 0, 0.8)'; fillColor = 'rgba(0, 255, 0, 0.9)'; } else if (currentTool === 'polygonal-lasso-invert') { strokeColor = 'rgba(255, 0, 255, 0.8)'; fillColor = 'rgba(255, 0, 255, 0.9)'; } previewCtx.strokeStyle = strokeColor; previewCtx.fillStyle = fillColor; const scaledLineWidth = 1.5 / zoomLevel; const scaledDash = [4 / zoomLevel, 4 / zoomLevel]; previewCtx.lineWidth = scaledLineWidth; previewCtx.beginPath(); previewCtx.moveTo(polygonPoints[0][0], polygonPoints[0][1]); for (let i = 1; i < polygonPoints.length; i++) { previewCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1]); } previewCtx.stroke(); previewCtx.beginPath(); previewCtx.setLineDash(scaledDash); previewCtx.moveTo(polygonPoints[polygonPoints.length - 1][0], polygonPoints[polygonPoints.length - 1][1]); previewCtx.lineTo(currentMousePos.x, currentMousePos.y); if (polygonPoints.length > 1) { previewCtx.moveTo(currentMousePos.x, currentMousePos.y); previewCtx.lineTo(polygonPoints[0][0], polygonPoints[0][1]); } previewCtx.stroke(); previewCtx.setLineDash([]); polygonPoints.forEach(p => { previewCtx.beginPath(); previewCtx.arc(p[0], p[1], 3.5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }); previewCtx.restore(); }
        function finalizePolygon(closeLoop = true) { if (!maskCtx || !maskCanvas || !isDrawingPolygon || polygonPoints.length < 3) { console.log("Lazo Poligonal cancelado: Menos de 3 puntos."); cancelCurrentAction(true); return; } const toolUsed = currentTool; const featherAmount = parseFloat(brushFeatherSlider.value); const width = maskCanvas.width; const height = maskCanvas.height; console.log(`Finalizando polígono ${toolUsed} con ${polygonPoints.length} puntos. Cerrado: ${closeLoop}. Difuminado: ${featherAmount}`); clearPreviewCanvas(); maskCtx.save(); if (toolUsed === 'polygonal-lasso') { maskCtx.globalCompositeOperation = 'destination-out'; maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; console.log("  Aplicando Lazo Eliminar Interior (destination-out)"); maskCtx.beginPath(); maskCtx.moveTo(polygonPoints[0][0], polygonPoints[0][1]); for (let i = 1; i < polygonPoints.length; i++) { maskCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1]); } if (closeLoop) { maskCtx.closePath(); } maskCtx.fill(); } else if (toolUsed === 'polygonal-lasso-keep') { maskCtx.globalCompositeOperation = 'source-over'; maskCtx.fillStyle = 'rgba(255, 255, 255, 1)'; console.log("  Aplicando Lazo Conservar Interior (source-over, white fill)"); maskCtx.beginPath(); maskCtx.moveTo(polygonPoints[0][0], polygonPoints[0][1]); for (let i = 1; i < polygonPoints.length; i++) { maskCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1]); } if (closeLoop) { maskCtx.closePath(); } maskCtx.fill(); } else if (toolUsed === 'polygonal-lasso-invert') { console.log("  Aplicando Lazo Eliminar Exterior (evenodd fill rule)"); maskCtx.globalCompositeOperation = 'destination-out'; maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; maskCtx.beginPath(); maskCtx.rect(0, 0, width, height); maskCtx.moveTo(polygonPoints[0][0], polygonPoints[0][1]); for (let i = 1; i < polygonPoints.length; i++) { maskCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1]); } maskCtx.closePath(); maskCtx.fill('evenodd'); } maskCtx.restore(); if (featherAmount > 0) { try { console.log(`  Aplicando difuminado general (valor: ${featherAmount}) a la máscara...`); let maskImageData = maskCtx.getImageData(0, 0, width, height); maskImageData = applyFeatherToMask(maskImageData, width, height, featherAmount); maskCtx.putImageData(maskImageData, 0, 0); console.log("  Difuminado aplicado post-lazo."); } catch(e) { console.error("Error aplicando difuminado post-lazo:", e); alert("Error al aplicar el difuminado al lazo.") } } isDrawingPolygon = false; polygonPoints = []; saveStateToHistory(); requestRender(); updateActionButtonsState(); updateStatusBar(); clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); }


        // --- Lógica Lazo Spline Cuadrático ---
        function drawQuadraticSplineLassoPreview() { if (!previewCtx || !isDrawingQuadraticSpline || splinePoints.length === 0) { clearPreviewCanvas(); return; } clearPreviewCanvas(); previewCtx.save(); previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.fillStyle = 'rgba(255, 0, 0, 0.9)'; const scaledLineWidth = 1.5 / zoomLevel; const scaledDash = [4 / zoomLevel, 4 / zoomLevel]; previewCtx.lineWidth = scaledLineWidth; previewCtx.beginPath(); previewCtx.moveTo(splinePoints[0][0], splinePoints[0][1]); if (splinePoints.length < 2) { previewCtx.lineTo(currentMousePos.x, currentMousePos.y); } else { let i; for (i = 1; i < splinePoints.length - 1; i++) { const xc = (splinePoints[i][0] + splinePoints[i + 1][0]) / 2; const yc = (splinePoints[i][1] + splinePoints[i + 1][1]) / 2; previewCtx.quadraticCurveTo(splinePoints[i][0], splinePoints[i][1], xc, yc); } if (splinePoints.length > 1) { previewCtx.quadraticCurveTo(splinePoints[i][0], splinePoints[i][1], splinePoints[i][0], splinePoints[i][1]); } previewCtx.stroke(); previewCtx.beginPath(); previewCtx.setLineDash(scaledDash); previewCtx.moveTo(splinePoints[splinePoints.length - 1][0], splinePoints[splinePoints.length - 1][1]); previewCtx.lineTo(currentMousePos.x, currentMousePos.y); if (splinePoints.length > 1) { previewCtx.moveTo(currentMousePos.x, currentMousePos.y); previewCtx.lineTo(splinePoints[0][0], splinePoints[0][1]); } } previewCtx.stroke(); previewCtx.setLineDash([]); splinePoints.forEach(p => { previewCtx.beginPath(); previewCtx.arc(p[0], p[1], 3.5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }); previewCtx.restore(); }
        function finalizeQuadraticSplineLasso(closeLoop = true) { if (!maskCtx || !maskCanvas || !isDrawingQuadraticSpline || splinePoints.length < 3) { console.log("Lazo Spline Cuadrático cancelado: Menos de 3 puntos."); cancelCurrentAction(true); return; } const toolUsed = currentTool; const featherAmount = parseFloat(brushFeatherSlider.value); const width = maskCanvas.width; const height = maskCanvas.height; console.log(`Finalizando lazo spline cuadrático (${toolUsed}) con ${splinePoints.length} puntos. Cerrado: ${closeLoop}. Difuminado: ${featherAmount}`); clearPreviewCanvas(); maskCtx.save(); maskCtx.globalCompositeOperation = 'destination-out'; maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; console.log("  Aplicando Lazo Spline Cuadrático Eliminar Interior (destination-out)"); maskCtx.beginPath(); maskCtx.moveTo(splinePoints[0][0], splinePoints[0][1]); if (splinePoints.length >= 2) { let i; for (i = 1; i < splinePoints.length - 1; i++) { const xc = (splinePoints[i][0] + splinePoints[i + 1][0]) / 2; const yc = (splinePoints[i][1] + splinePoints[i + 1][1]) / 2; maskCtx.quadraticCurveTo(splinePoints[i][0], splinePoints[i][1], xc, yc); } maskCtx.quadraticCurveTo(splinePoints[i][0], splinePoints[i][1], splinePoints[i][0], splinePoints[i][1]); } if (closeLoop && splinePoints.length >= 2) { const lastPoint = splinePoints[splinePoints.length - 1]; const firstPoint = splinePoints[0]; maskCtx.quadraticCurveTo(lastPoint[0], lastPoint[1], firstPoint[0], firstPoint[1]); maskCtx.closePath(); } else if (closeLoop && splinePoints.length < 2) { maskCtx.closePath();} maskCtx.fill(); maskCtx.restore(); if (featherAmount > 0) { try { console.log(`  Aplicando difuminado general (valor: ${featherAmount}) a la máscara...`); let maskImageData = maskCtx.getImageData(0, 0, width, height); maskImageData = applyFeatherToMask(maskImageData, width, height, featherAmount); maskCtx.putImageData(maskImageData, 0, 0); console.log("  Difuminado aplicado post-lazo spline cuadrático."); } catch(e) { console.error("Error aplicando difuminado post-lazo spline cuadrático:", e); alert("Error al aplicar el difuminado al lazo spline.") } } isDrawingQuadraticSpline = false; splinePoints = []; saveStateToHistory(); requestRender(); updateActionButtonsState(); updateStatusBar(); clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); }


        // --- Lógica Lazo Spline Interpolante ---
         function drawInterpolatingSplineLassoPreview() { if (!previewCtx || !isDrawingInterpolatingSpline || splinePoints.length === 0) { clearPreviewCanvas(); return; } clearPreviewCanvas(); previewCtx.save(); previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.fillStyle = 'rgba(255, 0, 0, 0.9)'; const scaledLineWidth = 1.5 / zoomLevel; const scaledDash = [4 / zoomLevel, 4 / zoomLevel]; previewCtx.lineWidth = scaledLineWidth; previewCtx.beginPath(); previewCtx.moveTo(splinePoints[0][0], splinePoints[0][1]); if (splinePoints.length > 1) { drawCatmullRomSpline(previewCtx, splinePoints, false); } else { previewCtx.lineTo(currentMousePos.x, currentMousePos.y); } previewCtx.stroke(); previewCtx.beginPath(); previewCtx.setLineDash(scaledDash); if(splinePoints.length > 0) { previewCtx.moveTo(splinePoints[splinePoints.length - 1][0], splinePoints[splinePoints.length - 1][1]); previewCtx.lineTo(currentMousePos.x, currentMousePos.y); } if (splinePoints.length > 1) { previewCtx.moveTo(currentMousePos.x, currentMousePos.y); previewCtx.lineTo(splinePoints[0][0], splinePoints[0][1]); } previewCtx.stroke(); previewCtx.setLineDash([]); splinePoints.forEach(p => { previewCtx.beginPath(); previewCtx.arc(p[0], p[1], 3.5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); }); previewCtx.restore(); }
        function finalizeInterpolatingSplineLasso(closeLoop = true) { if (!maskCtx || !maskCanvas || !isDrawingInterpolatingSpline || splinePoints.length < 3) { console.log("Lazo Spline Interpolante cancelado: Menos de 3 puntos."); cancelCurrentAction(true); return; } const toolUsed = currentTool; const featherAmount = parseFloat(brushFeatherSlider.value); const width = maskCanvas.width; const height = maskCanvas.height; console.log(`Finalizando lazo spline interpolante (${toolUsed}) con ${splinePoints.length} puntos. Cerrado: ${closeLoop}. Difuminado: ${featherAmount}`); clearPreviewCanvas(); maskCtx.save(); maskCtx.globalCompositeOperation = 'destination-out'; maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; console.log("  Aplicando Lazo Spline Interpolante Eliminar Interior (destination-out)"); maskCtx.beginPath(); maskCtx.moveTo(splinePoints[0][0], splinePoints[0][1]); drawCatmullRomSpline(maskCtx, splinePoints, closeLoop); if (closeLoop) { maskCtx.closePath(); } maskCtx.fill(); maskCtx.restore(); if (featherAmount > 0) { try { console.log(`  Aplicando difuminado general (valor: ${featherAmount}) a la máscara...`); let maskImageData = maskCtx.getImageData(0, 0, width, height); maskImageData = applyFeatherToMask(maskImageData, width, height, featherAmount); maskCtx.putImageData(maskImageData, 0, 0); console.log("  Difuminado aplicado post-lazo spline interpolante."); } catch(e) { console.error("Error aplicando difuminado post-lazo spline interpolante:", e); alert("Error al aplicar el difuminado al lazo spline interpolante.") } } isDrawingInterpolatingSpline = false; splinePoints = []; saveStateToHistory(); requestRender(); updateActionButtonsState(); updateStatusBar(); clearPreviewCanvas(); drawToolPreview(currentMousePos.x, currentMousePos.y); }
        function drawCatmullRomSpline(ctx, points, close, tension = 0.5) { if (!points || points.length < 2) return; let pts = [...points]; let len = pts.length; if (close) { pts.unshift(points[len - 1]); if(len > 1) pts.unshift(points[len - 2]); else pts.unshift(points[len - 1]); pts.push(points[0]); if (len > 1) pts.push(points[1]); else pts.push(points[0]); } else { pts.unshift(points[0]); pts.push(points[len - 1]); } ctx.moveTo(pts[1][0], pts[1][1]); const t = tension / 3.0; for (let i = 1; i < pts.length - 2; i++) { const p0 = pts[i - 1]; const p1 = pts[i]; const p2 = pts[i + 1]; const p3 = pts[i + 2]; const cp1x = p1[0] + (p2[0] - p0[0]) * t; const cp1y = p1[1] + (p2[1] - p0[1]) * t; const cp2x = p2[0] - (p3[0] - p1[0]) * t; const cp2y = p2[1] - (p3[1] - p1[1]) * t; ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2[0], p2[1]); } }

         // --- Lógica Invertir Máscara Completa ---
         function invertMask() { if (!maskCtx || !maskCanvas || !originalImage || !isGenerallyIdle()) { console.warn("Invertir máscara completa abortado: Estado inválido."); showButtonFeedback(invertMaskBtn, 'error', 'Ocupado', 1000); return; } console.log("Invirtiendo máscara completa..."); showButtonFeedback(invertMaskBtn, 'working', 'Invirtiendo...'); try { const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height); const data = maskImageData.data; for (let i = 0; i < data.length; i += 4) { data[i + 3] = 255 - data[i + 3]; } maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender(); showButtonFeedback(invertMaskBtn, 'success', 'Invertido'); } catch (e) { console.error("Error al invertir la máscara completa:", e); alert("Error al invertir la máscara completa: " + e.message); showButtonFeedback(invertMaskBtn, 'error', 'Error'); } }

        // --- Final cierre del listener DOMContentLoaded ---
    }); // Fin DOMContentLoaded Listener
</script>
</body>
</html>
