
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliminador de Fondos (API) - XocoStudio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- Estilos CSS (Optimizados) --- */
        body { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .checkerboard-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        .tool-btn.active-tool { background-color: #d1d5db; /* gray-300 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); }
        .tool-btn.active-hole-remover { background-color: #fde047 !important; /* yellow-300 */ color: #713f12 !important; /* yellow-800 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #ca8a04; /* yellow-600 */}
        .brush-shape.active-shape { border-color: #3b82f6; /* blue-500 */ border-width: 2px; }
        #canvas-outer-container { width: 100%; height: 100%; overflow: hidden; position: relative; /* Cursor se define por JS */ }
        #canvas-inner-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
        #image-canvas, #preview-canvas { display: block; position: absolute; top: 0; left: 0; max-width: none; /* width/height se definen por JS */ image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        #preview-canvas { pointer-events: none; z-index: 1;}
        #image-canvas { z-index: 0;}
        main { height: calc(100vh - 64px - 32px); }
        .fa-line-eraser::before { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 1; }
        .fa-line-eraser::after { content: ""; position: absolute; left: 15%; top: 50%; width: 70%; height: 2px; background-color: currentColor; transform: translateY(-50%) rotate(0deg); opacity: 0.6; z-index: 0; }
        .tool-btn .fa-line-eraser { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; }
        #eraser-line-tool i { font-size: 0.9em; }
        .btn-feedback { transition: background-color 0.2s ease-out, color 0.2s ease-out, border-color 0.2s ease-out; }
        .btn-feedback.success { background-color: #22c55e !important; color: white !important; border-color: #16a34a !important; }
        .btn-feedback.error { background-color: #ef4444 !important; color: white !important; border-color: #dc2626 !important; }
        .btn-feedback.working { background-color: #eab308 !important; color: white !important; border-color: #ca8a04 !important; cursor: wait; }
        .btn-feedback.cancelling { background-color: #f97316 !important; color: white !important; border-color: #ea580c !important; cursor: default; }
        .processing-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: none; }
        .processing-overlay i { margin-bottom: 10px; }
        .processing-overlay p { margin-top: 0px; font-size: 1.1rem; }
         .fa-continuous-eraser-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; }
         .fa-continuous-eraser-line::before { content: "\f55b"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; }
         .fa-continuous-eraser-line::after { content: "\f12d"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #ef4444; }
         #continuous-eraser-line-tool i { font-size: 1em; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col min-h-screen overflow-hidden">

    <header class="bg-white shadow-md p-4 flex-shrink-0 flex items-center">
        <a href="https://xocostudio.com/" target="_blank" rel="noopener noreferrer" class="mr-4 flex-shrink-0">
             <img src="https://xocostudio.com/assets/images/xocostudio-354x128.png" alt="XocoStudio Logo" class="h-8">
        </a>
        <h1 class="text-xl md:text-2xl font-bold text-gray-800">Eliminador de Fondos de Imágenes</h1>
    </header>

    <main class="flex-grow flex flex-col md:flex-row p-4 gap-4">
        <!-- Panel de Controles -->
        <aside class="w-full md:w-72 bg-white p-4 rounded-lg shadow space-y-6 flex-shrink-0 overflow-y-auto">
            <!-- Carga de Imagen -->
             <div id="upload-section">
                 <h2 class="text-lg font-semibold mb-2">1. Cargar Imagen</h2>
                 <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors">
                     <p class="text-gray-600">Arrastra y suelta</p><p class="text-sm text-gray-500 my-2">o</p>
                     <div class="flex flex-col items-center space-y-2">
                         <input type="file" id="file-input" accept="image/*" class="hidden">
                         <button id="upload-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded btn-feedback"><i class="fas fa-upload mr-1"></i> Seleccionar</button>
                         <button id="paste-btn" class="w-full bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Pegar (Ctrl+V)"><i class="fas fa-paste mr-1"></i> Pegar</button>
                     </div>
                     <p id="paste-support-warning" class="text-xs text-red-600 mt-2 hidden">Pegar no soportado.</p>
                 </div>
                 <p id="filename-display" class="text-xs text-gray-600 mt-2 truncate"></p>
             </div>
            <!-- Herramientas -->
            <div id="tools-section" class="space-y-4 hidden pt-4 border-t">
                <h2 class="text-lg font-semibold mb-2">2. Herramientas</h2>
                 <!-- Eliminación Automática -->
                 <div class="mb-4 space-y-2">
                     <button id="remove-edge-bg-btn" class="w-full bg-cyan-600 hover:bg-cyan-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Eliminar fondo (bordes)"><i class="fas fa-wand-magic-sparkles mr-1"></i> Fondo Automático</button>
                     <!-- NUEVO BOTÓN API -->
                     <button id="remove-bg-api-btn" class="w-full bg-teal-600 hover:bg-teal-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Eliminar fondo usando API externa (Requiere archivo original)">
                        <i class="fas fa-rocket mr-1"></i> Fondo Automático (API)
                    </button>
                    <p id="api-paste-warning" class="text-xs text-orange-600 text-center hidden">API no disponible para imágenes pegadas.</p>
                    <!-- Fin Nuevo Botón -->
                     <button id="remove-inner-hole-btn" class="tool-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Eliminar Hueco (Clic, Esc)"><i class="fas fa-highlighter mr-1"></i> Eliminar Hueco</button>
                     <div class="mt-2">
                         <label for="edge-color-tolerance" class="block text-sm font-medium text-gray-700">Tolerancia (<span id="edge-color-tolerance-value">30</span>):</label>
                         <input type="range" id="edge-color-tolerance" min="1" max="150" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled>
                         <p class="text-xs text-gray-500 mt-1">Sensibilidad para fondo/hueco.</p>
                     </div>
                 </div>
                <!-- Ajuste Manual -->
                <div class="border-t pt-4">
                    <p class="text-sm font-medium text-gray-700 mb-2">Ajuste manual:</p>
                    <div class="flex space-x-2">
                        <button id="brush-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Pincel (B)"><i class="fas fa-paint-brush fa-fw"></i></button>
                        <button id="eraser-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Borrador (E)"><i class="fas fa-eraser fa-fw"></i></button>
                        <button id="line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Conservar (L)"><i class="fas fa-minus fa-fw"></i></button>
                        <button id="eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Línea Borrar (Shift+L)"><i class="fa-line-eraser"></i></button>
                        <button id="continuous-eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50" title="Trazo Borrar (X, Esc)"><i class="fa-continuous-eraser-line"></i></button>
                    </div>
                </div>
                <!-- Opciones Pincel/Borrador/Trazo -->
                <div id="brush-options-section" class="space-y-3">
                    <div><label for="brush-size" class="block text-sm font-medium">Tamaño/Grosor: <span id="brush-size-value">50</span>px</label><input type="range" id="brush-size" min="1" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div id="feather-option"><label for="brush-feather" class="block text-sm font-medium">Difuminado: <span id="brush-feather-value">0.10</span></label><input type="range" id="brush-feather" min="0" max="1" step="0.05" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div><label for="brush-opacity" class="block text-sm font-medium">Opacidad: <span id="brush-opacity-value">1.00</span></label><input type="range" id="brush-opacity" min="0.05" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div id="shape-option"><label class="block text-sm font-medium">Forma:</label><div class="flex space-x-2 mt-1"><button id="brush-shape-circle" class="brush-shape p-1 border rounded-full w-6 h-6 bg-gray-700 disabled:opacity-50" title="Circular" disabled></button><button id="brush-shape-square" class="brush-shape p-1 border rounded w-6 h-6 bg-gray-700 disabled:opacity-50" title="Cuadrado" disabled></button></div></div>
                </div>
                <!-- Acciones -->
                <div class="flex space-x-2 pt-4 border-t">
                    <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50" title="Deshacer (Ctrl+Z)"><i class="fas fa-undo"></i> (<span id="undo-count">0</span>)</button>
                    <button id="reset-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50" title="Resetear"><i class="fas fa-trash-alt"></i> Reset</button>
                </div>
            </div>
            <!-- Exportar / Copiar -->
             <div id="export-section" class="hidden pt-4 border-t space-y-2">
                 <h2 class="text-lg font-semibold mb-2">3. Guardar / Copiar</h2>
                 <button id="export-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-download mr-1"></i> Exportar PNG</button>
                 <button id="copy-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 btn-feedback" disabled><i class="fas fa-copy mr-1"></i> Copiar Imagen</button>
                 <p id="clipboard-support-warning" class="text-xs text-red-600 text-center hidden">Copiar no soportado.</p>
             </div>
        </aside>

        <!-- Área de Trabajo -->
        <section class="flex-grow bg-gray-300 rounded-lg shadow overflow-hidden relative checkerboard-bg">
            <div id="canvas-outer-container">
                <div id="canvas-inner-container">
                    <canvas id="image-canvas" class="hidden"></canvas>
                    <canvas id="preview-canvas" class="hidden"></canvas>
                </div>
                <p id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">Carga una imagen para empezar</p>
            </div>
            <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-50 pointer-events-none"> <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i> <p class="text-lg font-semibold ml-3">Cargando...</p> </div>
            <div id="processing-overlay" class="processing-overlay hidden"> <i class="fas fa-spinner fa-spin fa-3x"></i> <p id="processing-status-text">Procesando...</p> </div>
            <div id="status-bar" class="absolute bottom-0 left-0 bg-black bg-opacity-60 text-white text-xs p-1 rounded-tr z-40 pointer-events-none"> Zoom: <span id="zoom-level">100</span>% | Herramienta: <span id="current-tool-status">Ninguna</span> | Rueda=Zoom, Espacio+Arrastrar=Mover </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Cargado - XocoStudio Background Remover (con API)");

            // --- DOM Elements ---
            const dropZone = document.getElementById('drop-zone'); const fileInput = document.getElementById('file-input'); const uploadBtn = document.getElementById('upload-btn'); const pasteBtn = document.getElementById('paste-btn'); const pasteSupportWarning = document.getElementById('paste-support-warning'); const filenameDisplay = document.getElementById('filename-display'); const canvasOuterContainer = document.getElementById('canvas-outer-container'); const canvasInnerContainer = document.getElementById('canvas-inner-container');
            const canvas = document.getElementById('image-canvas'); const previewCanvas = document.getElementById('preview-canvas');
            const canvasPlaceholder = document.getElementById('canvas-placeholder'); const loadingSpinner = document.getElementById('loading-spinner'); const toolsSection = document.getElementById('tools-section'); const exportSection = document.getElementById('export-section'); const brushBtn = document.getElementById('brush-tool'); const eraserBtn = document.getElementById('eraser-tool'); const lineBtn = document.getElementById('line-tool'); const eraserLineBtn = document.getElementById('eraser-line-tool'); const continuousEraserLineBtn = document.getElementById('continuous-eraser-line-tool'); const brushOptionsSection = document.getElementById('brush-options-section'); const featherOptionDiv = document.getElementById('feather-option'); const shapeOptionDiv = document.getElementById('shape-option'); const brushSizeSlider = document.getElementById('brush-size'); const brushSizeValue = document.getElementById('brush-size-value'); const brushFeatherSlider = document.getElementById('brush-feather'); const brushFeatherValue = document.getElementById('brush-feather-value'); const brushOpacitySlider = document.getElementById('brush-opacity'); const brushOpacityValue = document.getElementById('brush-opacity-value'); const shapeCircleBtn = document.getElementById('brush-shape-circle'); const shapeSquareBtn = document.getElementById('brush-shape-square'); const undoBtn = document.getElementById('undo-btn'); const undoCountSpan = document.getElementById('undo-count'); const resetBtn = document.getElementById('reset-btn'); const exportBtn = document.getElementById('export-btn'); const copyBtn = document.getElementById('copy-btn'); const clipboardSupportWarning = document.getElementById('clipboard-support-warning'); const zoomLevelSpan = document.getElementById('zoom-level'); const currentToolSpan = document.getElementById('current-tool-status'); const processingOverlay = document.getElementById('processing-overlay'); const processingStatusText = document.getElementById('processing-status-text'); const removeEdgeBgBtn = document.getElementById('remove-edge-bg-btn');
            const removeInnerHoleBtn = document.getElementById('remove-inner-hole-btn'); const edgeColorToleranceSlider = document.getElementById('edge-color-tolerance'); const edgeColorToleranceValueSpan = document.getElementById('edge-color-tolerance-value');
            const removeBgApiBtn = document.getElementById('remove-bg-api-btn'); // <-- Nuevo botón API
            const apiPasteWarning = document.getElementById('api-paste-warning'); // <-- Nuevo warning

            // --- State Variables ---
            let ctx = null; let previewCtx = null;
            let originalImage = null; let originalImageDataCache = null; let imageFilename = 'imagen';
            let maskCanvas = null; let maskCtx = null;
            let isDrawing = false; let lastX = 0; let lastY = 0; let history = []; const MAX_HISTORY = 30; let currentTool = 'eraser';
            let brushOptions = { size: 50, feather: 0.1, opacity: 1.0, shape: 'circle' };
            let zoomLevel = 1.0; let panX = 0; let panY = 0; let isPanning = false; let panStartX = 0; let panStartY = 0; let isSpacePressed = false;
            let isDrawingLine = false; let lineStartX = 0; let lineStartY = 0; let isDrawingContinuousLine = false; let lastContinuousLinePoint = null;
            let currentMousePos = { x: 0, y: 0 };
            let isClipboardWriteSupported = !!(navigator.clipboard && navigator.clipboard.write); let isClipboardReadSupported = !!(navigator.clipboard && navigator.clipboard.read);
            let isFloodFilling = false; let cancelFloodFillRequest = false; let waitingForInnerHoleClick = false; let holeRemoverFeedbackTimeout = null;
            let originalFile = null; // <-- Variable para guardar el archivo original
            let isApiProcessing = false; // <-- Flag para indicar procesamiento API

            // --- Performance Throttling ---
            let lastRenderTime = 0;
            const RENDER_THROTTLE = 16;

            // --- Verification ---
            if (!canvas || !previewCanvas || !dropZone || !fileInput || !uploadBtn || !pasteBtn || !removeEdgeBgBtn || !removeInnerHoleBtn || !continuousEraserLineBtn || !removeBgApiBtn || !apiPasteWarning) { console.error("Faltan elementos DOM."); alert("Error: App no iniciada."); return; }
            console.log("Elementos DOM OK.");

            // --- Initialization ---
            setActiveTool('eraser'); updateToolOptionsDisplay(); setupImageLoadingListeners(); setupInteractionListeners(); setupToolControlListeners(); checkClipboardSupport(); updateActionButtonsState(); console.log("Inicialización completada.");

            function cancelContinuousLineDrawing(silent = false) { if (isDrawingContinuousLine) { if (!silent) console.log("Cancelando trazo continuo."); isDrawingContinuousLine = false; lastContinuousLinePoint = null; clearPreviewCanvas(); updateStatusBar(); canvasOuterContainer.style.cursor = getToolCursor(); } }

            // --- Setup Functions ---
            function setupImageLoadingListeners() { console.log("Listeners carga..."); dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); const file = e.dataTransfer?.files?.[0]; if (file?.type.startsWith('image/')) { handleFile(file); } else if (file) { alert('Suelta imagen.'); } }); uploadBtn.addEventListener('click', () => fileInput.click()); pasteBtn.addEventListener('click', handlePasteButtonClick); fileInput.addEventListener('change', (e) => { const file = e.target.files?.[0]; if (file?.type.startsWith('image/')) { handleFile(file); e.target.value = null; } else if (file) { alert('Selecciona imagen.'); } }); window.addEventListener('paste', (e) => { const activeElement = document.activeElement; if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable) return; if (isApiProcessing || isFloodFilling || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine) return; if (handleClipboardPaste(e.clipboardData)) e.preventDefault(); }); console.log("Listeners carga OK."); }
            function setupInteractionListeners() { window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); canvasOuterContainer.addEventListener('mousedown', handleInteractionStart); canvasOuterContainer.addEventListener('mousemove', handleInteractionMove); window.addEventListener('mouseup', handleInteractionEnd); canvasOuterContainer.addEventListener('touchstart', (e) => handleInteractionStart(e.touches[0]), { passive: false }); canvasOuterContainer.addEventListener('touchmove', (e) => handleInteractionMove(e.touches[0]), { passive: false }); window.addEventListener('touchend', (e) => handleInteractionEnd(e.changedTouches[0])); window.addEventListener('touchcancel', (e) => handleInteractionEnd(e.changedTouches[0])); canvasOuterContainer.addEventListener('wheel', handleWheelZoom, { passive: false }); canvasOuterContainer.addEventListener('mouseleave', () => { if (!isDrawingLine && !isDrawingContinuousLine) { clearPreviewCanvas(); } }); }
            function setupToolControlListeners() { console.log("Listeners herramientas..."); brushBtn.addEventListener('click', () => setActiveTool('brush')); eraserBtn.addEventListener('click', () => setActiveTool('eraser')); lineBtn.addEventListener('click', () => setActiveTool('line')); eraserLineBtn.addEventListener('click', () => setActiveTool('eraser-line')); continuousEraserLineBtn.addEventListener('click', () => setActiveTool('continuous-eraser-line')); brushSizeSlider.addEventListener('input', (e) => { brushOptions.size = parseInt(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y);}); brushFeatherSlider.addEventListener('input', (e) => { brushOptions.feather = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); }); brushOpacitySlider.addEventListener('input', (e) => { brushOptions.opacity = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); }); shapeCircleBtn.addEventListener('click', () => { brushOptions.shape = 'circle'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); }); shapeSquareBtn.addEventListener('click', () => { brushOptions.shape = 'square'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); }); edgeColorToleranceSlider.addEventListener('input', (e) => edgeColorToleranceValueSpan.textContent = e.target.value); undoBtn.addEventListener('click', undo); resetBtn.addEventListener('click', () => { if (!originalImage || history.length <= 1) return; if (confirm('¿Resetear ediciones?')) { if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if (isDrawingLine) { isDrawingLine = false; clearPreviewCanvas(); } resetMask(); } }); exportBtn.addEventListener('click', exportImage); copyBtn.addEventListener('click', copyImageToClipboard); removeEdgeBgBtn.addEventListener('click', () => { if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if (isFloodFilling) { cancelFloodFillRequest = true; processingStatusText.textContent = "Cancelando..."; showButtonFeedback(removeEdgeBgBtn, 'cancelling', 'Cancelando...', 60000); } else { handleRemoveBackgroundByFloodFill(); } }); removeInnerHoleBtn.addEventListener('click', () => { if (isFloodFilling) return; cancelContinuousLineDrawing(true); if (waitingForInnerHoleClick) { cancelInnerHoleClickMode(); } else { activateInnerHoleClickMode(); } });
                // *** Listener para NUEVO botón API ***
                removeBgApiBtn.addEventListener('click', handleRemoveBgApiClick);
                 console.log("Listeners herramientas OK.");
            }

            // --- Core Logic ---
            function handleFile(file) {
                 console.log('>>> handleFile:', file?.name);
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if(isDrawingLine) isDrawingLine = false;
                 if (!file?.type?.startsWith('image/')) { alert('Archivo no válido.'); return; }

                 originalFile = file; // <-- Guardar el archivo original
                 apiPasteWarning.classList.add('hidden'); // Ocultar warning si cargamos archivo

                 const reader = new FileReader(); reader.onloadstart = () => { showLoadingState(file.name); }; reader.onload = (e) => { if (!e.target?.result) { handleLoadingError(file.name, 'Error leer.'); return; } originalImage = new Image(); let previousBlobUrl = null; // Para revocar URL anterior si existe
                      if (originalImage.src && originalImage.src.startsWith('blob:')) { previousBlobUrl = originalImage.src; } originalImage.onload = () => { console.log(`Imagen cargada: ${originalImage.naturalWidth}x${originalImage.naturalHeight}`); if (previousBlobUrl) { console.log("Revocando URL blob anterior:", previousBlobUrl); URL.revokeObjectURL(previousBlobUrl); } if (originalImage.naturalWidth === 0) { handleLoadingError(file.name, 'Dimensiones inválidas.'); originalImage = null; return; } initializeEditor(file.name, originalImage); }; originalImage.onerror = (err) => { if (previousBlobUrl) URL.revokeObjectURL(previousBlobUrl); handleLoadingError(file.name, 'Error decodificar.'); originalImage = null; }; originalImage.src = e.target.result; }; reader.onerror = (err) => { handleLoadingError(file.name, 'Error lectura.'); }; try { reader.readAsDataURL(file); } catch (error) { handleLoadingError(file.name, 'Error lectura.'); }
            }
            function showLoadingState(fileName) { console.log("Cargando:", fileName); if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if(isDrawingLine) isDrawingLine = false; loadingSpinner.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden'); filenameDisplay.textContent = `Cargando: ${fileName}...`; toolsSection.classList.add('hidden'); exportSection.classList.add('hidden'); canvas.classList.add('hidden'); previewCanvas.classList.add('hidden'); originalImage = null; originalImageDataCache = null; originalFile = null; /* Resetear archivo */ ctx = previewCtx = maskCtx = null; history = []; updateActionButtonsState(); }
            function handleLoadingError(fileName, message) { console.error(`Error carga ${fileName || 'imagen'}: ${message}`); if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if(isDrawingLine) isDrawingLine = false; alert(`Error al cargar "${fileName || ''}":\n${message}`); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.remove('hidden'); filenameDisplay.textContent = `Error al cargar`; originalImage = null; originalImageDataCache = null; originalFile = null; ctx = previewCtx = maskCtx = null; history = []; toolsSection.classList.add('hidden'); exportSection.classList.add('hidden'); updateActionButtonsState(); }

            function initializeEditor(fileName, loadedImage) {
                 console.log(">>> initializeEditor:", fileName); if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if (isDrawingLine) isDrawingLine = false;
                 if (!loadedImage || !loadedImage.naturalWidth || !loadedImage.naturalHeight) { handleLoadingError(fileName, "Datos inválidos."); return; } imageFilename = fileName.replace(/\.[^/.]+$/, "") || 'imagen_editada'; filenameDisplay.textContent = `Editando: ${fileName} (${loadedImage.naturalWidth}x${loadedImage.naturalHeight})`;
                 try { ctx = canvas.getContext('2d', { willReadFrequently: false }); previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true }); if (!ctx || !previewCtx ) throw new Error("getContext null."); console.log("Contextos OK."); } catch (e) { console.error("Error contextos:", e); handleLoadingError(fileName, "Error: Contexto gráfico."); return; }
                 if (!setupCanvases(loadedImage)) { handleLoadingError(fileName, "Error canvas."); return; } cacheOriginalImageData();
                 resetMask(); centerAndFitImage();
                 requestRender();
                 toolsSection.classList.remove('hidden'); exportSection.classList.remove('hidden'); canvas.classList.remove('hidden'); previewCanvas.classList.remove('hidden'); loadingSpinner.classList.add('hidden'); canvasPlaceholder.classList.add('hidden'); setActiveTool(currentTool); updateActionButtonsState(); console.log("<<< initializeEditor completado.");
            }

            function setupCanvases(img) { console.log(">>> setupCanvases"); if (!img?.naturalWidth || !img?.naturalHeight || !canvas || !previewCanvas || !canvasInnerContainer) { console.error("Faltan canvas."); return false; } const w = img.naturalWidth; const h = img.naturalHeight; canvas.width = w; canvas.height = h; previewCanvas.width = w; previewCanvas.height = h; canvasInnerContainer.style.width = `${w}px`; canvasInnerContainer.style.height = `${h}px`; try { if (!maskCanvas) maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h; maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true }); if (!maskCtx) throw new Error("maskCtx null."); console.log("maskCtx OK."); } catch (e) { alert("Error máscara."); console.error("Error maskCtx:", e); maskCanvas = maskCtx = null; return false; } console.log(`Canvases ${w}x${h}`); return true; }
            function cacheOriginalImageData() { if (!originalImage || !canvas) { originalImageDataCache = null; console.warn("No cache ImageData."); return; } console.log("Cacheando ImageData..."); const tempCanvas = document.createElement('canvas'); tempCanvas.width = originalImage.naturalWidth; tempCanvas.height = originalImage.naturalHeight; const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true }); if (!tempCtx) { console.error("Error ctx temp."); originalImageDataCache = null; return; } try { tempCtx.drawImage(originalImage, 0, 0); originalImageDataCache = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height); console.log("ImageData cacheada OK."); } catch (e) { console.error("Error getImageData:", e); originalImageDataCache = null; alert("Error leer píxeles."); } }
            function centerAndFitImage() { if (!originalImage || !canvasOuterContainer) return; const imgWidth = originalImage.naturalWidth; const imgHeight = originalImage.naturalHeight; const contWidth = canvasOuterContainer.clientWidth; const contHeight = canvasOuterContainer.clientHeight; if (contWidth <= 0 || contHeight <= 0 || imgWidth <= 0 || imgHeight <= 0) { zoomLevel = 1.0; panX = 0; panY = 0; } else { zoomLevel = Math.min(contWidth / imgWidth, contHeight / imgHeight) * 0.95; panX = (contWidth - imgWidth * zoomLevel) / 2; panY = (contHeight - imgHeight * zoomLevel) / 2; } updateTransform(); updateStatusBar(); console.log(`Centrado: z=${zoomLevel.toFixed(2)}, pX=${panX.toFixed(0)}, pY=${panY.toFixed(0)}`); }

            function resetMask() { if (waitingForInnerHoleClick) cancelInnerHoleClickMode(); cancelContinuousLineDrawing(true); if (!maskCtx || !maskCanvas || !originalImage) return; console.log("Reseteando máscara."); maskCtx.fillStyle = 'white'; maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height); history = []; saveStateToHistory(); updateActionButtonsState(); requestRender(); }
            function requestRender() { const now = performance.now(); if (now - lastRenderTime >= RENDER_THROTTLE) { renderCanvas(); lastRenderTime = now; } }
            function renderCanvas() { if (!ctx || !originalImage || !maskCanvas) return; ctx.globalCompositeOperation = 'source-over'; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(originalImage, 0, 0); ctx.globalCompositeOperation = 'destination-in'; ctx.drawImage(maskCanvas, 0, 0); ctx.globalCompositeOperation = 'source-over'; }
            function clearPreviewCanvas() { if (previewCtx) previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height); }
            function drawBrushPreview(imageX, imageY) { if (!previewCtx || isPanning || waitingForInnerHoleClick || currentTool === 'line' || currentTool === 'eraser-line' || currentTool === 'continuous-eraser-line' || isDrawingLine) { clearPreviewCanvas(); return; } clearPreviewCanvas(); const size = brushOptions.size * zoomLevel; const featherAmount = size * brushOptions.feather; const solidRadius = size / 2 - featherAmount / 2; const totalRadius = size / 2; const screenX = imageX * zoomLevel + panX; const screenY = imageY * zoomLevel + panY; const previewX = (screenX - panX) / zoomLevel; const previewY = (screenY - panY) / zoomLevel; previewCtx.save(); previewCtx.globalAlpha = 0.6; if (brushOptions.shape === 'circle') { const gradient = previewCtx.createRadialGradient(previewX, previewY, Math.max(0, solidRadius / zoomLevel), previewX, previewY, totalRadius / zoomLevel); gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); previewCtx.fillStyle = gradient; previewCtx.beginPath(); previewCtx.arc(previewX, previewY, totalRadius / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); } else { const previewSize = brushOptions.size; const halfSize = previewSize / 2; previewCtx.fillStyle = 'rgba(0, 0, 0, 0.6)'; previewCtx.fillRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize); previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; previewCtx.lineWidth = 1 / zoomLevel; previewCtx.strokeRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize); } previewCtx.restore(); }
            function drawLinePreview(startX, startY, endX, endY) { if (!previewCtx || waitingForInnerHoleClick || currentTool === 'continuous-eraser-line') return; clearPreviewCanvas(); previewCtx.save(); previewCtx.beginPath(); previewCtx.moveTo(startX, startY); previewCtx.lineTo(endX, endY); previewCtx.strokeStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)'; previewCtx.lineWidth = Math.max(1, 3 / zoomLevel); previewCtx.setLineDash([5 / zoomLevel, 5 / zoomLevel]); previewCtx.stroke(); previewCtx.restore(); }
            function applyMaskModification(drawX, drawY, tool, options) { if (!maskCtx || (tool !== 'brush' && tool !== 'eraser')) return; const isEraser = tool === 'eraser'; maskCtx.save(); maskCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over'; const size = options.size; const halfSize = size / 2; const feather = options.feather; const opacity = options.opacity; if (options.shape === 'circle') { const solidRadius = halfSize * (1 - feather); const gradient = maskCtx.createRadialGradient(drawX, drawY, solidRadius, drawX, drawY, halfSize); if (isEraser) { gradient.addColorStop(0, `rgba(0,0,0, ${opacity})`); gradient.addColorStop(1, 'rgba(0,0,0, 0)'); } else { gradient.addColorStop(0, `rgba(255,255,255, ${opacity})`); gradient.addColorStop(1, 'rgba(255,255,255, 0)'); } maskCtx.fillStyle = gradient; maskCtx.beginPath(); maskCtx.arc(drawX, drawY, halfSize, 0, Math.PI * 2); maskCtx.fill(); } else { if (isEraser) { maskCtx.fillStyle = `rgba(0,0,0, ${opacity})`; } else { maskCtx.fillStyle = `rgba(255,255,255, ${opacity})`; } maskCtx.fillRect(drawX - halfSize, drawY - halfSize, size, size); } maskCtx.restore(); requestRender(); }
            function drawLineOnMask(imgX1, imgY1, imgX2, imgY2, tool, options) { if (!maskCtx) return; const isEraserTool = tool === 'eraser' || tool === 'eraser-line' || tool === 'continuous-eraser-line'; const size = options.size; const opacity = options.opacity; maskCtx.save(); maskCtx.globalCompositeOperation = isEraserTool ? 'destination-out' : 'source-over'; maskCtx.beginPath(); maskCtx.moveTo(imgX1, imgY1); maskCtx.lineTo(imgX2, imgY2); maskCtx.lineWidth = size; maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round'; if (isEraserTool) { maskCtx.strokeStyle = `rgba(0, 0, 0, ${opacity})`; } else { maskCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`; } maskCtx.stroke(); maskCtx.restore(); requestRender(); }

            function getInteractionPos(evt) { if (!canvasOuterContainer) return { screenX:0, screenY:0, imageX: 0, imageY: 0 }; const rect = canvasOuterContainer.getBoundingClientRect(); const clientX = evt.clientX ?? evt.pageX; const clientY = evt.clientY ?? evt.pageY; if (clientX === undefined || clientY === undefined) return { screenX:0, screenY:0, imageX: 0, imageY: 0 }; const screenX = clientX - rect.left; const screenY = clientY - rect.top; const imageX = (screenX - panX) / zoomLevel; const imageY = (screenY - panY) / zoomLevel; return { screenX, screenY, imageX, imageY }; }
            function handleInteractionStart(e) { if (!originalImage || isFloodFilling || isApiProcessing) return; if (waitingForInnerHoleClick) { if (e.preventDefault && e.cancelable) e.preventDefault(); const { imageX, imageY } = getInteractionPos(e); removeInnerHoleAt(imageX, imageY); return; } if (isSpacePressed) { if (e.preventDefault && e.cancelable) e.preventDefault(); const { screenX, screenY } = getInteractionPos(e); isPanning = true; panStartX = screenX - panX; panStartY = screenY - panY; canvasOuterContainer.style.cursor = 'grabbing'; return; } if (e.preventDefault && e.cancelable) e.preventDefault(); const { imageX, imageY } = getInteractionPos(e); switch (currentTool) { case 'line': case 'eraser-line': if (!isDrawingLine) { isDrawingLine = true; lineStartX = imageX; lineStartY = imageY; clearPreviewCanvas(); previewCtx.fillStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)'; previewCtx.beginPath(); previewCtx.arc(lineStartX, lineStartY, 5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); canvasOuterContainer.style.cursor = 'crosshair'; } else { drawLineOnMask(lineStartX, lineStartY, imageX, imageY, currentTool, brushOptions); saveStateToHistory(); requestRender(); isDrawingLine = false; clearPreviewCanvas(); setActiveTool(currentTool); } break; case 'continuous-eraser-line': if (!isDrawingContinuousLine) { isDrawingContinuousLine = true; lastContinuousLinePoint = { x: imageX, y: imageY }; clearPreviewCanvas(); previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.beginPath(); previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); canvasOuterContainer.style.cursor = 'crosshair'; } else { drawLineOnMask(lastContinuousLinePoint.x, lastContinuousLinePoint.y, imageX, imageY, currentTool, brushOptions); lastContinuousLinePoint = { x: imageX, y: imageY }; saveStateToHistory(); requestRender(); clearPreviewCanvas(); previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.beginPath(); previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); } break; case 'brush': case 'eraser': default: if(isDrawingLine) isDrawingLine = false; cancelContinuousLineDrawing(true); isDrawing = true; lastX = imageX; lastY = imageY; applyMaskModification(imageX, imageY, currentTool, brushOptions); canvasOuterContainer.style.cursor = 'crosshair'; break; } updateActionButtonsState(); }
            function handleInteractionMove(e) { if (!originalImage || isFloodFilling || isApiProcessing || waitingForInnerHoleClick) return; const { screenX, screenY, imageX, imageY } = getInteractionPos(e); currentMousePos = { x: imageX, y: imageY }; if (isPanning) { panX = screenX - panStartX; panY = screenY - panStartY; updateTransform(); updateStatusBar(); } else if (isDrawing) { drawLineOnMask(lastX, lastY, imageX, imageY, currentTool, brushOptions); lastX = imageX; lastY = imageY; requestRender(); drawBrushPreview(imageX, imageY); } else if (isDrawingLine) { drawLinePreview(lineStartX, lineStartY, imageX, imageY); } else if (isDrawingContinuousLine) { clearPreviewCanvas(); if(lastContinuousLinePoint) { previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.beginPath(); previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); } } else { drawBrushPreview(imageX, imageY); } }
            function handleInteractionEnd(e) { if (isPanning) { isPanning = false; canvasOuterContainer.style.cursor = getToolCursor(); } else if (isDrawing) { isDrawing = false; saveStateToHistory(); clearPreviewCanvas(); drawBrushPreview(currentMousePos.x, currentMousePos.y); requestRender(); updateActionButtonsState();} }

            function setActiveTool(tool) { if (tool !== 'hole-remover' && waitingForInnerHoleClick) cancelInnerHoleClickMode(); if (tool !== 'line' && tool !== 'eraser-line' && isDrawingLine) { isDrawingLine = false; clearPreviewCanvas(); console.log("Línea cancelada."); } if (tool !== 'continuous-eraser-line' && isDrawingContinuousLine) cancelContinuousLineDrawing(); currentTool = tool; console.log("Herramienta:", tool); [brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousEraserLineBtn].forEach(btn => btn.classList.remove('active-tool')); const manualTools = ['brush', 'eraser', 'line', 'eraser-line', 'continuous-eraser-line']; if (manualTools.includes(tool)) { const activeBtn = document.getElementById(`${tool}-tool`); if (activeBtn) activeBtn.classList.add('active-tool'); } const isBrushOrEraser = tool === 'brush' || tool === 'eraser'; const isAnyLineTool = tool === 'line' || tool === 'eraser-line' || tool === 'continuous-eraser-line'; const showBrushOptionsPanel = isBrushOrEraser || isAnyLineTool; brushOptionsSection.style.display = showBrushOptionsPanel ? 'block' : 'none'; featherOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none'; shapeOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none'; canvasOuterContainer.style.cursor = getToolCursor(); updateStatusBar(); updateToolOptionsDisplay(); clearPreviewCanvas(); if (tool === 'continuous-eraser-line' && isDrawingContinuousLine && lastContinuousLinePoint) { previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; previewCtx.beginPath(); previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2); previewCtx.fill(); } updateActionButtonsState(); }
            function getToolCursor() { if (waitingForInnerHoleClick) return 'crosshair'; if (isSpacePressed) return 'grab'; if (isPanning) return 'grabbing'; if (['brush', 'eraser', 'line', 'eraser-line', 'continuous-eraser-line'].includes(currentTool)) return 'crosshair'; return 'default'; }
            function updateToolOptionsDisplay() { brushSizeValue.textContent = brushOptions.size; brushFeatherValue.textContent = brushOptions.feather.toFixed(2); brushOpacityValue.textContent = brushOptions.opacity.toFixed(2); shapeCircleBtn.classList.toggle('active-shape', brushOptions.shape === 'circle'); shapeSquareBtn.classList.toggle('active-shape', brushOptions.shape === 'square'); }

            function updateActionButtonsState() {
                 const imageLoaded = !!originalImage && !!ctx && !!maskCtx; const canUndo = history.length > 1; const isActionInProgress = isDrawing || isDrawingLine || isDrawingContinuousLine || isFloodFilling || waitingForInnerHoleClick || isApiProcessing;
                 undoBtn.disabled = !canUndo || isActionInProgress; undoCountSpan.textContent = Math.max(0, history.length - 1); resetBtn.disabled = !imageLoaded || !canUndo || isActionInProgress; exportBtn.disabled = !imageLoaded || isActionInProgress; copyBtn.disabled = !imageLoaded || !isClipboardWriteSupported || isActionInProgress; pasteBtn.disabled = !isClipboardReadSupported || isActionInProgress;
                 [brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousEraserLineBtn].forEach(btn => { btn.disabled = !imageLoaded || isActionInProgress; });
                 [brushSizeSlider, brushFeatherSlider, brushOpacitySlider, shapeCircleBtn, shapeSquareBtn].forEach(control => { control.disabled = !imageLoaded || isActionInProgress; });
                 removeEdgeBgBtn.disabled = !imageLoaded || isActionInProgress;
                 removeInnerHoleBtn.disabled = !imageLoaded || isActionInProgress || isDrawing || isDrawingLine || isDrawingContinuousLine; // Allow cancel hole, disable others
                 edgeColorToleranceSlider.disabled = !imageLoaded || isActionInProgress;
                 // API Button State
                 removeBgApiBtn.disabled = !imageLoaded || !originalFile || isActionInProgress; // Disable if no original file or action in progress
                 apiPasteWarning.style.display = (imageLoaded && !originalFile) ? 'block' : 'none'; // Show warning if image loaded but no file (pasted)
            }

            function checkClipboardSupport() { if (!isClipboardReadSupported) { pasteSupportWarning.classList.remove('hidden'); pasteBtn.disabled = true; pasteBtn.title = "Pegar no soportado."; console.warn("Clipboard read no soportado."); } else { pasteSupportWarning.classList.add('hidden'); } if (!isClipboardWriteSupported) { clipboardSupportWarning.classList.remove('hidden'); copyBtn.disabled = true; copyBtn.title = "Copiar no soportado."; console.warn("Clipboard write no soportado."); } else { clipboardSupportWarning.classList.add('hidden'); } updateActionButtonsState(); }
            function saveStateToHistory() { if (!maskCtx || !maskCanvas) return; const currentMaskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height); const historyData = new ImageData( new Uint8ClampedArray(currentMaskData.data), currentMaskData.width, currentMaskData.height ); history.push(historyData); if (history.length > MAX_HISTORY + 1) { history.shift(); } updateActionButtonsState(); }
            function undo() { const canUndoNow = history.length > 1 && !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !isFloodFilling && !waitingForInnerHoleClick && !isApiProcessing; if (!canUndoNow) return; console.log("Deshaciendo..."); history.pop(); const previousState = history[history.length - 1]; if (previousState) { maskCtx.putImageData(previousState, 0, 0); requestRender(); updateActionButtonsState(); console.log(`Restaurado estado ${history.length}.`); } else { console.error("Error deshacer."); } }

            function handleWheelZoom(e) { if (!originalImage || isFloodFilling || isApiProcessing || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine) return; e.preventDefault(); const { screenX, screenY } = getInteractionPos(e); const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1; zoomInOut(zoomFactor, screenX, screenY); }
            function updateTransform() { if (canvasInnerContainer) canvasInnerContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
            function updateStatusBar() { zoomLevelSpan.textContent = Math.round(zoomLevel * 100); let toolName = 'Ninguna'; if (waitingForInnerHoleClick) { toolName = 'Eliminar Hueco (Clic)'; } else { switch (currentTool) { case 'brush': toolName = 'Pincel'; break; case 'eraser': toolName = 'Borrador'; break; case 'line': toolName = 'Línea (Guardar)'; break; case 'eraser-line': toolName = 'Línea (Borrar)'; break; case 'continuous-eraser-line': toolName = 'Trazo Borrador'; break; } if (isDrawingLine || isDrawingContinuousLine) toolName += ' (dibujando)'; else if (isDrawing) toolName += ' (pintando)'; } currentToolSpan.textContent = toolName; }
            function handleKeyDown(e) { if (e.key === 'Escape') { if (waitingForInnerHoleClick) { cancelInnerHoleClickMode(); e.preventDefault(); return; } if (isDrawingLine) { isDrawingLine = false; clearPreviewCanvas(); setActiveTool(currentTool); console.log("Línea cancelada (Esc)."); e.preventDefault(); return; } if (isDrawingContinuousLine) { cancelContinuousLineDrawing(); setActiveTool(currentTool); e.preventDefault(); return; } } const canPan = !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !waitingForInnerHoleClick && !isApiProcessing; if (e.key === ' ' && !isSpacePressed && !e.repeat && canPan) { isSpacePressed = true; if (!isPanning) canvasOuterContainer.style.cursor = 'grab'; e.preventDefault(); } const canUndoNow = history.length > 1 && !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !isFloodFilling && !waitingForInnerHoleClick && !isApiProcessing; if (e.ctrlKey && e.key.toLowerCase() === 'z' && !e.repeat && canUndoNow) { e.preventDefault(); undo(); } const canChangeTool = !isDrawing && !isDrawingLine && !isDrawingContinuousLine && !isFloodFilling && !waitingForInnerHoleClick && !isApiProcessing; const isFocusOnInput = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable; if (!e.ctrlKey && !e.altKey && !e.metaKey && canChangeTool && !isFocusOnInput) { switch(e.key.toLowerCase()) { case 'b': setActiveTool('brush'); e.preventDefault(); break; case 'e': setActiveTool('eraser'); e.preventDefault(); break; case 'l': setActiveTool(e.shiftKey ? 'eraser-line' : 'line'); e.preventDefault(); break; case 'x': setActiveTool('continuous-eraser-line'); e.preventDefault(); break; } } }
            function handleKeyUp(e) { if (e.key === ' ') { isSpacePressed = false; if (!isPanning) canvasOuterContainer.style.cursor = getToolCursor(); e.preventDefault(); } }
            function zoomInOut(factor, pivotX, pivotY) { if (!originalImage) return; const newZoomLevel = Math.max(0.1, Math.min(zoomLevel * factor, 15)); if (newZoomLevel === zoomLevel) return; const dx = (pivotX - panX) * (newZoomLevel / zoomLevel - 1); const dy = (pivotY - panY) * (newZoomLevel / zoomLevel - 1); panX -= dx; panY -= dy; zoomLevel = newZoomLevel; updateTransform(); updateStatusBar(); clearPreviewCanvas(); if (isDrawingContinuousLine && lastContinuousLinePoint) { /* Redraw marker */ } else if (!isDrawingLine && !waitingForInnerHoleClick && (currentTool === 'brush' || currentTool === 'eraser')) { drawBrushPreview(currentMousePos.x, currentMousePos.y); } }

            function showButtonFeedback(button, status, message = null, duration = 1500) { if (!button) return; const isHoleRemoverActive = button.id === 'remove-inner-hole-btn' && button.classList.contains('active-hole-remover'); if (!button.dataset.originalHtml) button.dataset.originalHtml = button.innerHTML; if (!button.dataset.originalTitle) button.dataset.originalTitle = button.title; button.classList.remove('success', 'error', 'working', 'cancelling'); button.classList.add(status); if (message) { if (message.startsWith('<i class="')) button.innerHTML = message; else button.textContent = message; } button.disabled = (status === 'working' || status === 'cancelling'); if (button.feedbackTimeout) clearTimeout(button.feedbackTimeout); const shouldRevert = status === 'success' || status === 'error'; const preventRevert = (isHoleRemoverActive && button.id === 'remove-inner-hole-btn'); if (shouldRevert && !preventRevert) { button.feedbackTimeout = setTimeout(() => { button.classList.remove('success', 'error'); if (button.dataset.originalHtml) button.innerHTML = button.dataset.originalHtml; if (button.dataset.originalTitle) button.title = button.dataset.originalTitle; delete button.dataset.originalHtml; delete button.dataset.originalTitle; updateActionButtonsState(); }, duration); } }
            function showProcessingOverlay(message) { processingStatusText.textContent = message || "Procesando..."; processingOverlay.classList.remove('hidden'); } function hideProcessingOverlay() { processingOverlay.classList.add('hidden'); }

            async function createFinalImageBlob(format = 'image/png') { if (!originalImage || !maskCanvas) return null; console.log("Creando Blob..."); const finalCanvas = document.createElement('canvas'); finalCanvas.width = originalImage.naturalWidth; finalCanvas.height = originalImage.naturalHeight; const finalCtx = finalCanvas.getContext('2d'); if (!finalCtx) { console.error("Error ctx final."); return null; } finalCtx.clearRect(0, 0, finalCanvas.width, finalCanvas.height); finalCtx.drawImage(originalImage, 0, 0); finalCtx.globalCompositeOperation = 'destination-in'; finalCtx.drawImage(maskCanvas, 0, 0); finalCtx.globalCompositeOperation = 'source-over'; return new Promise((resolve) => finalCanvas.toBlob(resolve, format)); }
            async function exportImage() { if (!originalImage || exportBtn.disabled) return; showButtonFeedback(exportBtn, 'working', 'Exportando...'); try { const blob = await createFinalImageBlob('image/png'); if (!blob) throw new Error("No Blob."); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${imageFilename}_sin_fondo.png`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showButtonFeedback(exportBtn, 'success', '<i class="fas fa-check"></i> Exportado'); } catch (error) { console.error("Error exportando:", error); alert(`Error: ${error.message}`); showButtonFeedback(exportBtn, 'error', '<i class="fas fa-times"></i> Error'); } finally { updateActionButtonsState(); } }
            async function copyImageToClipboard() { if (!originalImage || !isClipboardWriteSupported || copyBtn.disabled) return; showButtonFeedback(copyBtn, 'working', 'Copiando...'); try { const blob = await createFinalImageBlob('image/png'); if (!blob) throw new Error("No Blob."); const item = new ClipboardItem({ 'image/png': blob }); await navigator.clipboard.write([item]); showButtonFeedback(copyBtn, 'success', '<i class="fas fa-check"></i> Copiado'); } catch (error) { console.error("Error copiando:", error); let msg = error.name === 'NotAllowedError' ? "Permiso denegado." : "Error."; alert(`No se pudo copiar: ${msg}`); showButtonFeedback(copyBtn, 'error', '<i class="fas fa-times"></i> Error'); } finally { updateActionButtonsState(); } }
            async function handlePasteButtonClick() {
                 if (!isClipboardReadSupported || pasteBtn.disabled) return; console.log("Pegando (botón)..."); showButtonFeedback(pasteBtn, 'working', 'Pegando...'); try { const permission = await navigator.permissions.query({ name: 'clipboard-read' }); if (permission.state === 'denied') throw new Error("Permiso denegado."); const clipboardItems = await navigator.clipboard.read(); let imageFound = false; for (const item of clipboardItems) { const imageType = item.types.find(type => type.startsWith("image/")); if (imageType) { const blob = await item.getType(imageType);
                     originalFile = null; // *** Marcar que no hay archivo original ***
                     handleFile(new File([blob], "imagen_pegada.png", { type: imageType })); imageFound = true; break; } } if (imageFound) showButtonFeedback(pasteBtn, 'success', '<i class="fas fa-check"></i> Pegado'); else showButtonFeedback(pasteBtn, 'error', 'No imagen', 1000); } catch (error) { console.error("Error pegando:", error); let msg = error.name === 'NotAllowedError' ? "Permiso denegado." : "Error."; alert(`No se pudo pegar: ${msg}`); showButtonFeedback(pasteBtn, 'error', '<i class="fas fa-times"></i> Error'); } finally { updateActionButtonsState(); }
            }
            function handleClipboardPaste(clipboardData) {
                 if (!clipboardData?.items) return false; console.log("Paste evento..."); let imageFound = false; for (const item of clipboardData.items) { if (item.kind === 'file' && item.type.startsWith('image/')) { const file = item.getAsFile(); if (file) {
                     originalFile = null; // *** Marcar que no hay archivo original ***
                     handleFile(file); imageFound = true; break; } } } return imageFound;
            }

            function colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2; const dg = g1 - g2; const db = b1 - b2; return dr * dr + dg * dg + db * db; }

            function floodFillMask(originalData, maskData, startX, startY, toleranceSq, visited) { const width = originalData.width; const height = originalData.height; const originalPixels = originalData.data; const maskPixels = maskData.data; if (startX < 0 || startX >= width || startY < 0 || startY >= height || visited[startY][startX]) return false; const startIndex = (startY * width + startX) * 4; const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2]; if (originalPixels[startIndex + 3] < 128 || maskPixels[startIndex + 3] < 1) { visited[startY][startX] = true; return false; } const queue = [[startX, startY]]; visited[startY][startX] = true; maskPixels[startIndex + 3] = 0; let iterations = 0; const maxIterations = width * height * 1.5; while (queue.length > 0) { iterations++; if (iterations % 500 === 0) { if (cancelFloodFillRequest) return true; } if (iterations > maxIterations) { console.warn(`Flood fill límite.`); break; } const [x, y] = queue.shift(); const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ]; for (const [nx, ny] of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) { const nIndex = (ny * width + nx) * 4; if (originalPixels[nIndex + 3] >= 128 && maskPixels[nIndex + 3] > 128) { const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2]; const distSq = colorDistance(startR, startG, startB, nR, nG, nB); if (distSq <= toleranceSq) { visited[ny][nx] = true; queue.push([nx, ny]); maskPixels[nIndex + 3] = 0; } } else { visited[ny][nx] = true; } } } } return false; }
            async function handleRemoveBackgroundByFloodFill() { if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache) { alert("Error datos."); return; } if (isFloodFilling || isApiProcessing || isDrawing || isDrawingLine || isDrawingContinuousLine || waitingForInnerHoleClick) { console.warn("Flood Fill bloqueado."); return; } isFloodFilling = true; cancelFloodFillRequest = false; updateActionButtonsState(); showButtonFeedback(removeEdgeBgBtn, 'working', 'Analizando...'); showProcessingOverlay('Analizando bordes...'); await new Promise(resolve => setTimeout(resolve, 50)); try { if (cancelFloodFillRequest) throw new Error("Cancelled"); processingStatusText.textContent = "Procesando fondo..."; const tolerance = parseInt(edgeColorToleranceSlider.value, 10); const toleranceSq = tolerance * tolerance * 3; const originalData = originalImageDataCache; const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height); const width = maskImageData.width; const height = maskImageData.height; const visited = Array(height).fill(null).map(() => Array(width).fill(false)); console.log("Iniciando Flood Fill..."); const startTime = performance.now(); let cancelledInsideLoop = false; for (let x = 0; x < width; x++) { if (cancelFloodFillRequest || cancelledInsideLoop) break; if (floodFillMask(originalData, maskImageData, x, 0, toleranceSq, visited)) cancelledInsideLoop = true; if (floodFillMask(originalData, maskImageData, x, height - 1, toleranceSq, visited)) cancelledInsideLoop = true; } if (!cancelledInsideLoop) for (let y = 1; y < height - 1; y++) { if (cancelFloodFillRequest || cancelledInsideLoop) break; if (floodFillMask(originalData, maskImageData, 0, y, toleranceSq, visited)) cancelledInsideLoop = true; if (floodFillMask(originalData, maskImageData, width - 1, y, toleranceSq, visited)) cancelledInsideLoop = true; } const endTime = performance.now(); console.log(`Flood Fill terminado ${((endTime - startTime)/1000).toFixed(2)}s. Cancelado: ${cancelledInsideLoop || cancelFloodFillRequest}`); if (cancelFloodFillRequest || cancelledInsideLoop) throw new Error("Cancelled"); maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender(); console.log("Fondo Automático OK."); showButtonFeedback(removeEdgeBgBtn, 'success', '<i class="fas fa-check"></i> Hecho'); } catch (error) { if (error.message === "Cancelled") { console.log("Proceso Cancelado."); showButtonFeedback(removeEdgeBgBtn, 'error', 'Cancelado', 1500); } else { console.error("Error Flood Fill:", error); alert(`Error: ${error.message}`); showButtonFeedback(removeEdgeBgBtn, 'error', '<i class="fas fa-times"></i> Error'); } } finally { isFloodFilling = false; cancelFloodFillRequest = false; hideProcessingOverlay(); if (!removeEdgeBgBtn.classList.contains('success') && !removeEdgeBgBtn.classList.contains('error')) { if (removeEdgeBgBtn.dataset.originalHtml) removeEdgeBgBtn.innerHTML = removeEdgeBgBtn.dataset.originalHtml; delete removeEdgeBgBtn.dataset.originalHtml; if (removeEdgeBgBtn.dataset.originalTitle) removeEdgeBgBtn.title = removeEdgeBgBtn.dataset.originalTitle; delete removeEdgeBgBtn.dataset.originalTitle; } updateActionButtonsState(); } }

            function activateInnerHoleClickMode() { if (!originalImage || isFloodFilling || isApiProcessing || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine) { console.warn("No activar modo hueco."); return; } console.log("Activando modo Hueco"); cancelContinuousLineDrawing(true); setActiveTool('hole-remover'); waitingForInnerHoleClick = true; removeInnerHoleBtn.classList.add('active-hole-remover'); if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout); if (!removeInnerHoleBtn.dataset.originalHtml) removeInnerHoleBtn.dataset.originalHtml = removeInnerHoleBtn.innerHTML; if (!removeInnerHoleBtn.dataset.originalTitle) removeInnerHoleBtn.dataset.originalTitle = removeInnerHoleBtn.title; removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Clic en Hueco'; canvasOuterContainer.style.cursor = 'crosshair'; updateStatusBar(); updateActionButtonsState(); clearPreviewCanvas(); }
            function cancelInnerHoleClickMode() { if (!waitingForInnerHoleClick) return; console.log("Cancelando modo Hueco"); waitingForInnerHoleClick = false; removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error'); if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout); if (removeInnerHoleBtn.dataset.originalHtml) { removeInnerHoleBtn.innerHTML = removeInnerHoleBtn.dataset.originalHtml; delete removeInnerHoleBtn.dataset.originalHtml; } else { removeInnerHoleBtn.innerHTML = '<i class="fas fa-highlighter mr-1"></i> Eliminar Hueco'; } if (removeInnerHoleBtn.dataset.originalTitle) { removeInnerHoleBtn.title = removeInnerHoleBtn.dataset.originalTitle; delete removeInnerHoleBtn.dataset.originalTitle; } setActiveTool('eraser'); updateStatusBar(); updateActionButtonsState(); }
            function removeInnerHoleAt(startX, startY) { if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || !waitingForInnerHoleClick) { console.warn("Eliminar Hueco abortado."); return; } const width = maskCanvas.width; const height = maskCanvas.height; startX = Math.floor(startX); startY = Math.floor(startY); if (startX < 0 || startX >= width || startY < 0 || startY >= height) { console.log("Clic fuera."); return; } let pixelsChanged = 0; let success = false; let message = ''; let statusClass = 'error'; try { const maskImageData = maskCtx.getImageData(0, 0, width, height); const maskPixels = maskImageData.data; const originalPixels = originalImageDataCache.data; const toleranceSq = parseInt(edgeColorToleranceSlider.value, 10) ** 2 * 3; const startIndex = (startY * width + startX) * 4; if (maskPixels[startIndex + 3] < 128) { message = 'Ya Transparente'; statusClass = 'error'; } else { const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2]; const visited = Array(height).fill(null).map(() => Array(width).fill(false)); const queue = [[startX, startY]]; visited[startY][startX] = true; maskPixels[startIndex + 3] = 0; pixelsChanged = 1; let iterations = 0; const maxIterations = width * height; while (queue.length > 0) { iterations++; if (iterations > maxIterations) { console.warn(`Flood fill hueco límite.`); break; } const [x, y] = queue.shift(); const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ]; for (const [nx, ny] of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) { const nIndex = (ny * width + nx) * 4; if (maskPixels[nIndex + 3] > 128) { const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2]; if (colorDistance(startR, startG, startB, nR, nG, nB) <= toleranceSq) { visited[ny][nx] = true; queue.push([nx, ny]); maskPixels[nIndex + 3] = 0; pixelsChanged++; } } else { visited[ny][nx] = true; } } } } if (pixelsChanged > 0) { maskCtx.putImageData(maskImageData, 0, 0); saveStateToHistory(); requestRender(); message = '<i class="fas fa-check"></i> Hueco Borrado'; statusClass = 'success'; success = true; } else { message = 'No Cambios'; statusClass = 'error'; } } } catch (error) { console.error("Error eliminando hueco:", error); alert(`Error: ${error.message}`); message = '<i class="fas fa-times"></i> Error'; statusClass = 'error'; } finally { const feedbackDuration = success ? 1000 : 1500; if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout); removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error'); removeInnerHoleBtn.classList.add(statusClass); removeInnerHoleBtn.innerHTML = message; holeRemoverFeedbackTimeout = setTimeout(() => { removeInnerHoleBtn.classList.remove('success', 'error'); if (waitingForInnerHoleClick) { removeInnerHoleBtn.classList.add('active-hole-remover'); removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Clic en Hueco'; } }, feedbackDuration); } }

             // --- NUEVA LÓGICA: Remove.bg API ---
            function handleRemoveBgApiClick() {
                console.log("Botón API presionado");
                 if (!originalImage || !originalFile || removeBgApiBtn.disabled || isApiProcessing || isFloodFilling || isDrawing || isDrawingLine || isDrawingContinuousLine || waitingForInnerHoleClick) {
                     console.warn("Llamada API abortada: No hay archivo original o acción en curso.");
                     if (!originalFile) {
                         alert("La eliminación de fondo con API solo funciona con imágenes cargadas desde archivo, no pegadas.");
                     }
                     return;
                 }

                 // Cancelar otros modos si están activos
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true);
                 if (isDrawingLine) isDrawingLine = false; clearPreviewCanvas();

                 isApiProcessing = true;
                 updateActionButtonsState();
                 showButtonFeedback(removeBgApiBtn, 'working', 'Procesando API...');
                 showProcessingOverlay('Enviando a Remove.bg...');

                 const formData = new FormData();
                 formData.append("image_file", originalFile); // Usar el archivo original guardado
                 formData.append("size", "auto");

                 // --- ¡¡¡ADVERTENCIA DE SEGURIDAD!!! ---
                 // ¡NO USAR UNA API KEY DIRECTAMENTE EN CÓDIGO CLIENTE EN PRODUCCIÓN!
                 // Esto es solo para demostración. Crea un backend para manejar la API Key.
                 const apiKey = "cy1Ptt4EPQ8vis9prcKwSfHH"; // <-- TU API KEY AQUÍ
                 // --- FIN ADVERTENCIA ---

                 console.log("Enviando a Remove.bg API...");

                 fetch("https://api.remove.bg/v1.0/removebg", {
                     method: "POST",
                     headers: {
                         "X-Api-Key": apiKey,
                     },
                     body: formData,
                 })
                 .then(response => {
                     console.log("Respuesta API recibida, estado:", response.status);
                     if (!response.ok) {
                         // Intentar leer el error como texto o JSON
                         return response.text().then(errText => {
                             let errorMsg = `Error ${response.status}: ${response.statusText}`;
                             try {
                                 // Remove.bg devuelve errores como JSON con una clave "errors"
                                 const errJson = JSON.parse(errText);
                                 if (errJson.errors && errJson.errors.length > 0) {
                                     errorMsg = `Error API: ${errJson.errors[0].title} (${errJson.errors[0].code || ''})`;
                                 }
                             } catch (e) { /* No era JSON válido, usar texto */ errorMsg = `Error ${response.status}: ${errText || response.statusText}`; }
                             throw new Error(errorMsg);
                         });
                     }
                     return response.blob(); // Si OK, obtener el blob
                 })
                 .then(blob => {
                     console.log("Blob recibido de la API:", blob);
                     if (!blob || blob.size === 0) {
                         throw new Error("Respuesta de API vacía o inválida.");
                     }
                     processingStatusText.textContent = "Cargando resultado...";

                     const url = URL.createObjectURL(blob);
                     const resultImage = new Image();
                     let previousBlobUrl = null; // Para revocar URL anterior si existe
                     if (originalImage && originalImage.src && originalImage.src.startsWith('blob:')) {
                         previousBlobUrl = originalImage.src;
                     }

                     resultImage.onload = () => {
                         console.log("Imagen resultado API cargada:", resultImage.width, "x", resultImage.height);
                          if (previousBlobUrl) {
                             console.log("Revocando URL blob anterior:", previousBlobUrl);
                             URL.revokeObjectURL(previousBlobUrl);
                         }

                         // Reemplazar la imagen base
                         originalImage = resultImage;
                         imageFilename = (originalFile?.name.replace(/\.[^/.]+$/, "") || 'imagen') + '_rbg'; // Añadir sufijo
                         filenameDisplay.textContent = `Editando: ${imageFilename}.png (${resultImage.width}x${resultImage.height})`;

                         // Reconfigurar canvas si el tamaño cambió (no debería con 'auto', pero por si acaso)
                         // setupCanvases(resultImage); // Opcional, podría causar problemas si el tamaño es muy diferente

                         // Resetear máscara a blanco (porque la imagen ya no tiene fondo)
                         resetMask(); // Esto guarda estado inicial y llama a requestRender

                         // Actualizar caché de datos (importante para Flood Fill si se usa después)
                         cacheOriginalImageData();

                         // Centrar la nueva imagen
                         centerAndFitImage();

                         // Finalizar estado de procesamiento API
                         isApiProcessing = false;
                         hideProcessingOverlay();
                         showButtonFeedback(removeBgApiBtn, 'success', '<i class="fas fa-check"></i> API OK');
                         updateActionButtonsState(); // Reactivar botones

                         // Importante: No revocar 'url' aquí porque resultImage.src lo está usando.
                         // Se revocará la próxima vez que se cargue una imagen.
                     };
                     resultImage.onerror = () => {
                         console.error("Error al cargar la imagen resultado de la API.");
                         if (previousBlobUrl) URL.revokeObjectURL(previousBlobUrl);
                         URL.revokeObjectURL(url); // Revocar la URL fallida
                         isApiProcessing = false;
                         hideProcessingOverlay();
                         alert("Error: No se pudo cargar la imagen procesada por la API.");
                         showButtonFeedback(removeBgApiBtn, 'error', 'Error Carga');
                         updateActionButtonsState();
                     };
                     resultImage.src = url; // Empezar a cargar la imagen resultado

                 })
                 .catch(error => {
                     console.error("Error en llamada API Remove.bg:", error);
                     isApiProcessing = false;
                     hideProcessingOverlay();
                     alert(`Error API: ${error.message}`);
                     showButtonFeedback(removeBgApiBtn, 'error', 'Error API');
                     updateActionButtonsState();
                 });
            }

        }); // End DOMContentLoaded
    </script>
</body>
</html>
