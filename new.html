<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eliminador de Fondos (Simple) - XocoStudio</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- Estilos CSS (Optimizados) --- */
        body { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .checkerboard-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        .tool-btn.active-tool { background-color: #d1d5db; /* gray-300 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); }
        /* Añadido estilo para el botón de eliminar huecos activo */
        .tool-btn.active-hole-remover { background-color: #fde047 !important; /* yellow-300 */ color: #713f12 !important; /* yellow-800 */ box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1); border-color: #ca8a04; /* yellow-600 */}
        .brush-shape.active-shape { border-color: #3b82f6; /* blue-500 */ border-width: 2px; }
        #canvas-outer-container { width: 100%; height: 100%; overflow: hidden; position: relative; /* Cursor se define por JS */ }
        #canvas-inner-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
        #image-canvas, #preview-canvas { display: block; position: absolute; top: 0; left: 0; max-width: none; /* width/height se definen por JS */ image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        #preview-canvas { pointer-events: none; }
        main { height: calc(100vh - 64px - 32px); } /* Header height (64px) + padding (2*16px=32px) */
        /* Estilo para el icono custom de línea-borrador */
        .fa-line-eraser::before { content: "\f12d"; /* Icono de borrador */ font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 1; }
        .fa-line-eraser::after { content: ""; position: absolute; left: 15%; top: 50%; width: 70%; height: 2px; background-color: currentColor; transform: translateY(-50%) rotate(0deg); opacity: 0.6; z-index: 0; }
        .tool-btn .fa-line-eraser { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; }
        #eraser-line-tool i { font-size: 0.9em; }
        /* Feedback visual para botones */
        .btn-feedback { transition: background-color 0.2s ease-out, color 0.2s ease-out, border-color 0.2s ease-out; }
        .btn-feedback.success { background-color: #22c55e !important; color: white !important; border-color: #16a34a !important; }
        .btn-feedback.error { background-color: #ef4444 !important; color: white !important; border-color: #dc2626 !important; }
        .btn-feedback.working { background-color: #eab308 !important; color: white !important; border-color: #ca8a04 !important; cursor: wait; }
        .btn-feedback.cancelling { background-color: #f97316 !important; color: white !important; border-color: #ea580c !important; cursor: default; }
         /* Overlay para procesamiento */
        .processing-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: none; }
        .processing-overlay i { margin-bottom: 10px; }
        .processing-overlay p { margin-top: 0px; font-size: 1.1rem; }
         /* Estilo para icono de trazo */
         .fa-continuous-eraser-line { position: relative; display: inline-block; width: 1.1em; height: 1em; vertical-align: middle; }
         .fa-continuous-eraser-line::before { content: "\f55b"; /* Icono signature o similar */ font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 45%; top: 45%; transform: translate(-50%, -50%) scale(0.8); z-index: 1; }
         .fa-continuous-eraser-line::after { content: "\f12d"; /* Icono eraser */ font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; left: 70%; top: 70%; transform: translate(-50%, -50%) scale(0.5); z-index: 2; color: #ef4444; /* Red */ }
         #continuous-eraser-line-tool i { font-size: 1em; } /* Ajustar tamaño si es necesario */

    </style>
</head>
<body class="bg-gray-100 flex flex-col min-h-screen overflow-hidden">

    <header class="bg-white shadow-md p-4 flex-shrink-0 flex items-center"> <!-- Añadido flex e items-center -->
        <!-- LOGO Añadido -->
        <a href="https://xocostudio.com/" target="_blank" rel="noopener noreferrer" class="mr-4 flex-shrink-0">
             <img src="https://xocostudio.com/assets/images/xocostudio-354x128.png" alt="XocoStudio Logo" class="h-8"> <!-- Ajustar altura (h-8) si es necesario -->
        </a>
        <!-- Título -->
        <h1 class="text-xl md:text-2xl font-bold text-gray-800">Eliminador de Fondos de Imágenes</h1>
    </header>

    <main class="flex-grow flex flex-col md:flex-row p-4 gap-4">
        <!-- Panel de Controles -->
        <aside class="w-full md:w-72 bg-white p-4 rounded-lg shadow space-y-6 flex-shrink-0 overflow-y-auto">
            <!-- Carga de Imagen -->
            <div id="upload-section">
                 <h2 class="text-lg font-semibold mb-2">1. Cargar Imagen</h2>
                 <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors">
                    <p class="text-gray-600">Arrastra y suelta</p>
                    <p class="text-sm text-gray-500 my-2">o</p>
                    <div class="flex flex-col items-center space-y-2">
                        <input type="file" id="file-input" accept="image/*" class="hidden">
                        <button id="upload-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded btn-feedback">
                            <i class="fas fa-upload mr-1"></i> Seleccionar Archivo
                        </button>
                        <button id="paste-btn" class="w-full bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Pegar imagen del portapapeles (Requiere permisos)">
                             <i class="fas fa-paste mr-1"></i> Pegar (Ctrl+V)
                        </button>
                    </div>
                     <p id="paste-support-warning" class="text-xs text-red-600 mt-2 hidden">Pegar desde el portapapeles no está soportado o permitido.</p>
                 </div>
                 <p id="filename-display" class="text-xs text-gray-600 mt-2 truncate"></p>
            </div>

            <!-- Herramientas -->
            <div id="tools-section" class="space-y-4 hidden pt-4 border-t">
                <h2 class="text-lg font-semibold mb-2">2. Herramientas</h2>

                 <!-- Eliminación Automática -->
                 <div class="mb-4 space-y-2"> <!-- Added space-y-2 -->
                    <button id="remove-edge-bg-btn" class="w-full bg-cyan-600 hover:bg-cyan-800 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Eliminar fondo basado en el color de los bordes. Haz clic de nuevo para intentar cancelar.">
                        <i class="fas fa-wand-magic-sparkles mr-1"></i> Fondo Automático
                    </button>
                    <button id="remove-inner-hole-btn" class="tool-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded btn-feedback disabled:opacity-50 disabled:cursor-not-allowed" title="Activa/Desactiva el modo 'Eliminar Hueco'. Haz clic en un 'hueco' (ej: interior de 'o') para eliminarlo según su color original. Usa la tolerancia de abajo. Pulsa Esc para cancelar.">
                        <i class="fas fa-highlighter mr-1"></i> Eliminar Hueco Interno
                    </button>
                    <div class="mt-2">
                         <label for="edge-color-tolerance" class="block text-sm font-medium text-gray-700">Tolerancia (<span id="edge-color-tolerance-value">30</span>):</label>
                         <input type="range" id="edge-color-tolerance" min="1" max="150" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled>
                         <p class="text-xs text-gray-500 mt-1">Detecta más colores como fondo/hueco.</p> <!-- Updated text -->
                     </div>
                </div>

                <!-- Ajuste Manual -->
                <div class="border-t pt-4">
                    <p class="text-sm font-medium text-gray-700 mb-2">Ajuste manual:</p>
                    <div class="flex space-x-2">
                        <button id="brush-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Pincel Conservar (B)" disabled> <i class="fas fa-paint-brush fa-fw"></i> </button>
                        <button id="eraser-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Borrador Eliminar (E)" disabled> <i class="fas fa-eraser fa-fw"></i> </button>
                        <button id="line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Línea Conservar (L) - Clic inicio, Clic fin" disabled> <i class="fas fa-minus fa-fw"></i> </button>
                        <button id="eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Línea Borrador (Shift+L) - Clic inicio, Clic fin" disabled> <i class="fa-line-eraser"></i> </button>
                        <!-- NUEVO BOTÓN -->
                        <button id="continuous-eraser-line-tool" class="tool-btn p-2 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Trazo Borrador Continuo (X) - Clic, Clic, Clic... (Esc para cancelar)" disabled>
                             <i class="fa-continuous-eraser-line"></i> <!-- Icono personalizado o fas fa-route -->
                        </button>
                         <!-- FIN NUEVO BOTÓN -->
                    </div>
                </div>

                <!-- Opciones Pincel/Borrador/Trazo -->
                <div id="brush-options-section" class="space-y-3">
                     <!-- Ajustado: Mostrar Tamaño siempre que la sección esté visible -->
                    <div><label for="brush-size" class="block text-sm font-medium text-gray-700">Tamaño / Grosor: <span id="brush-size-value">50</span>px</label><input type="range" id="brush-size" min="1" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                     <!-- Fin Ajustado -->
                    <div id="feather-option"><label for="brush-feather" class="block text-sm font-medium text-gray-700">Difuminado: <span id="brush-feather-value">0.10</span></label><input type="range" id="brush-feather" min="0" max="1" step="0.05" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div><label for="brush-opacity" class="block text-sm font-medium text-gray-700">Opacidad: <span id="brush-opacity-value">1.00</span></label><input type="range" id="brush-opacity" min="0.05" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50" disabled></div>
                    <div id="shape-option"><label class="block text-sm font-medium text-gray-700">Forma:</label><div class="flex space-x-2 mt-1"><button id="brush-shape-circle" class="brush-shape p-1 border rounded-full w-6 h-6 bg-gray-700 disabled:opacity-50" title="Circular" disabled></button><button id="brush-shape-square" class="brush-shape p-1 border rounded w-6 h-6 bg-gray-700 disabled:opacity-50" title="Cuadrado" disabled></button></div></div>
                </div>
                <!-- Acciones -->
                <div class="flex space-x-2 pt-4 border-t">
                    <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Deshacer (Ctrl+Z)" disabled> <i class="fas fa-undo"></i> (<span id="undo-count">0</span>) </button>
                    <button id="reset-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Resetear Máscara" disabled> <i class="fas fa-trash-alt"></i> Reset </button>
                </div>
            </div>

            <!-- Exportar / Copiar -->
             <div id="export-section" class="hidden pt-4 border-t space-y-2">
                 <h2 class="text-lg font-semibold mb-2">3. Guardar / Copiar</h2>
                 <button id="export-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed btn-feedback" disabled><i class="fas fa-download mr-1"></i> Exportar PNG</button>
                 <button id="copy-btn" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed btn-feedback" disabled><i class="fas fa-copy mr-1"></i> Copiar Imagen</button>
                 <p id="clipboard-support-warning" class="text-xs text-red-600 text-center hidden">La copia al portapapeles no está soportada o permitida.</p>
             </div>
        </aside>

        <!-- Área de Trabajo -->
        <section class="flex-grow bg-gray-300 rounded-lg shadow overflow-hidden relative checkerboard-bg">
            <div id="canvas-outer-container">
                <div id="canvas-inner-container">
                    <canvas id="image-canvas" class="hidden"></canvas>
                    <canvas id="preview-canvas" class="hidden"></canvas>
                </div>
                <p id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">Carga una imagen para empezar</p>
            </div>
            <div id="loading-spinner" class="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center hidden z-50 pointer-events-none">
                <i class="fas fa-spinner fa-spin fa-3x text-blue-500"></i>
                <p class="text-lg font-semibold ml-3">Cargando...</p>
            </div>
            <!-- Overlay para procesamiento (usado por Flood Fill) -->
            <div id="processing-overlay" class="processing-overlay hidden">
                <i class="fas fa-spinner fa-spin fa-3x"></i>
                <p id="processing-status-text">Procesando...</p>
            </div>
            <div id="status-bar" class="absolute bottom-0 left-0 bg-black bg-opacity-60 text-white text-xs p-1 rounded-tr z-10 pointer-events-none">Zoom: <span id="zoom-level">100</span>% | Herramienta: <span id="current-tool-status">Ninguna</span> | Rueda=Zoom, Espacio+Arrastrar=Mover</div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Cargado - XocoStudio Background Remover");

            // --- DOM Elements ---
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const uploadBtn = document.getElementById('upload-btn');
            const pasteBtn = document.getElementById('paste-btn');
            const pasteSupportWarning = document.getElementById('paste-support-warning');
            const filenameDisplay = document.getElementById('filename-display');
            const canvasOuterContainer = document.getElementById('canvas-outer-container');
            const canvasInnerContainer = document.getElementById('canvas-inner-container');
            const canvas = document.getElementById('image-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const canvasPlaceholder = document.getElementById('canvas-placeholder');
            const loadingSpinner = document.getElementById('loading-spinner');
            const toolsSection = document.getElementById('tools-section');
            const exportSection = document.getElementById('export-section');
            const brushBtn = document.getElementById('brush-tool');
            const eraserBtn = document.getElementById('eraser-tool');
            const lineBtn = document.getElementById('line-tool');
            const eraserLineBtn = document.getElementById('eraser-line-tool');
            const continuousEraserLineBtn = document.getElementById('continuous-eraser-line-tool'); // <-- Nuevo Botón
            const brushOptionsSection = document.getElementById('brush-options-section');
            const featherOptionDiv = document.getElementById('feather-option');
            const shapeOptionDiv = document.getElementById('shape-option');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushFeatherSlider = document.getElementById('brush-feather');
            const brushFeatherValue = document.getElementById('brush-feather-value');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            const brushOpacityValue = document.getElementById('brush-opacity-value');
            const shapeCircleBtn = document.getElementById('brush-shape-circle');
            const shapeSquareBtn = document.getElementById('brush-shape-square');
            const undoBtn = document.getElementById('undo-btn');
            const undoCountSpan = document.getElementById('undo-count');
            const resetBtn = document.getElementById('reset-btn');
            const exportBtn = document.getElementById('export-btn');
            const copyBtn = document.getElementById('copy-btn');
            const clipboardSupportWarning = document.getElementById('clipboard-support-warning');
            const zoomLevelSpan = document.getElementById('zoom-level');
            const currentToolSpan = document.getElementById('current-tool-status');
            const processingOverlay = document.getElementById('processing-overlay');
            const processingStatusText = document.getElementById('processing-status-text');
            const removeEdgeBgBtn = document.getElementById('remove-edge-bg-btn');
            const removeInnerHoleBtn = document.getElementById('remove-inner-hole-btn');
            const edgeColorToleranceSlider = document.getElementById('edge-color-tolerance');
            const edgeColorToleranceValueSpan = document.getElementById('edge-color-tolerance-value');

            // --- State Variables ---
            let ctx = null;
            let previewCtx = null;
            let originalImage = null;
            let originalImageDataCache = null;
            let imageFilename = 'imagen';
            let maskCanvas = null;
            let maskCtx = null;
            let isDrawing = false; // Para pincel/borrador normal
            let lastX = 0, lastY = 0;
            let history = [];
            const MAX_HISTORY = 30;
            let currentTool = 'eraser';
            let brushOptions = { size: 50, feather: 0.1, opacity: 1.0, shape: 'circle' };
            let zoomLevel = 1.0;
            let panX = 0, panY = 0;
            let isPanning = false;
            let panStartX = 0, panStartY = 0;
            let isSpacePressed = false;
            let isDrawingLine = false; // Para línea simple (inicio/fin)
            let lineStartX = 0, lineStartY = 0;
            let isDrawingContinuousLine = false; // <-- Nuevo estado para línea continua
            let lastContinuousLinePoint = null; // <-- Nuevo estado {x, y}
            let currentMousePos = { x: 0, y: 0 };
            let isClipboardWriteSupported = !!(navigator.clipboard && navigator.clipboard.write);
            let isClipboardReadSupported = !!(navigator.clipboard && navigator.clipboard.read);
            let isFloodFilling = false;
            let cancelFloodFillRequest = false;
            let waitingForInnerHoleClick = false;
            let holeRemoverFeedbackTimeout = null;

            // Performance Throttling
            let lastRenderTime = 0;
            const RENDER_THROTTLE = 16; // ms, approx 60fps

            // --- Verification ---
            if (!canvas || !previewCanvas || !dropZone || !fileInput || !uploadBtn || !pasteBtn || !removeEdgeBgBtn || !removeInnerHoleBtn || !continuousEraserLineBtn) { // Added check for new button
                console.error("¡ERROR CRÍTICO! No se encontraron uno o más elementos esenciales del DOM. Verifica los IDs.");
                alert("Error: La aplicación no pudo iniciarse correctamente.");
                return;
            }
            console.log("Elementos DOM principales OK.");

            // --- Initialization ---
            setActiveTool('eraser');
            updateToolOptionsDisplay();
            updateActionButtonsState();
            setupImageLoadingListeners();
            setupInteractionListeners();
            setupToolControlListeners();
            checkClipboardSupport();
            console.log("Inicialización completada.");

            // --- Helper Function to Cancel Continuous Line ---
            function cancelContinuousLineDrawing(silent = false) {
                if (isDrawingContinuousLine) {
                    if (!silent) console.log("Cancelando trazo borrador continuo.");
                    isDrawingContinuousLine = false;
                    lastContinuousLinePoint = null;
                    clearPreviewCanvas(); // Clear any markers
                    // No need to change tool, just reset state
                    updateStatusBar();
                    canvasOuterContainer.style.cursor = getToolCursor();
                }
            }

            // --- Setup Functions ---
            function setupImageLoadingListeners() {
                console.log("Configurando listeners de carga...");
                dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); });
                dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500', 'bg-blue-50'); });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                    const file = e.dataTransfer?.files?.[0];
                    if (file?.type.startsWith('image/')) {
                        handleFile(file);
                    } else if (file) { alert('Por favor, suelta un archivo de imagen válido.'); }
                });
                uploadBtn.addEventListener('click', () => fileInput.click());
                pasteBtn.addEventListener('click', handlePasteButtonClick);
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files?.[0];
                    if (file?.type.startsWith('image/')) {
                        handleFile(file);
                        e.target.value = null;
                    } else if (file) { alert('Por favor, selecciona un archivo de imagen válido.'); }
                });
                window.addEventListener('paste', (e) => {
                    const activeElement = document.activeElement;
                    if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable) return;
                    if (handleClipboardPaste(e.clipboardData)) e.preventDefault();
                });
                console.log("Listeners de carga añadidos.");
            }

            function setupInteractionListeners() {
                window.addEventListener('keydown', handleKeyDown); // <-- Keydown listener
                window.addEventListener('keyup', handleKeyUp);
                canvasOuterContainer.addEventListener('mousedown', handleInteractionStart);
                canvasOuterContainer.addEventListener('mousemove', handleInteractionMove);
                window.addEventListener('mouseup', handleInteractionEnd);
                canvasOuterContainer.addEventListener('touchstart', (e) => handleInteractionStart(e.touches[0]), { passive: false });
                canvasOuterContainer.addEventListener('touchmove', (e) => handleInteractionMove(e.touches[0]), { passive: false });
                window.addEventListener('touchend', (e) => handleInteractionEnd(e.changedTouches[0]));
                window.addEventListener('touchcancel', (e) => handleInteractionEnd(e.changedTouches[0]));
                canvasOuterContainer.addEventListener('wheel', handleWheelZoom, { passive: false });
                canvasOuterContainer.addEventListener('mouseleave', () => {
                    clearPreviewCanvas();
                    // No cancelamos trazo continuo al salir, solo limpiamos preview
                });
            }

            function setupToolControlListeners() {
                console.log("Configurando listeners de herramientas...");
                brushBtn.addEventListener('click', () => setActiveTool('brush'));
                eraserBtn.addEventListener('click', () => setActiveTool('eraser'));
                lineBtn.addEventListener('click', () => setActiveTool('line'));
                eraserLineBtn.addEventListener('click', () => setActiveTool('eraser-line'));
                continuousEraserLineBtn.addEventListener('click', () => setActiveTool('continuous-eraser-line')); // <-- Nuevo Listener
                brushSizeSlider.addEventListener('input', (e) => { brushOptions.size = parseInt(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y);});
                brushFeatherSlider.addEventListener('input', (e) => { brushOptions.feather = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                brushOpacitySlider.addEventListener('input', (e) => { brushOptions.opacity = parseFloat(e.target.value); updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                shapeCircleBtn.addEventListener('click', () => { brushOptions.shape = 'circle'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                shapeSquareBtn.addEventListener('click', () => { brushOptions.shape = 'square'; updateToolOptionsDisplay(); drawBrushPreview(currentMousePos.x, currentMousePos.y); });
                undoBtn.addEventListener('click', undo);
                resetBtn.addEventListener('click', () => {
                    if (!originalImage || history.length <= 1) return;
                    if (confirm('¿Resetear todas las ediciones? Esta acción no se puede deshacer.')) {
                        if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                        cancelContinuousLineDrawing(true); // Cancelar trazo silenciosamente
                        resetMask();
                    }
                 });
                exportBtn.addEventListener('click', exportImage);
                copyBtn.addEventListener('click', copyImageToClipboard);
                edgeColorToleranceSlider.addEventListener('input', (e) => edgeColorToleranceValueSpan.textContent = e.target.value);

                removeEdgeBgBtn.addEventListener('click', () => {
                    if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                    cancelContinuousLineDrawing(true); // Cancelar trazo antes de acción auto
                    if (isFloodFilling) {
                        console.log("%cSolicitando cancelación de Flood Fill...", 'color: orange; font-weight: bold;');
                        cancelFloodFillRequest = true;
                        processingStatusText.textContent = "Cancelando...";
                        showButtonFeedback(removeEdgeBgBtn, 'cancelling', 'Cancelando...', 60000);
                    } else {
                        handleRemoveBackgroundByFloodFill();
                    }
                });

                removeInnerHoleBtn.addEventListener('click', () => {
                    if (isFloodFilling) return;
                    cancelContinuousLineDrawing(true); // Cancelar trazo al activar modo hueco
                    if (waitingForInnerHoleClick) {
                         cancelInnerHoleClickMode();
                    } else {
                        activateInnerHoleClickMode();
                    }
                });

                console.log("Listeners de herramientas añadidos.");
            }

            // --- Core Logic ---
            function handleFile(file) {
                 console.log('>>> handleFile:', file?.name);
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true); // Cancelar trazo al cargar nueva imagen
                if (!file?.type?.startsWith('image/')) {
                    alert('Archivo no válido. Selecciona una imagen.');
                    console.error('Tipo inválido:', file?.type);
                    return;
                }
                const reader = new FileReader();
                reader.onloadstart = () => { console.log('   reader.onloadstart'); showLoadingState(file.name); }
                reader.onload = (e) => {
                    console.log('   reader.onload');
                    if (!e.target?.result) { handleLoadingError(file.name, 'Error al leer.'); return; }
                    originalImage = new Image();
                    originalImage.onload = () => {
                        console.log(`      originalImage.onload OK: ${originalImage.naturalWidth}x${originalImage.naturalHeight}`);
                        if (originalImage.naturalWidth === 0 || originalImage.naturalHeight === 0) {
                            handleLoadingError(file.name, 'Dimensiones inválidas (0x0).'); originalImage = null; return;
                        }
                        initializeEditor(file.name, originalImage);
                    };
                    originalImage.onerror = (err) => { console.error('originalImage.onerror:', err); handleLoadingError(file.name, 'Error al decodificar. ¿Formato soportado?'); originalImage = null; };
                    originalImage.src = e.target.result;
                };
                reader.onerror = (err) => { console.error('reader.onerror:', err); handleLoadingError(file.name, 'Error de lectura.'); };
                try { reader.readAsDataURL(file); } catch (error) { console.error("Error readAsDataURL:", error); handleLoadingError(file.name, 'Error iniciando lectura.'); }
            }

            function showLoadingState(fileName) {
                console.log("Mostrando carga:", fileName);
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true); // Cancelar trazo
                loadingSpinner.classList.remove('hidden');
                canvasPlaceholder.classList.add('hidden');
                filenameDisplay.textContent = `Cargando: ${fileName}...`;
                toolsSection.classList.add('hidden');
                exportSection.classList.add('hidden');
                canvas.classList.add('hidden');
                previewCanvas.classList.add('hidden');
                originalImage = null;
                originalImageDataCache = null;
                ctx = previewCtx = maskCtx = null;
                history = [];
                updateActionButtonsState();
            }

            function handleLoadingError(fileName, message) {
                console.error(`Error cargando ${fileName || 'imagen'}: ${message}`);
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true); // Cancelar trazo
                alert(`Error al cargar "${fileName || ''}":\n${message}`);
                loadingSpinner.classList.add('hidden');
                canvasPlaceholder.classList.remove('hidden');
                filenameDisplay.textContent = `Error al cargar`;
                originalImage = null;
                originalImageDataCache = null;
                ctx = previewCtx = maskCtx = null;
                history = [];
                updateActionButtonsState();
            }

            function initializeEditor(fileName, loadedImage) {
                 console.log(">>> initializeEditor:", fileName);
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true); // Cancelar trazo
                 if (!loadedImage || !loadedImage.naturalWidth || !loadedImage.naturalHeight) {
                     handleLoadingError(fileName, "Datos de imagen inválidos."); return;
                 }
                 imageFilename = fileName.replace(/\.[^/.]+$/, "") || 'imagen_editada';
                 filenameDisplay.textContent = `Editando: ${fileName} (${loadedImage.naturalWidth}x${loadedImage.naturalHeight})`;

                 try {
                    ctx = canvas.getContext('2d', { willReadFrequently: false });
                    previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
                    if (!ctx || !previewCtx) throw new Error("getContext devolvió null.");
                    console.log("   Contextos ctx y previewCtx OK.");
                 } catch (e) {
                     console.error("¡ERROR FATAL obteniendo contextos principales!:", e);
                     handleLoadingError(fileName, "Error interno: No se pudo crear contexto gráfico."); return;
                 }

                 if (!setupCanvases(loadedImage)) {
                     handleLoadingError(fileName, "Error configurando canvas."); return;
                 }
                 cacheOriginalImageData();
                 resetMask();
                 centerAndFitImage();
                 requestRender();

                 toolsSection.classList.remove('hidden');
                 exportSection.classList.remove('hidden');
                 canvas.classList.remove('hidden');
                 previewCanvas.classList.remove('hidden');
                 loadingSpinner.classList.add('hidden');
                 canvasPlaceholder.classList.add('hidden');
                 setActiveTool(currentTool);
                 updateActionButtonsState();
                 console.log("<<< initializeEditor completado.");
            }

             function setupCanvases(img) {
                 console.log(">>> setupCanvases");
                 if (!img?.naturalWidth || !img?.naturalHeight) { console.error("   Imagen inválida."); return false; }
                 if (!canvas || !previewCanvas || !canvasInnerContainer) { console.error("   Faltan elementos canvas."); return false; }

                 const w = img.naturalWidth; const h = img.naturalHeight;
                 canvas.width = w; canvas.height = h;
                 previewCanvas.width = w; previewCanvas.height = h;
                 canvasInnerContainer.style.width = `${w}px`; canvasInnerContainer.style.height = `${h}px`;

                 try {
                      maskCanvas = document.createElement('canvas');
                      maskCanvas.width = w; maskCanvas.height = h;
                      maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
                      if (!maskCtx) throw new Error("maskCtx es null.");
                      console.log("   Contexto maskCtx OK.");
                 } catch (e) {
                     alert("Error fatal: No se pudo crear canvas interno para máscara.");
                     console.error("   Error creando maskCtx:", e);
                     maskCanvas = maskCtx = null; return false;
                 }
                 console.log(`   Canvases configurados a ${w}x${h}`);
                 return true;
             }

             function cacheOriginalImageData() {
                if (!originalImage || !canvas || !maskCanvas) {
                    originalImageDataCache = null;
                    console.warn("No se pudo cachear ImageData original: faltan elementos.");
                    return;
                }
                console.log("Cacheando ImageData original...");
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImage.naturalWidth;
                tempCanvas.height = originalImage.naturalHeight;
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                if (!tempCtx) {
                    console.error("Error creando contexto temporal para cachear ImageData.");
                    originalImageDataCache = null;
                    return;
                }
                try {
                    tempCtx.drawImage(originalImage, 0, 0);
                    originalImageDataCache = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    console.log("   ImageData original cacheada OK.");
                } catch (e) {
                    console.error("Error al obtener ImageData original para cache:", e);
                    originalImageDataCache = null;
                }
             }

            function centerAndFitImage() {
                if (!originalImage || !canvasOuterContainer) return;
                const imgWidth = originalImage.naturalWidth; const imgHeight = originalImage.naturalHeight;
                const contWidth = canvasOuterContainer.clientWidth; const contHeight = canvasOuterContainer.clientHeight;
                zoomLevel = Math.min(contWidth / imgWidth, contHeight / imgHeight) * 0.95;
                panX = (contWidth - imgWidth * zoomLevel) / 2;
                panY = (contHeight - imgHeight * zoomLevel) / 2;
                updateTransform(); updateStatusBar();
                console.log(`Imagen centrada/ajustada: zoom=${zoomLevel.toFixed(2)}, panX=${panX.toFixed(0)}, panY=${panY.toFixed(0)}`);
             }

            function resetMask() {
                 if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                 cancelContinuousLineDrawing(true); // Cancelar trazo
                if (!maskCtx || !maskCanvas || !originalImage) return;
                console.log("Reseteando máscara a blanco (opaco).");
                maskCtx.fillStyle = 'white';
                maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
                history = [];
                saveStateToHistory();
                updateActionButtonsState();
                requestRender();
            }

            function requestRender() {
                const now = performance.now();
                if (now - lastRenderTime >= RENDER_THROTTLE) { renderCanvas(); lastRenderTime = now; }
            }

            function renderCanvas() {
                if (!ctx || !originalImage || !maskCanvas) return;
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(originalImage, 0, 0);
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(maskCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            }

            function clearPreviewCanvas() { if (previewCtx) previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height); }

            function drawBrushPreview(imageX, imageY) {
                // Don't draw preview if hole clicking, panning, or using line tools
                if (!previewCtx || isPanning || waitingForInnerHoleClick || currentTool === 'line' || currentTool === 'eraser-line' || currentTool === 'continuous-eraser-line' || isDrawingLine) {
                    clearPreviewCanvas();
                    return;
                }
                clearPreviewCanvas();
                const size = brushOptions.size * zoomLevel; const featherAmount = size * brushOptions.feather;
                const solidRadius = size / 2 - featherAmount / 2; const totalRadius = size / 2;
                const screenX = imageX * zoomLevel + panX; const screenY = imageY * zoomLevel + panY;
                const previewX = (screenX - panX) / zoomLevel; const previewY = (screenY - panY) / zoomLevel;
                previewCtx.save(); previewCtx.globalAlpha = 0.6;
                if (brushOptions.shape === 'circle') {
                    const gradient = previewCtx.createRadialGradient(previewX, previewY, Math.max(0, solidRadius / zoomLevel), previewX, previewY, totalRadius / zoomLevel);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    previewCtx.fillStyle = gradient; previewCtx.beginPath(); previewCtx.arc(previewX, previewY, totalRadius / zoomLevel, 0, Math.PI * 2); previewCtx.fill();
                } else {
                    const previewSize = brushOptions.size; const halfSize = previewSize / 2;
                    previewCtx.fillStyle = 'rgba(0, 0, 0, 0.6)'; previewCtx.fillRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize);
                    previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; previewCtx.lineWidth = 1 / zoomLevel;
                    previewCtx.strokeRect(previewX - halfSize, previewY - halfSize, previewSize, previewSize);
                }
                previewCtx.restore();
            }

            function drawLinePreview(startX, startY, endX, endY) {
                 if (!previewCtx || waitingForInnerHoleClick || currentTool === 'continuous-eraser-line') return; // No preview for continuous line yet
                 clearPreviewCanvas(); previewCtx.save(); previewCtx.beginPath();
                 previewCtx.moveTo(startX, startY); previewCtx.lineTo(endX, endY);
                 previewCtx.strokeStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                 previewCtx.lineWidth = Math.max(1 / zoomLevel, brushOptions.size * 0.1); // Thin preview line
                 previewCtx.setLineDash([5 / zoomLevel, 5 / zoomLevel]); previewCtx.stroke(); previewCtx.restore();
            }

            function applyMaskModification(drawX, drawY, tool, options) {
                if (!maskCtx) return;
                const isEraser = tool === 'eraser' || tool === 'eraser-line' || tool === 'continuous-eraser-line'; // Include new tool
                maskCtx.save();
                maskCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
                const size = options.size; const halfSize = size / 2;
                const feather = options.feather; const opacity = options.opacity;
                if (options.shape === 'circle') {
                    const solidRadius = halfSize * (1 - feather);
                    const gradient = maskCtx.createRadialGradient(drawX, drawY, solidRadius, drawX, drawY, halfSize);
                    if (isEraser) { gradient.addColorStop(0, `rgba(0,0,0, ${opacity})`); gradient.addColorStop(1, 'rgba(0,0,0, 0)'); }
                    else { gradient.addColorStop(0, `rgba(255,255,255, ${opacity})`); gradient.addColorStop(1, 'rgba(255,255,255, 0)'); }
                    maskCtx.fillStyle = gradient; maskCtx.beginPath(); maskCtx.arc(drawX, drawY, halfSize, 0, Math.PI * 2); maskCtx.fill();
                } else {
                    maskCtx.fillStyle = isEraser ? `rgba(0,0,0, ${opacity})` : `rgba(255,255,255, ${opacity})`;
                    maskCtx.fillRect(drawX - halfSize, drawY - halfSize, size, size);
                }
                maskCtx.restore();
            }

            function getInteractionPos(evt) {
                if (!canvasOuterContainer) return { screenX:0, screenY:0, imageX: 0, imageY: 0 };
                const rect = canvasOuterContainer.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.pageX; const clientY = evt.clientY ?? evt.pageY;
                const screenX = clientX - rect.left; const screenY = clientY - rect.top;
                const imageX = (screenX - panX) / zoomLevel; const imageY = (screenY - panY) / zoomLevel;
                return { screenX, screenY, imageX, imageY };
            }

            function handleInteractionStart(e) {
                 if (!originalImage || isFloodFilling) return;
                 if (e.preventDefault && e.cancelable) e.preventDefault();
                 const { screenX, screenY, imageX, imageY } = getInteractionPos(e);

                 // --- Handle Inner Hole Click First ---
                 if (waitingForInnerHoleClick) {
                     console.log(`Click detectado para eliminar hueco en: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                     removeInnerHoleAt(imageX, imageY);
                     return;
                 }

                 // --- Panning ---
                 if (isSpacePressed) {
                    isPanning = true; panStartX = screenX - panX; panStartY = screenY - panY;
                    canvasOuterContainer.style.cursor = 'grabbing';
                    return; // Don't process other tools if panning
                 }

                 // --- Tool Specific Logic ---
                 switch (currentTool) {
                    case 'line':
                    case 'eraser-line':
                        if (!isDrawingLine) {
                            isDrawingLine = true; lineStartX = imageX; lineStartY = imageY;
                            console.log(`Inicio línea (${currentTool}) en: ${lineStartX.toFixed(0)}, ${lineStartY.toFixed(0)}`);
                            clearPreviewCanvas(); previewCtx.fillStyle = (currentTool === 'line') ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                            previewCtx.beginPath(); previewCtx.arc(lineStartX, lineStartY, 5 / zoomLevel, 0, Math.PI * 2); previewCtx.fill();
                            canvasOuterContainer.style.cursor = 'crosshair';
                        } else {
                            console.log(`Fin línea (${currentTool}) en: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                            drawLineOnMask(lineStartX, lineStartY, imageX, imageY, currentTool, brushOptions);
                            saveStateToHistory(); requestRender(); isDrawingLine = false; clearPreviewCanvas();
                            setActiveTool(currentTool); // Resets cursor etc.
                        }
                        break;

                    case 'continuous-eraser-line': // <-- NUEVA LÓGICA
                         if (!isDrawingContinuousLine) {
                             // Primer clic: Inicia el trazo
                             isDrawingContinuousLine = true;
                             lastContinuousLinePoint = { x: imageX, y: imageY };
                             console.log(`Inicio Trazo Continuo en: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                             // Opcional: Dibujar marcador inicial en previewCanvas
                             previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // Rojo para indicar inicio/activo
                             previewCtx.beginPath();
                             previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2);
                             previewCtx.fill();
                         } else {
                             // Clics subsiguientes: Dibujar segmento desde el último punto
                             console.log(`Segmento Trazo Continuo a: ${imageX.toFixed(0)}, ${imageY.toFixed(0)}`);
                             drawLineOnMask(lastContinuousLinePoint.x, lastContinuousLinePoint.y, imageX, imageY, currentTool, brushOptions); // Usa la herramienta actual ('continuous-eraser-line') que es tratada como borrador
                             lastContinuousLinePoint = { x: imageX, y: imageY }; // Actualizar último punto
                             saveStateToHistory(); // Guardar después de cada segmento
                             requestRender();
                             // Opcional: Actualizar marcador en previewCanvas si se desea
                             clearPreviewCanvas(); // Limpiar marcador anterior
                             previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                             previewCtx.beginPath();
                             previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2);
                             previewCtx.fill();
                         }
                         canvasOuterContainer.style.cursor = 'crosshair';
                         break;

                    case 'brush':
                    case 'eraser':
                    default: // Pincel o Borrador
                         // Asegurarse de cancelar otros modos de línea si se empieza a pintar
                         if(isDrawingLine) isDrawingLine = false;
                         cancelContinuousLineDrawing(true); // Cancelar trazo continuo silenciosamente

                         isDrawing = true; lastX = imageX; lastY = imageY;
                         applyMaskModification(imageX, imageY, currentTool, brushOptions);
                         // requestRender(); // Renderizar en move para más fluidez
                         canvasOuterContainer.style.cursor = 'crosshair';
                         break;
                 }
            }

            function handleInteractionMove(e) {
                 if (!originalImage || isFloodFilling || waitingForInnerHoleClick) return;
                 const { screenX, screenY, imageX, imageY } = getInteractionPos(e);
                 currentMousePos = { x: imageX, y: imageY };

                 if (isPanning) {
                    panX = screenX - panStartX; panY = screenY - panStartY;
                    updateTransform(); updateStatusBar();
                 } else if (isDrawing) { // Moviendo con pincel/borrador normal presionado
                    drawLineOnMask(lastX, lastY, imageX, imageY, currentTool, brushOptions);
                    lastX = imageX; lastY = imageY; requestRender();
                    drawBrushPreview(imageX, imageY);
                 } else if (isDrawingLine) { // Moviendo mientras se define línea simple
                    drawLinePreview(lineStartX, lineStartY, imageX, imageY);
                 } else if (isDrawingContinuousLine) { // Moviendo mientras se define línea continua (solo mostramos marcador)
                     // Por ahora, no dibujamos preview de línea al siguiente punto.
                     // Solo aseguramos que el marcador del último punto esté visible si lo dibujamos.
                     // drawLinePreview(lastContinuousLinePoint.x, lastContinuousLinePoint.y, imageX, imageY); // Podría añadirse si se quiere
                     clearPreviewCanvas(); // Limpiar previews anteriores
                     if(lastContinuousLinePoint) { // Redibujar marcador último punto
                         previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                         previewCtx.beginPath();
                         previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2);
                         previewCtx.fill();
                     }
                 } else { // Solo moviendo el cursor, mostrar preview de pincel si aplica
                    drawBrushPreview(imageX, imageY);
                 }
            }

            function handleInteractionEnd(e) {
                if (isPanning) {
                    isPanning = false; canvasOuterContainer.style.cursor = getToolCursor();
                } else if (isDrawing) { // Finaliza trazo de pincel/borrador normal
                    isDrawing = false;
                    saveStateToHistory(); // Guardar estado al soltar
                    clearPreviewCanvas();
                    drawBrushPreview(currentMousePos.x, currentMousePos.y); // Mostrar preview final
                }
                // Para línea simple (isDrawingLine) y línea continua (isDrawingContinuousLine),
                // la acción se completa en el segundo clic (o clics subsiguientes),
                // no al soltar el botón.
            }

             function drawLineOnMask(imgX1, imgY1, imgX2, imgY2, tool, options) {
                 if (!maskCtx) return;
                 // Determinar si la herramienta actual debe borrar
                 const isEraserTool = tool === 'eraser' || tool === 'eraser-line' || tool === 'continuous-eraser-line';
                 const size = options.size; const opacity = options.opacity;

                 maskCtx.save();
                 maskCtx.globalCompositeOperation = isEraserTool ? 'destination-out' : 'source-over'; // destination-out para borrar
                 maskCtx.beginPath();
                 maskCtx.moveTo(imgX1, imgY1);
                 maskCtx.lineTo(imgX2, imgY2);
                 maskCtx.lineWidth = size; // Usar el tamaño como grosor de línea
                 maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
                 // El color no importa para destination-out, pero sí la opacidad
                 maskCtx.strokeStyle = isEraserTool ? `rgba(0, 0, 0, ${opacity})` : `rgba(255, 255, 255, ${opacity})`;
                 maskCtx.stroke();
                 maskCtx.restore();
             }

            function setActiveTool(tool) {
                 // Cancelar modos activos si se cambia de herramienta
                 if (tool !== 'hole-remover' && waitingForInnerHoleClick) {
                     cancelInnerHoleClickMode();
                 }
                 if (tool !== 'line' && tool !== 'eraser-line' && isDrawingLine) {
                     isDrawingLine = false; clearPreviewCanvas(); console.log("Línea simple cancelada por cambio de herramienta.");
                 }
                 if (tool !== 'continuous-eraser-line' && isDrawingContinuousLine) {
                    cancelContinuousLineDrawing(); // Usar la función helper
                 }

                 currentTool = tool; console.log("Herramienta activa:", tool);
                 // Quitar clase activa de todos los botones de herramientas manuales
                 [brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousEraserLineBtn].forEach(btn => btn.classList.remove('active-tool'));

                 // Añadir clase activa al botón seleccionado (si es una herramienta manual)
                  const manualTools = ['brush', 'eraser', 'line', 'eraser-line', 'continuous-eraser-line'];
                 if (manualTools.includes(tool)) {
                    const activeBtn = document.getElementById(`${tool}-tool`);
                    if (activeBtn) activeBtn.classList.add('active-tool');
                 }
                 // La clase activa para 'hole-remover' se maneja por separado

                 // Configurar visibilidad de opciones
                 const isBrushOrEraser = tool === 'brush' || tool === 'eraser';
                 const isAnyLineTool = tool === 'line' || tool === 'eraser-line' || tool === 'continuous-eraser-line';
                 const showBrushOptionsPanel = isBrushOrEraser || isAnyLineTool;

                 brushOptionsSection.style.display = showBrushOptionsPanel ? 'block' : 'none';
                 // Opciones específicas
                 featherOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none'; // Solo para pincel/borrador
                 shapeOptionDiv.style.display = isBrushOrEraser ? 'block' : 'none'; // Solo para pincel/borrador
                 // Opacidad y Tamaño/Grosor se muestran para todos los que usan el panel

                 canvasOuterContainer.style.cursor = getToolCursor();
                 updateStatusBar();
                 updateToolOptionsDisplay(); // Actualizar valores mostrados
                 clearPreviewCanvas(); // Limpiar preview al cambiar
                 if (isDrawingContinuousLine && lastContinuousLinePoint) { // Redibujar marcador si se vuelve a la herramienta
                     previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                     previewCtx.beginPath();
                     previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2);
                     previewCtx.fill();
                 }
            }

             function getToolCursor() {
                 if (waitingForInnerHoleClick) return 'crosshair';
                 if (isSpacePressed) return 'grab';
                 if (isPanning) return 'grabbing';
                 if (isDrawingLine || currentTool === 'line' || currentTool === 'eraser-line' || currentTool === 'continuous-eraser-line') return 'crosshair'; // Usar crosshair para todas las líneas y trazos
                 return 'crosshair'; // Usar crosshair para pincel/borrador también
             }

            function updateToolOptionsDisplay() {
                brushSizeValue.textContent = brushOptions.size;
                brushFeatherValue.textContent = brushOptions.feather.toFixed(2);
                brushOpacityValue.textContent = brushOptions.opacity.toFixed(2);
                shapeCircleBtn.classList.toggle('active-shape', brushOptions.shape === 'circle');
                shapeSquareBtn.classList.toggle('active-shape', brushOptions.shape === 'square');
            }

            // --- History & State ---
            function updateActionButtonsState() {
                 const imageLoaded = !!originalImage && !!ctx && !!maskCtx;
                 const canUndo = history.length > 1;
                 const isEditingManually = isDrawing || isDrawingLine || isDrawingContinuousLine; // Check if any manual edit is in progress

                 // Standard buttons
                 undoBtn.disabled = !canUndo || isFloodFilling || waitingForInnerHoleClick || isEditingManually; // Disable if drawing line/trace
                 undoCountSpan.textContent = Math.max(0, history.length - 1);
                 resetBtn.disabled = !imageLoaded || !canUndo || isFloodFilling || waitingForInnerHoleClick || isEditingManually; // Disable if drawing line/trace
                 exportBtn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick || isEditingManually;
                 copyBtn.disabled = !imageLoaded || !isClipboardWriteSupported || isFloodFilling || waitingForInnerHoleClick || isEditingManually;
                 pasteBtn.disabled = !isClipboardReadSupported || isFloodFilling || waitingForInnerHoleClick || isEditingManually;

                 // Manual tools buttons
                 [brushBtn, eraserBtn, lineBtn, eraserLineBtn, continuousEraserLineBtn].forEach(btn => btn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick); // Don't disable based on isEditingManually, allow switching

                 // Controls within options panel
                 [brushSizeSlider, brushFeatherSlider, brushOpacitySlider, shapeCircleBtn, shapeSquareBtn].forEach(control => control.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick || isEditingManually); // Disable sliders if drawing

                 // Auto tools
                 removeEdgeBgBtn.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick || isEditingManually;
                 removeInnerHoleBtn.disabled = !imageLoaded || isFloodFilling || isEditingManually; // Allow cancelling hole mode, so don't check waitingForInnerHoleClick here
                 edgeColorToleranceSlider.disabled = !imageLoaded || isFloodFilling || waitingForInnerHoleClick || isEditingManually;
            }

            function checkClipboardSupport() {
                 if (!isClipboardReadSupported) { pasteSupportWarning.classList.remove('hidden'); pasteBtn.disabled = true; pasteBtn.title = "Pegar no soportado/permitido."; console.warn("Clipboard API (read) no soportada."); }
                 else { pasteSupportWarning.classList.add('hidden'); }
                 if (!isClipboardWriteSupported) { clipboardSupportWarning.classList.remove('hidden'); copyBtn.disabled = true; copyBtn.title = "Copiar no soportado/permitido."; console.warn("Clipboard API (write) no soportada."); }
                 else { clipboardSupportWarning.classList.add('hidden'); }
            }

            function saveStateToHistory() {
                 if (!maskCtx || !maskCanvas) return;
                 // console.log("Guardando historial..."); // Reduce log noise
                 history.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
                 if (history.length > MAX_HISTORY + 1) { history.shift(); }
                 // console.log(`   Historial: ${history.length} estados.`);
                 updateActionButtonsState();
            }

            function undo() {
                if (history.length <= 1 || isFloodFilling || waitingForInnerHoleClick || isDrawingLine || isDrawingContinuousLine) return; // Prevent undo while drawing lines
                console.log("Deshaciendo..."); history.pop();
                const previousState = history[history.length - 1];
                maskCtx.putImageData(previousState, 0, 0); requestRender(); updateActionButtonsState();
                console.log(`   Restaurado estado ${history.length}.`);
            }

            // --- Zoom/Pan ---
            function handleWheelZoom(e) {
                if (!originalImage || isFloodFilling || waitingForInnerHoleClick || isDrawingLine || isDrawingContinuousLine) return; // Prevent zoom while drawing lines
                e.preventDefault();
                const { screenX, screenY } = getInteractionPos(e);
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                zoomInOut(zoomFactor, screenX, screenY);
            }
            function updateTransform() { if (canvasInnerContainer) canvasInnerContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`; }
            function updateStatusBar() {
                zoomLevelSpan.textContent = Math.round(zoomLevel * 100);
                let toolName = 'Ninguna';
                if (waitingForInnerHoleClick) {
                    toolName = 'Eliminar Hueco (Clic)';
                } else {
                    switch (currentTool) {
                         case 'brush': toolName = 'Pincel'; break;
                         case 'eraser': toolName = 'Borrador'; break;
                         case 'line': toolName = 'Línea (Guardar)'; break;
                         case 'eraser-line': toolName = 'Línea (Borrar)'; break;
                         case 'continuous-eraser-line': toolName = 'Trazo Borrador'; break; // <-- Nuevo nombre
                     }
                    if (isDrawingLine || isDrawingContinuousLine) toolName += ' (dibujando)'; // Indicate drawing state for both line types
                 }
                 currentToolSpan.textContent = toolName;
            }

            // --- Keyboard Handling ---
            function handleKeyDown(e) {
                 // Escape Key Logic
                 if (e.key === 'Escape') {
                    if (waitingForInnerHoleClick) {
                        cancelInnerHoleClickMode(); e.preventDefault(); return;
                    } else if (isDrawingLine) { // Cancel regular line drawing
                        isDrawingLine = false; clearPreviewCanvas(); setActiveTool(currentTool); // Reset cursor etc.
                        console.log("Dibujo de línea cancelado (Esc)."); e.preventDefault(); return;
                    } else if (isDrawingContinuousLine) { // Cancel continuous line drawing
                        cancelContinuousLineDrawing(); // Use helper
                        setActiveTool(currentTool); // Reset cursor etc.
                         e.preventDefault(); return;
                    }
                 }

                 // --- Space Key for Panning (prevent if drawing lines/strokes) ---
                 // Check active drawing state directly here
                 const isCurrentlyDrawingOrLiningForSpace = isDrawing || isDrawingLine || isDrawingContinuousLine;
                 if (e.key === ' ' && !isSpacePressed && !e.repeat && !waitingForInnerHoleClick && !isCurrentlyDrawingOrLiningForSpace) {
                    isSpacePressed = true;
                    if (!isPanning) canvasOuterContainer.style.cursor = 'grab';
                    e.preventDefault(); // Prevent page scroll when panning
                 }

                 // --- Undo (Ctrl+Z) ---
                 // Check if NOT actively drawing/lining/stroking before allowing undo
                 const isCurrentlyDrawingOrLiningForUndo = isDrawing || isDrawingLine || isDrawingContinuousLine;
                 if (e.ctrlKey && e.key.toLowerCase() === 'z' && !e.repeat) {
                    if (!isCurrentlyDrawingOrLiningForUndo && !isFloodFilling && !waitingForInnerHoleClick) {
                         e.preventDefault();
                         undo();
                    } else {
                         console.log("Undo bloqueado mientras se dibuja, procesa o espera clic.");
                    }
                 }

                 // --- Tool Shortcuts (B, E, L, Shift+L, X) ---
                 // Check if NOT actively drawing/lining/stroking AND focus is not on an input/textarea
                 const isCurrentlyDrawingOrLiningForShortcut = isDrawing || isDrawingLine || isDrawingContinuousLine;
                 const isFocusOnInput = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable;

                 if (!e.ctrlKey && !e.altKey && !e.metaKey && !isCurrentlyDrawingOrLiningForShortcut && !isFocusOnInput && !isFloodFilling && !waitingForInnerHoleClick) {
                     switch(e.key.toLowerCase()) {
                        case 'b': setActiveTool('brush'); e.preventDefault(); break;
                        case 'e': setActiveTool('eraser'); e.preventDefault(); break;
                        case 'l': setActiveTool(e.shiftKey ? 'eraser-line' : 'line'); e.preventDefault(); break;
                        case 'x': setActiveTool('continuous-eraser-line'); e.preventDefault(); break;
                        // 'h' para hole remover? Podría ser:
                        // case 'h':
                        //    if (removeInnerHoleBtn.disabled) break;
                        //    if (waitingForInnerHoleClick) cancelInnerHoleClickMode();
                        //    else activateInnerHoleClickMode();
                        //    e.preventDefault();
                        //    break;
                     }
                 }
            }

            function handleKeyUp(e) {
                 if (e.key === ' ') {
                     isSpacePressed = false;
                     // Restore cursor only if not currently panning (mouse button might still be down)
                     if (!isPanning) {
                        canvasOuterContainer.style.cursor = getToolCursor();
                     }
                     // It's generally safe to prevent default for space keyup too if space was pressed
                     // to avoid potential unwanted actions after panning.
                     e.preventDefault();
                 }
            }

             function zoomInOut(factor, pivotX, pivotY) {
                 if (!originalImage) return; const newZoomLevel = Math.max(0.1, Math.min(zoomLevel * factor, 15));
                 if (newZoomLevel === zoomLevel) return; const dx = (pivotX - panX) * (newZoomLevel / zoomLevel - 1);
                 const dy = (pivotY - panY) * (newZoomLevel / zoomLevel - 1); panX -= dx; panY -= dy;
                 zoomLevel = newZoomLevel; updateTransform(); updateStatusBar(); clearPreviewCanvas();
                 // Redraw preview only if applicable tool is active
                 if (!isDrawingLine && !isDrawingContinuousLine) { // Don't redraw brush preview if drawing lines
                     if (currentTool === 'brush' || currentTool === 'eraser') {
                         drawBrushPreview(currentMousePos.x, currentMousePos.y);
                     }
                 } else if (isDrawingContinuousLine && lastContinuousLinePoint) { // Redraw marker
                     previewCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                     previewCtx.beginPath();
                     previewCtx.arc(lastContinuousLinePoint.x, lastContinuousLinePoint.y, 3 / zoomLevel, 0, Math.PI * 2);
                     previewCtx.fill();
                 }
             }

            // --- UI Feedback ---
            function showButtonFeedback(button, status, message = null, duration = 1500) {
                 if (!button) return;
                 // Preserve active state for hole remover
                 const isHoleRemoverActive = button.id === 'remove-inner-hole-btn' && button.classList.contains('active-hole-remover');

                 button.classList.remove('success', 'error', 'working', 'cancelling');
                 // Re-apply active class if needed
                 if (isHoleRemoverActive) button.classList.add('active-hole-remover');

                 const originalText = button.dataset.originalHtml || button.innerHTML;
                 if (!button.dataset.originalHtml) button.dataset.originalHtml = originalText;
                 const originalTitle = button.dataset.originalTitle || button.title;
                 if (!button.dataset.originalTitle) button.dataset.originalTitle = originalTitle;

                 const statusClass = `btn-feedback ${status}`;
                 button.classList.add(...statusClass.split(' '));

                 if (message) {
                      if (message.startsWith('<i class="fas ') || message.startsWith('<i class="fa ')) button.innerHTML = message;
                      else button.textContent = message;
                 }
                 button.disabled = (status === 'working' || status === 'cancelling');

                 if (button.feedbackTimeout) clearTimeout(button.feedbackTimeout);

                 const isPersistentStatus = status === 'working' || status === 'cancelling' || isHoleRemoverActive;

                 if (!isPersistentStatus) {
                      button.feedbackTimeout = setTimeout(() => {
                          button.classList.remove('success', 'error');
                          if (button.dataset.originalHtml) button.innerHTML = button.dataset.originalHtml;
                          if (button.dataset.originalTitle) button.title = button.dataset.originalTitle;
                          // button.disabled = !originalImage; // Let updateActionButtonsState handle disabling
                          delete button.dataset.originalHtml;
                          delete button.dataset.originalTitle;
                          updateActionButtonsState(); // Update all buttons after feedback
                      }, duration);
                 } else if (button.id === 'remove-inner-hole-btn' && !isHoleRemoverActive) {
                     // Special handling for hole remover button feedback is within removeInnerHoleAt if it's NOT active
                     // If it IS active, the feedback persists until cancelled or clicked again
                 } else {
                    // Keep working/cancelling state until explicitly removed
                 }
            }

            function showProcessingOverlay(message) { processingStatusText.textContent = message || "Procesando..."; processingOverlay.classList.remove('hidden'); }
            function hideProcessingOverlay() { processingOverlay.classList.add('hidden'); }

            // --- Export / Copy / Paste ---
            async function createFinalImageBlob(format = 'image/png') {
                 if (!originalImage || !maskCanvas) return null; console.log("Creando Blob final...");
                 const finalCanvas = document.createElement('canvas'); finalCanvas.width = originalImage.naturalWidth; finalCanvas.height = originalImage.naturalHeight;
                 const finalCtx = finalCanvas.getContext('2d'); if (!finalCtx) { console.error("No se pudo crear contexto final."); return null; }
                 // Ensure the background is transparent before drawing
                 finalCtx.clearRect(0, 0, finalCanvas.width, finalCanvas.height);
                 // Draw original image
                 finalCtx.drawImage(originalImage, 0, 0);
                 // Use the mask to keep only desired parts
                 finalCtx.globalCompositeOperation = 'destination-in';
                 finalCtx.drawImage(maskCanvas, 0, 0);
                 // Reset composite operation for safety if canvas is reused (though it's not here)
                 finalCtx.globalCompositeOperation = 'source-over';
                 return new Promise((resolve) => finalCanvas.toBlob(resolve, format));
            }
            async function exportImage() {
                if (!originalImage || exportBtn.disabled) return; showButtonFeedback(exportBtn, 'working', 'Exportando...');
                 try {
                     const blob = await createFinalImageBlob(); if (!blob) throw new Error("No se pudo generar Blob.");
                     const url = URL.createObjectURL(blob); const a = document.createElement('a');
                     a.href = url; a.download = `${imageFilename}_sin_fondo.png`; document.body.appendChild(a);
                     a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                     showButtonFeedback(exportBtn, 'success', '<i class="fas fa-check"></i> Exportado');
                 } catch (error) { console.error("Error exportando:", error); alert(`Error al exportar: ${error.message}`); showButtonFeedback(exportBtn, 'error', '<i class="fas fa-times"></i> Error'); }
                 finally { updateActionButtonsState(); }
            }
            async function copyImageToClipboard() {
                 if (!originalImage || !isClipboardWriteSupported || copyBtn.disabled) return;
                 showButtonFeedback(copyBtn, 'working', 'Copiando...');
                 try {
                     const blob = await createFinalImageBlob('image/png'); if (!blob) throw new Error("No se pudo generar Blob.");
                     // Use the ClipboardItem constructor
                     const item = new ClipboardItem({ 'image/png': blob });
                     await navigator.clipboard.write([item]);
                     showButtonFeedback(copyBtn, 'success', '<i class="fas fa-check"></i> Copiado');
                 } catch (error) {
                     console.error("Error copiando:", error);
                     let msg = "Error al copiar.";
                     if (error.name === 'NotAllowedError') {
                         msg = "Permiso denegado por el navegador o sistema operativo.";
                     } else if (error.message.includes("large")) {
                         msg = "Imagen demasiado grande para el portapapeles.";
                     }
                     alert(`No se pudo copiar: ${msg}\n${error.message}`);
                     showButtonFeedback(copyBtn, 'error', '<i class="fas fa-times"></i> Error');
                 } finally {
                     updateActionButtonsState();
                 }
            }
            async function handlePasteButtonClick() {
                 if (!isClipboardReadSupported || pasteBtn.disabled) return; console.log("Intentando pegar (botón)...");
                 showButtonFeedback(pasteBtn, 'working', 'Pegando...');
                 try {
                      // Check permission status first, although read() might prompt if needed
                      const permission = await navigator.permissions.query({ name: 'clipboard-read' });
                      console.log("Clipboard read permission state:", permission.state);
                      if (permission.state === 'denied') throw new Error("Permiso denegado explícitamente.");

                      const clipboardItems = await navigator.clipboard.read();
                      let imageFound = false;
                      for (const item of clipboardItems) {
                          const imageType = item.types.find(type => type.startsWith("image/"));
                          if (imageType) {
                               console.log(`Imagen encontrada en portapapeles: ${imageType}`);
                               const blob = await item.getType(imageType);
                               handleFile(new File([blob], "imagen_pegada.png", { type: imageType }));
                               imageFound = true;
                               break; // Process first image found
                          }
                      }
                      if (imageFound) showButtonFeedback(pasteBtn, 'success', '<i class="fas fa-check"></i> Pegado');
                      else { console.log("No se encontró imagen en el portapapeles."); showButtonFeedback(pasteBtn, 'error', 'No hay imagen', 1000); }
                 } catch (error) {
                     console.error("Error pegando desde el portapapeles:", error);
                     let msg = "Error al pegar.";
                     if (error.name === 'NotAllowedError' || error.message.includes("denied")) {
                         msg = "Permiso denegado. Puede que necesites hacer clic en la página o conceder permisos.";
                     } else if (error.name === 'SecurityError') {
                          msg = "Error de seguridad. La página debe ser HTTPS o localhost para pegar.";
                     } else if (error.message.includes("No valid data found")) {
                          msg = "No hay datos de imagen válidos en el portapapeles.";
                     }
                     alert(`No se pudo pegar: ${msg}\n${error.message}`);
                     showButtonFeedback(pasteBtn, 'error', '<i class="fas fa-times"></i> Error');
                 } finally {
                     updateActionButtonsState();
                 }
            }
            function handleClipboardPaste(clipboardData) {
                 if (!clipboardData?.items) return false; console.log("Manejando evento paste (Ctrl+V)...");
                 let imageFound = false;
                 // Iterate through items using a standard for loop or for...of
                 for (const item of clipboardData.items) {
                     if (item.kind === 'file' && item.type.startsWith('image/')) {
                         const file = item.getAsFile();
                         if (file) {
                             console.log(`   Imagen encontrada via evento paste: ${file.type}, ${file.name}`);
                             handleFile(file);
                             imageFound = true;
                             break; // Process the first image file found
                         }
                     }
                 }
                 if(!imageFound) console.log("   No se encontraron archivos de imagen en el evento paste.");
                 return imageFound; // Return true if an image was processed to prevent default paste behavior
            }

            // --- Color Distance Utility ---
            function colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2; const dg = g1 - g2; const db = b1 - b2; return dr * dr + dg * dg + db * db; }

            // --- Flood Fill Background Removal (Edge Based) ---
            function floodFillMask(originalData, maskData, startX, startY, toleranceSq, visited) {
                const width = originalData.width; const height = originalData.height;
                const originalPixels = originalData.data; const maskPixels = maskData.data;
                // Basic boundary and visited check
                if (startX < 0 || startX >= width || startY < 0 || startY >= height || visited[startY][startX]) return false; // Indicate no work done here

                const startIndex = (startY * width + startX) * 4;
                const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2];
                const startA = originalPixels[startIndex + 3];

                // Ignore fully transparent pixels in the original image as start points
                // Also ignore pixels that are already fully transparent in the mask
                if (startA < 128 || maskPixels[startIndex + 3] < 1) {
                     visited[startY][startX] = true; // Mark as visited even if ignored
                     return false; // No fill started
                }

                const queue = [[startX, startY]];
                visited[startY][startX] = true;
                maskPixels[startIndex + 3] = 0; // Make the start pixel transparent in the mask
                let pixelsFilled = 1;
                let iterations = 0; const maxIterations = width * height * 1.5; // Safety limit

                while (queue.length > 0) {
                    iterations++;
                    // Check for cancellation request periodically
                    if (iterations % 500 === 0) {
                        if (cancelFloodFillRequest) {
                             console.log(`   *** Cancelación detectada DENTRO de floodFillMask desde (${startX}, ${startY}) ***`);
                             return true; // Indicate cancellation occurred
                        }
                    }
                    // Safety break
                    if (iterations > maxIterations) {
                        console.warn(`Flood fill (edge) excedió límite de iteraciones desde (${startX}, ${startY}). Deteniendo.`);
                        break;
                    }

                    const [x, y] = queue.shift();

                    // Check 4 neighbors (Up, Down, Left, Right)
                    const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ];

                    for (const [nx, ny] of neighbors) {
                        // Check boundaries
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                             const nIndex = (ny * width + nx) * 4;
                             const nA = originalPixels[nIndex + 3];

                             // Only process if the neighbor is not fully transparent in original
                             // and is currently opaque in the mask
                             if (nA >= 128 && maskPixels[nIndex + 3] > 128) {
                                 const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2];
                                 const distSq = colorDistance(startR, startG, startB, nR, nG, nB);

                                 // If color is within tolerance, add to queue and make transparent
                                 if (distSq <= toleranceSq) {
                                     visited[ny][nx] = true;
                                     queue.push([nx, ny]);
                                     maskPixels[nIndex + 3] = 0; // Make transparent in mask
                                     pixelsFilled++;
                                 }
                             } else {
                                 // Mark as visited even if skipped (transparent or already masked)
                                 visited[ny][nx] = true;
                             }
                        }
                    }
                }
                // console.log(`   Flood fill from (${startX}, ${startY}) completed. Pixels: ${pixelsFilled}`);
                return false; // Indicate completed without cancelling
            }

            async function handleRemoveBackgroundByFloodFill() {
                console.log(`%c>>> handleRemoveBackgroundByFloodFill EJECUTADO - ${new Date().toLocaleTimeString()}`, 'color: blue; font-weight: bold; font-size: 1.2em;');
                 if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache) {
                     console.warn("Flood Fill (edge) cancelado: Faltan elementos o cache de imagen original.");
                     alert("Error: No se pueden leer los píxeles originales para el fondo automático.");
                     return;
                 }
                 if (isFloodFilling) { console.warn("Flood Fill (edge) ya en proceso."); return; }
                 if (isDrawing || isDrawingLine || isDrawingContinuousLine) { console.warn("Flood Fill (edge) bloqueado: Edición manual en curso."); return;} // Block if drawing

                cancelContinuousLineDrawing(true); // Ensure cancelled

                isFloodFilling = true; cancelFloodFillRequest = false;
                updateActionButtonsState();
                showButtonFeedback(removeEdgeBgBtn, 'working', 'Analizando...');
                showProcessingOverlay('Analizando bordes...');
                // Brief pause to allow UI update before heavy computation
                await new Promise(resolve => setTimeout(resolve, 50));

                try {
                    if (cancelFloodFillRequest) throw new Error("Cancelled"); // Check before starting

                    processingStatusText.textContent = "Procesando fondo...";
                    const tolerance = parseInt(edgeColorToleranceSlider.value, 10);
                    const toleranceSq = tolerance * tolerance * 3; // Square tolerance for distance check
                    console.log(`   Tolerancia (edge): ${tolerance}, Dist^2 <= ${toleranceSq.toFixed(0)}`);

                    const originalData = originalImageDataCache;
                    // Get a FRESH copy of the mask data to work on
                    const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                    const width = maskImageData.width; const height = maskImageData.height;
                    // Initialize visited array
                    const visited = Array(height).fill(null).map(() => Array(width).fill(false));

                    console.log("   Iniciando bucles Flood Fill (edge) desde bordes...");
                    const startTime = performance.now();
                    let cancelledInsideLoop = false;

                    // Process top and bottom edges
                    for (let x = 0; x < width; x++) {
                         if (cancelFloodFillRequest) { cancelledInsideLoop = true; break; }
                         if (floodFillMask(originalData, maskImageData, x, 0, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                         if (floodFillMask(originalData, maskImageData, x, height - 1, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                    }
                    // Process left and right edges (skip corners already done)
                    if (!cancelledInsideLoop) {
                         for (let y = 1; y < height - 1; y++) {
                             if (cancelFloodFillRequest) { cancelledInsideLoop = true; break; }
                             if (floodFillMask(originalData, maskImageData, 0, y, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                             if (floodFillMask(originalData, maskImageData, width - 1, y, toleranceSq, visited)) { cancelledInsideLoop = true; break; }
                         }
                    }

                    const endTime = performance.now();
                    console.log(`   Bucles Flood Fill (edge) terminados en ${((endTime - startTime)/1000).toFixed(2)}s. Cancelado en bucle: ${cancelledInsideLoop}`);

                    // Check cancellation status again after loops finish
                    if (cancelFloodFillRequest || cancelledInsideLoop) throw new Error("Cancelled");

                    console.log("   Aplicando máscara (edge)...");
                    maskCtx.putImageData(maskImageData, 0, 0);
                    console.log("   Guardando y renderizando (edge)...");
                    saveStateToHistory();
                    renderCanvas(); // Use renderCanvas which handles composition
                    console.log("<<< Fondo Automático (Edge) Completado.");
                    showButtonFeedback(removeEdgeBgBtn, 'success', '<i class="fas fa-check"></i> Hecho');

                } catch (error) {
                    if (error.message === "Cancelled") {
                        console.log("%cProceso Flood Fill (Edge) CANCELADO.", 'color: orange; font-weight: bold;');
                        showButtonFeedback(removeEdgeBgBtn, 'error', 'Cancelado', 1500);
                        // Restore previous mask state? Maybe not, user might want to keep partial result.
                        // If restoration is needed, could reload last history state here.
                    } else {
                        console.error("Error durante Flood Fill (Edge):", error);
                        alert(`Error en proceso automático: ${error.message}`);
                        showButtonFeedback(removeEdgeBgBtn, 'error', '<i class="fas fa-times"></i> Error');
                    }
                } finally {
                     console.log("   Finally Flood Fill (Edge): Limpiando estado.");
                    isFloodFilling = false;
                    cancelFloodFillRequest = false; // Reset flag
                    hideProcessingOverlay();
                     // Clear 'working'/'cancelling' state from button unless it got success/error
                     if (!removeEdgeBgBtn.classList.contains('success') && !removeEdgeBgBtn.classList.contains('error')) {
                         removeEdgeBgBtn.classList.remove('working', 'cancelling');
                         if (removeEdgeBgBtn.dataset.originalHtml) removeEdgeBgBtn.innerHTML = removeEdgeBgBtn.dataset.originalHtml;
                         if (removeEdgeBgBtn.dataset.originalTitle) removeEdgeBgBtn.title = removeEdgeBgBtn.dataset.originalTitle;
                         delete removeEdgeBgBtn.dataset.originalHtml;
                         delete removeEdgeBgBtn.dataset.originalTitle;
                     }
                    updateActionButtonsState(); // Re-enable/disable buttons appropriately
                }
            }

            // --- Inner Hole Removal Logic ---
            function activateInnerHoleClickMode() {
                if (!originalImage || isFloodFilling || waitingForInnerHoleClick || isDrawing || isDrawingLine || isDrawingContinuousLine) return; // Block if drawing/processing
                console.log("Activando modo 'Eliminar Hueco Interno'");
                cancelContinuousLineDrawing(true); // Ensure any continuous line is cancelled

                setActiveTool('hole-remover'); // This also updates cursor via getToolCursor
                waitingForInnerHoleClick = true;
                removeInnerHoleBtn.classList.add('active-hole-remover');

                // Clear any previous feedback timeout
                if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);

                // Save original state if not already saved
                if (!removeInnerHoleBtn.dataset.originalHtml) removeInnerHoleBtn.dataset.originalHtml = removeInnerHoleBtn.innerHTML;
                if (!removeInnerHoleBtn.dataset.originalTitle) removeInnerHoleBtn.dataset.originalTitle = removeInnerHoleBtn.title;

                // Update button text and state
                removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                updateStatusBar();
                updateActionButtonsState(); // Disable other tools etc.
                clearPreviewCanvas(); // Ensure no brush preview is shown
            }

            function cancelInnerHoleClickMode() {
                if (!waitingForInnerHoleClick) return;
                console.log("Cancelando modo 'Eliminar Hueco Interno'");
                waitingForInnerHoleClick = false;
                removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error', 'working', 'cancelling'); // Clear all states

                // Clear timeout
                if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);

                // Restore original button content if available
                if (removeInnerHoleBtn.dataset.originalHtml) {
                    removeInnerHoleBtn.innerHTML = removeInnerHoleBtn.dataset.originalHtml;
                    delete removeInnerHoleBtn.dataset.originalHtml;
                } else {
                     removeInnerHoleBtn.innerHTML = '<i class="fas fa-highlighter mr-1"></i> Eliminar Hueco Interno'; // Default fallback
                }
                 if (removeInnerHoleBtn.dataset.originalTitle) {
                    removeInnerHoleBtn.title = removeInnerHoleBtn.dataset.originalTitle;
                    delete removeInnerHoleBtn.dataset.originalTitle;
                 }

                setActiveTool('eraser'); // Switch back to a default tool (e.g., eraser)
                updateStatusBar();
                updateActionButtonsState(); // Re-enable other buttons
            }

            function removeInnerHoleAt(startX, startY) {
                console.log(`%c>>> removeInnerHoleAt (${startX.toFixed(0)}, ${startY.toFixed(0)})`, 'color: purple; font-weight: bold;');
                 if (!originalImage || !maskCtx || !maskCanvas || !originalImageDataCache || !waitingForInnerHoleClick) {
                     console.warn("Eliminar Hueco abortado: Faltan elementos, cache, o modo no activo.");
                     // Provide feedback even if aborted early
                      if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);
                      removeInnerHoleBtn.classList.add('error');
                      removeInnerHoleBtn.innerHTML = '<i class="fas fa-times"></i> Error Prep.';
                      holeRemoverFeedbackTimeout = setTimeout(() => {
                          // Reset to 'Click en Hueco' state if still waiting
                          if (waitingForInnerHoleClick) {
                               removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                               removeInnerHoleBtn.classList.remove('error');
                          } else {
                              cancelInnerHoleClickMode(); // Should already be cancelled if !waiting...
                          }
                      }, 1000);
                     return;
                 }

                 const width = maskCanvas.width; const height = maskCanvas.height;
                 startX = Math.floor(startX); startY = Math.floor(startY);

                 // Boundary check
                 if (startX < 0 || startX >= width || startY < 0 || startY >= height) {
                     console.log("   Clic fuera de los límites.");
                      // No visual feedback needed for out-of-bounds click, user can just click again
                     return;
                 }

                 let pixelsChanged = 0;
                 let success = false;
                 let message = '';
                 let statusClass = 'error'; // Default to error

                 try {
                    // Get current mask data
                    const maskImageData = maskCtx.getImageData(0, 0, width, height);
                    const maskPixels = maskImageData.data;
                    // Use cached original image data
                    const originalPixels = originalImageDataCache.data;
                    const tolerance = parseInt(edgeColorToleranceSlider.value, 10);
                    const toleranceSq = tolerance * tolerance * 3;
                    const startIndex = (startY * width + startX) * 4;

                    // Check if the clicked pixel in the *mask* is already transparent
                    if (maskPixels[startIndex + 3] < 128) {
                        console.log("   El área clicada ya es transparente en la máscara.");
                        message = 'Ya Transparente';
                        statusClass = 'error'; // Or maybe 'info'? But 'error' fits button style
                        success = false; // No change made
                    } else {
                        // Pixel is opaque in the mask, proceed with flood fill
                        const startR = originalPixels[startIndex]; const startG = originalPixels[startIndex + 1]; const startB = originalPixels[startIndex + 2];
                        console.log(`   Color original en clic: R=${startR} G=${startG} B=${startB}, Tolerancia^2: ${toleranceSq}`);

                        // Flood fill logic (similar to edge fill, but operates on mask based on original color)
                        const visited = Array(height).fill(null).map(() => Array(width).fill(false));
                        const queue = [[startX, startY]];
                        visited[startY][startX] = true;
                        maskPixels[startIndex + 3] = 0; // Make start pixel transparent in mask data
                        pixelsChanged = 1;
                        let iterations = 0; const maxIterations = width * height; // Safety limit

                        while (queue.length > 0) {
                            iterations++;
                            if (iterations > maxIterations) {
                                console.warn(`Flood fill (hueco) excedió límite de iteraciones desde (${startX}, ${startY}).`);
                                break;
                            }

                            const [x, y] = queue.shift();
                            const neighbors = [ [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y] ];

                            for (const [nx, ny] of neighbors) {
                                // Check boundaries and visited
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                                    const nIndex = (ny * width + nx) * 4;
                                    // Check if neighbor is currently opaque in the mask
                                    if (maskPixels[nIndex + 3] > 128) {
                                        // Check color similarity in the original image
                                        const nR = originalPixels[nIndex]; const nG = originalPixels[nIndex + 1]; const nB = originalPixels[nIndex + 2];
                                        const distSq = colorDistance(startR, startG, startB, nR, nG, nB);
                                        // If color is similar, mark visited, add to queue, make transparent
                                        if (distSq <= toleranceSq) {
                                            visited[ny][nx] = true;
                                            queue.push([nx, ny]);
                                            maskPixels[nIndex + 3] = 0;
                                            pixelsChanged++;
                                        }
                                        // If color not similar, mark visited but don't process further from here
                                        // else { visited[ny][nx] = true; } // Not strictly needed as it's marked below anyway if skipped
                                    } else {
                                        // Neighbor already transparent in mask, just mark visited
                                        visited[ny][nx] = true;
                                    }
                                }
                            } // End neighbor loop
                        } // End while loop

                        console.log(`   Flood fill (hueco) completado. ${pixelsChanged} píxeles de máscara borrados.`);
                        if (pixelsChanged > 0) {
                            maskCtx.putImageData(maskImageData, 0, 0); // Apply changes to the actual mask canvas
                            saveStateToHistory();
                            requestRender(); // Update the main canvas view
                            message = '<i class="fas fa-check"></i> Hueco Borrado'; statusClass = 'success'; success = true;
                        } else {
                            // This case should be rare if the start pixel was opaque, maybe only if tolerance is 0?
                            message = 'No Cambios'; statusClass = 'error'; success = false;
                        }
                    } // End else (pixel was not transparent)
                 } catch (error) {
                    console.error("Error durante la eliminación de hueco interno:", error);
                    alert(`Error al eliminar hueco: ${error.message}`);
                    message = '<i class="fas fa-times"></i> Error Proc.'; statusClass = 'error'; success = false;
                 } finally {
                     // Provide feedback on the button
                     const feedbackDuration = success ? 1000 : 1500; // Shorter for success
                     if (holeRemoverFeedbackTimeout) clearTimeout(holeRemoverFeedbackTimeout);

                     // Temporarily remove active class to show feedback color, then restore if needed
                     removeInnerHoleBtn.classList.remove('active-hole-remover', 'success', 'error');
                     removeInnerHoleBtn.classList.add(statusClass);
                     removeInnerHoleBtn.innerHTML = message;

                     holeRemoverFeedbackTimeout = setTimeout(() => {
                         removeInnerHoleBtn.classList.remove('success', 'error');
                         // If still in hole-clicking mode, restore the active state and prompt
                         if (waitingForInnerHoleClick) {
                              removeInnerHoleBtn.classList.add('active-hole-remover');
                              removeInnerHoleBtn.innerHTML = '<i class="fas fa-hand-pointer mr-1"></i> Haz Clic en Hueco';
                         } else {
                             // If mode was somehow cancelled during feedback, ensure it's fully cancelled
                             cancelInnerHoleClickMode();
                         }
                     }, feedbackDuration);
                 }
            }


        }); // End DOMContentLoaded
    </script>
</body>
</html>
